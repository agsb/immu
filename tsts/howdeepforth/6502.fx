
 : #%# 3 ;

 : #%# 5 ;

 : #%# 6 ;
 
 CODE EMIT XSAVE STX, BOT 1+ LDA, 7F # AND, 72C6 JSR, XSAVE LDX, POP JMP, 
 CODE KEY XSAVE STX, BEGIN, BEGIN, 8 # LDX, BEGIN, 6E02 LDA, .A LSR, CS END, 7320 JSR, BEGIN, 731D JSR, 0 X) CMP, 0 X) CMP, 0 X) CMP, 0 X) CMP, 0 X) CMP, 6E02 LDA, .A LSR, PHP, TYA, .A LSR, PLP, CS IF, 80 # ORA, THEN, TAY, DEX, 0= END, 731D JSR, FF # EOR, 7F # AND, 0= NOT END, 7F # CMP, 0= NOT END, XSAVE LDX, PUSH0A JMP, 
 CODE CR XSAVE STX, 728A JSR, XSAVE LDX, NEXT JMP,
 CODE ?TERMINAL 1 # LDA, 6E02 BIT, 0= NOT IF, BEGIN, 731D JSR, 6E02 BIT, 0= END, INY, THEN, TYA, PUSH0A JMP, 
DECIMAL ;S
 
 : #%# 7 ;
 
 CODE HOME FC58 JSR, NEXT JMP, 
 CODE SCROLL FC70 JSR, NEXT JMP, HERE ' KEY 2 - ! FD0C JSR, 7F # AND, PUSH0A JMP, HERE ' EMIT 2 - ! BOT 1+ LDA, 80 # ORA, FDED JSR, POP JMP, HERE ' CR 2 - ! FD8E JSR, NEXT JMP, HERE ' ?TERMINAL 2 - ! C000 BIT, 0< IF, BEGIN, C010 BIT, C000 BIT, 0< NOT END, INY, THEN, TYA, PUSH0A JMP, 
 
 : #%# 8 ;

 CODE KEY 8A58 JSR, 7F # AND, PUSH0A JMP,
 CODE EMIT BOT 1+ LDA, 8A47 JSR, POP JMP,
 CODE CR 834D JSR, NEXT JMP,
 CODE ?TERMINAL 8B3C JSR, CS IF, BEGIN, 8B3C JSR, CS NOT END, INY, THEN, TYA, PUSH0A JMP, 
 
 : #%# 12 ;

 : #%# 13 ;
 
 CODE LIT IP )Y LDA, PHA, IP INC, 0= IF, IP 1+ INC, THEN, IP )Y LDA, IP INC, 0= IF, IP 1+ INC, THEN, LABEL PUSH DEX, DEX, LABEL PUT BOT 1+ STA, PLA, BOT STA, LABEL NEXT 1 # LDY, IP )Y LDA, W 1+ STA, DEY, IP )Y LDA, W STA, CLC, IP LDA, 2 # ADC, IP STA, CS IF, IP 1+ INC, THEN, W 1 - JMP, 

 : #%# 14 ;

 CODE SETUP HERE 2+ , IP )Y LDA, PHA, TYA, 'T LIT 0B + 0= NOT END, LABEL SETUP .A ASL, N 1 - STA, BEGIN, BOT LDA, N ,Y STA, INX, INY, N 1 - CPY, 0= END, 0 # LDY, RTS,
 CODE EXECUTE BOT LDA, W STA, BOT 1+ LDA, W 1+ STA, INX, INX, W 1 - JMP, 

 : #%# 15 
 CODE BRANCH CLC, IP )Y LDA, IP ADC, PHA, INY, IP )Y LDA, IP 1+ ADC, IP 1+ STA, PLA, IP STA, NEXT 2+ JMP,
 CODE 0BRANCH INX, INX, FE ,X LDA, FF ,X ORA, ' BRANCH 0= NOT END, LABEL BUMP: CLC, IP LDA, 2 # ADC, IP STA, CS IF, IP 1+ INC, THEN, NEXT JMP, 

 : #%# 16 ;
 
 CODE (LOOP) XSAVE STX, TSX, R INC, 0= IF, R 1+ INC, THEN, LABEL L1: CLC, R 2+ LDA, R SBC, R 3 + LDA, R 1+ SBC, LABEL L2: XSAVE LDX, .A ASL, ' BRANCH CS END, PLA, PLA, PLA, PLA, BUMP: JMP, 
 CODE (+LOOP) INX, INX, XSAVE STX, FF ,X LDA, PHA, PHA, FE ,X LDA, TSX, INX, INX, CLC, R ADC, R STA, PLA, R 1 + ADC, R 1 + STA, PLA, L1: 0< END, CLC, R LDA, R 2+ SBC, R 1+ LDA, R 3 + SBC, L2: JMP, 

 : #%# 17 ;
 
 CODE (DO) SEC 1+ LDA, PHA, SEC LDA, PHA, BOT 1+ LDA, PHA, BOT LDA, PHA, LABEL POPTWO INX, INX, LABEL POP INX, INX, NEXT JMP,
 CODE I NEXT JMP, 

 : #%# 18 

 CODE DIGIT SEC, SEC LDA, 30 # SBC, 0< NOT IF, 0A # CMP, 0< NOT IF, SEC, 07 # SBC, 0A # CMP, 0< NOT IF, SWAP THEN, BOT CMP, 0< IF, SEC STA, 1 # LDA, PHA, TYA, PUT JMP, THEN, THEN, THEN, TYA, PHA, INX, INX, PUT JMP, 

 : #%# 19 ;
 
 CODE (FIND) 2 # LDA, SETUP JSR, XSAVE STX, BEGIN, 0 # LDY, N )Y LDA, N 2+ )Y EOR, 3F # AND, 0= IF, BEGIN, INY, N )Y LDA, N 2+ )Y EOR, .A ASL, 0= IF, SWAP CS END, XSAVE LDX, DEX, DEX, DEX, DEX, CLC, TYA, 5 # ADC, N ADC, SEC STA, 0 # LDY, TYA, N 1+ ADC, SEC 1+ STA, BOT 1+ STY, N )Y LDA, BOT STA, 1 # LDA, PHA, PUSH JMP, THEN, CS NOT IF, SWAP THEN, BEGIN, INY, N )Y LDA, 0< END, THEN, INY, N )Y LDA, TAX, INY, N )Y LDA, N 1+ STA, N STX, N ORA, 0= END, XSAVE LDX, 0 # LDA, PHA, PUSH JMP, 

 : #%# 20 ;
 
 CODE ENCLOSE 2 # LDA, SETUP JSR, TXA, SEC, 8 # SBC, TAX, SEC 1+ STY, BOT 1+ STY, DEY, BEGIN, INY, N 2+ )Y LDA, N CMP, 0= NOT END, BOT 4 + STY, BEGIN, N 2+ )Y LDA, 0= IF, SEC STY, BOT STY, TYA, BOT 4 + CMP, 0= IF, SEC INC, THEN, NEXT JMP, THEN, SEC STY, INY, N CMP, 0= END, BOT STY, NEXT JMP,


 : #%# 21 
 
 CODE EMIT NEXT JMP,
 CODE KEY NEXT JMP,
 CODE ?TERMINAL NEXT JMP,
 CODE CR NEXT JMP,

 : #%# 22 ;
 
 CODE CMOVE 3 # LDA, SETUP JSR, BEGIN, BEGIN, N CPY, 0= IF, N 1+ DEC, 0< IF, NEXT JMP, THEN, THEN, N 4 + )Y LDA, N 2+ )Y STA, INY, 0= END, N 5 + INC, N 3 + INC, JMP, 
 
 : #%# 23 ;
 
 CODE U* SEC LDA, N STA, SEC STY, SEC 1+ LDA, N 1+ STA, SEC 1+ STY, 10 # LDY, BEGIN, BOT 2+ ASL, BOT 3 + ROL, BOT ROL, BOT 1+ ROL, CS IF, CLC, N LDA, BOT 2 + ADC, BOT 2 + STA, N 1+ LDA, BOT 3 + ADC, BOT 3 + STA, CS IF, BOT INC, 0= IF, BOT 1+ INC, ENDIF, ENDIF, ENDIF, DEY, 0= UNTIL, NEXT JMP, 

 : #%# 24 ;

 CODE U/ SEC 2 + LDA, SEC LDY, SEC 2 + STY, .A ASL, SEC STA, SEC 3 + LDA, SEC 1+ LDY, SEC 3 + STY, .A ROL, SEC 1+ STA, 10 # LDA, N STA, BEGIN, SEC 2 + ROL, SEC 3 + ROL, SEC, SEC 2 + LDA, BOT SBC, TAY, SEC 3 + LDA, BOT 1+ SBC, CS IF, SEC 2+ STY, SEC 3 + STA, THEN, SEC ROL, SEC 1+ ROL, N DEC, 0= END, POP JMP, 
 
 : #%# 25 ;
 
 CODE AND BOT LDA, SEC AND, PHA, BOT 1+ LDA, SEC 1+ AND, INX, INX, PUT JMP,
 CODE OR BOT LDA, SEC ORA, PHA, BOT 1+ LDA, SEC 1 + ORA, INX, INX, PUT JMP,
 CODE XOR BOT LDA, SEC EOR, PHA, BOT 1+ LDA, SEC 1+ EOR, INX, INX, PUT JMP, 

 : #%# 26 ;

 CODE SP@ TXA, LABEL PUSH0A PHA, 0 # LDA, PUSH JMP,
 CODE SP! 06 # LDY, UP )Y LDA, TAX, NEXT JMP,
 CODE RP! XSAVE STX, 08 # LDY, UP )Y LDA, TAX, TXS, XSAVE LDX, NEXT JMP,
 CODE ;S PLA, IP STA, PLA, IP 1+ STA, NEXT JMP,

: #%# 27 ; 
 
 CODE LEAVE XSAVE STX, TSX, R LDA, R 2+ STA, R 1+ LDA, R 3 + STA, XSAVE LDX, NEXT JMP,
 CODE >R BOT 1+ LDA, PHA, BOT LDA, PHA, INX, INX, NEXT JMP,
 CODE R> DEX, DEX, PLA, BOT STA, PLA, BOT 1+ STA, NEXT JMP,
 CODE R XSAVE STX, TSX, R LDA, PHA, R 1+ LDA, XSAVE LDX, PUSH JMP, 

 : #%# 28 ;
 
 CODE 0= BOT LDA, BOT 1+ ORA, BOT 1+ STY, 0= IF, INY, THEN, BOT STY, NEXT JMP,
 CODE 0< BOT 1+ ASL, TYA, .A ROL, BOT 1+ STY, BOT STA, NEXT JMP, 
 
 : #%# 29 ; 

 CODE + CLC, BOT LDA, SEC ADC, SEC STA, BOT 1+ LDA, SEC 1+ ADC, SEC 1+ STA, INX, INX, NEXT JMP, 
 CODE D+ CLC, BOT 2 + LDA, BOT 6 + ADC, BOT 6 + STA, BOT 3 + LDA, BOT 7 + ADC, BOT 7 + STA, BOT LDA, BOT 4 + ADC, BOT 4 + STA, BOT 1 + LDA, BOT 5 + ADC, BOT 5 + STA, POPTWO JMP, 
 CODE MINUS SEC, TYA, BOT SBC, BOT STA, TYA, BOT 1+ SBC, BOT 1+ STA, NEXT JMP, 
 CODE DMINUS SEC, TYA, BOT 2 + SBC, BOT 2 + STA, TYA, BOT 3 + SBC, BOT 3 + STA, 1 BYTE.IN MINUS JMP,

 : #%# 30 ;

 CODE OVER SEC LDA, PHA, SEC 1+ LDA, PUSH JMP,
 CODE DROP POP -2 BYTE.IN DROP ! JMP, 
 CODE SWAP SEC LDA, PHA, BOT LDA, SEC STA, SEC 1+ LDA, BOT 1+ LDY, SEC 1+ STY, PUT JMP,
 CODE DUP BOT LDA, PHA, BOT 1+ LDA, PUSH JMP, 

 : #%# 31 ;

 CODE +! CLC, BOT X) LDA, SEC ADC, BOT X) STA, BOT INC, 0= IF, BOT 1+ INC, THEN, BOT X) LDA, SEC 1+ ADC, BOT X) STA, POPTWO JMP,
 CODE TOGGLE SEC X) LDA, BOT EOR, SEC X) STA, POPTWO JMP, 

 : #%# 32 ;

 CODE @ BOT X) LDA, PHA, BOT INC, 0= IF, BOT 1+ INC, THEN, BOT X) LDA, PUT JMP,
 CODE C@ BOT X) LDA, BOT STA, BOT 1+ STY, NEXT JMP,
 CODE ! SEC LDA, BOT X) STA, BOT INC, 0= IF, BOT 1+ INC, THEN, SEC 1+ LDA, BOT X) STA, POPTWO JMP,
 CODE C! SEC LDA, BOT X) STA, POPTWO JMP, DECIMAL ;

 # 33 ( :, ;
 : : ?EXEC !CSP CURRENT @ CONTEXT ! CREATE ] ;
 CODE DOCOL IP 1+ LDA, PHA, IP LDA, PHA, CLC, W LDA, 2 # ADC, IP STA, TYA, W 1+ ADC, IP 1+ STA, NEXT JMP, 
 : ; ?CSP COMPILE ;S SMUDGE [ ; IMMEDIATE 

 : #%# 34 ;
 : CONSTANT CREATE SMUDGE , ;
 CODE DOCON 2 # LDY, W )Y LDA, PHA, INY, W )Y LDA, PUSH JMP, 
 : VARIABLE CONSTANT ;
 CODE DOVAR CLC, W LDA, 2 # ADC, PHA, TYA, W 1+ ADC, PUSH JMP, 
 : USER CONSTANT ;
 CODE DOUSE 2 # LDY, CLC, W )Y LDA, UP ADC, PHA, 0 # LDA, UP 1+ ADC, PUSH JMP, 

 : #%# 35 ;
 HEX 
 00 CONSTANT 0 
 01 CONSTANT 1 
 02 CONSTANT 2 
 03 CONSTANT 3 
 20 CONSTANT BL 
 40 CONSTANT C/L 
 3BE0 CONSTANT FIRST 
 4000 CONSTANT LIMIT 
 80 CONSTANT B/BUF 
 8 CONSTANT B/SCR 
 00 +ORIGIN 
 : +ORIGIN LITERAL + ;

 : #%# 36 
 HEX 
 0A USER TIB 
 0C USER WIDTH 
 0E USER WARNING 
 10 USER FENCE 
 12 USER DP 
 14 USER VOC-LINK 
 16 USER BLK 
 18 USER IN 
 1A USER OUT 
 1C USER SCR 

 : #%# 37 
 1E USER OFFSET 
 20 USER CONTEXT 
 22 USER CURRENT 
 24 USER STATE 
 26 USER BASE 
 28 USER DPL 
 2A USER PLO 
 2C USER CSP 
 2E USER R# 
 30 USER HLD 

 : #%# 38 ;
 : 1+ 1 + ;
 : 2+ 2 + ;
 : HERE DP @ ;
 : ALLOT DP +! ;
 : , HERE ! 2 ALLOT ;
 : C, HERE C! 1 ALLOT ;
 : - MINUS + ;
 : = - 0= ;
 : < - 0< ;
 : > SWAP < ;
 : ROT >R SWAP R> SWAP ;
 : SPACE BL EMIT ;
 : -DUP DUP IF DUP ENDIF ;
 
: #%# 39 
: TRAVERSE SWAP BEGIN OVER + 7F OVER C@ < UNTIL SWAP DROP ;
 : LATEST CURRENT @ @ ;
 : LFA 4 - ;
 : CFA 2 - ;
 : NFA 5 - -1 TRAVERSE ;
 : PFA 1 TRAVERSE 5 + ;
 

: #%# 40 ;
 : !CSP SP@ CSP ! ;
 : ?ERROR SWAP IF ERROR ELSE DROP ENDIF ;
 : ?COMP STATE @ 0= 11 ?ERROR ;
 : ?EXEC STATE @ 12 ?ERROR ;
 : ?PAIRS - 13 ?ERROR ;
 : ?CSP SP@ CSP @ - 14 ?ERROR ;
 : ?LOADING BLK @ 0= 16 ?ERROR ;
 
 : #%# 41 ;
 : COMPILE ?COMP R> DUP 2+ >R @ , ;
 : [ 0 STATE ! ;
 IMMEDIATE : ] C0 STATE ! ;
 : SMUDGE LATEST 20 TOGGLE ;
 : HEX 10 BASE ! ;
 : DECIMAL 0A BASE ! ;
 

 : #%# 42 ; 
 
 : R> LATEST PFA CFA ! ;
 : ;CODE ?CSP COMPILE [COMPILE] [ SMUDGE ;
 IMMEDIATE 

: #%# 43 ;
 : <BUILDS 0 CONSTANT ;
 : DOES> R> LATEST PFA ! ;
CODE IP 1+ LDA, PHA, IP LDA, PHA, 2 # LDY, W )Y LDA, IP STA, INY, W )Y LDA, IP 1+ STA, CLC, W LDA, 4 # ADC, PHA, W 1+ LDA, 00 # ADC, PUSH JMP, 

 : #%# 44 ;
 : COUNT DUP 1+ SWAP C@ ;
 : TYPE -DUP IF OVER + SWAP DO I C@ EMIT LOOP ELSE DROP ENDIF ;
 : -TRAILING DUP 0 DO OVER OVER + 1 - C@ BL - IF LEAVE ELSE 1 - ENDIF LOOP ;
 : R COUNT DUP 1+ R> + >R TYPE ;
 : ." 22 STATE @ IF COMPILE WORD HERE C@ 1+ ALLOT ELSE WORD HERE COUNT TYPE ENDIF ;
 IMMEDIATE
 
 : #%# 45 ;
 
 : EXPECT OVER + OVER DO KEY DUP 0E +ORIGIN @ = IF DROP 08 OVER I = DUP R> 2 - + >R - ELSE DUP 0D = IF LEAVE DROP BL 0 ELSE DUP ENDIF I C! 0 I 1+ ! ENDIF EMIT LOOP DROP ;
 : QUERY TIB @ 50 EXPECT 0 IN ! ;
 8081 HERE 
 : X BLK @ IF 1 BLK +! 0 IN ! BLK @ 7 AND 0= IF ?EXEC R> DROP ENDIF ELSE R> DROP ENDIF ;

 ! IMMEDIATE 
 : #%# 46 ;
 : FILL SWAP >R OVER C! DUP 1+ R> 1 - CMOVE ;
 : ERASE 0 FILL ;
 : BLANKS BL FILL ;
 : HOLD -1 HLD +! HLD @ C! ;
 : PAD HERE 44 + ;
 
 
 : #%# 47 ;
 : WORD BLK @ IF BLK @ BLOCK ELSE TIB @ ENDIF IN @ + SWAP ENCLOSE HERE 22 BLANKS IN +! OVER - >R R HERE C! + HERE 1+ R> CMOVE ;
 
 
 : #%# 48 ;
 
 : BEGIN 1+ DUP >R C@ BASE @ DIGIT WHILE SWAP BASE @ U* DROP ROT BASE @ U* D+ DPL @ 1+ IF 1 DPL +! ENDIF R> REPEAT R> ;
 : NUMBER 0 0 ROT DUP 1+ C@ 2D = DUP >R + -1 BEGIN DPL ! DUP C@ BL - WHILE DUP C@ 2E - 0 ?ERROR 0 REPEAT DROP R> IF DMINUS ENDIF ;
 : -FIND BL WORD HERE CONTEXT @ @ DUP 0= IF DROP HERE LATEST ENDIF ;
 
 : #%# 49 ;
 : ABORT ;
 : ERROR WARNING @ 0< IF ENDIF HERE COUNT TYPE ." ? " MESSAGE SP! IN @ BLK @ QUIT ;
 : ID. PAD 020 5F FILL DUP PFA LFA OVER - PAD SWAP CMOVE PAD COUNT 01F AND TYPE SPACE ;

 : #%# 50 ;
 
 : CREATE TIB HERE 0A0 + < 2 ?ERROR -FIND IF DROP NFA ID. 4 MESSAGE SPACE ENDIF HERE DUP C@ WIDTH @ MIN 1+ ALLOT DP C@ 0FD = ALLOT DUP A0 TOGGLE HERE 1 - 80 TOGGLE LATEST , CURRENT @ ! HERE 2+ , ;
 
 : #%# 51 ;
 : [COMPILE] -FIND 0= 0 ?ERROR DROP CFA , ;
 IMMEDIATE : LITERAL STATE @ IF COMPILE LIT , ENDIF ;
 IMMEDIATE : DLITERAL STATE @ IF SWAP [COMPILE] LITERAL [COMPILE] LITERAL ENDIF ;
 IMMEDIATE : ?STACK 09E SP@ < 1 ?ERROR SP@ 020 < 7 ?ERROR ;
 
 : #%# 52 ;
 : INTERPRET BEGIN -FIND IF STATE @ < IF CFA , ELSE CFA EXECUTE ENDIF ?STACK ELSE HERE NUMBER DPL @ 1+ IF [COMPILE] DLITERAL ELSE DROP [COMPILE] LITERAL ENDIF ?STACK ENDIF AGAIN ;
 : #%# 53 ;
 
 : IMMEDIATE LATEST 40 TOGGLE ;
 : VOCABULARY <BUILDS A081 , CURRENT @ CFA , HERE VOC-LINK @ , VOC-LINK ! DOES> 2+ CONTEXT ! ;
 VOCABULARY FORTH IMMEDIATE 
 : DEFINITIONS CONTEXT @ CURRENT ! ;
 : 29 WORD ;
 IMMEDIATE

 : #%# 54 ;
 : QUIT 0 BLK ! [COMPILE] [ BEGIN RP! CR QUERY INTERPRET STATE @ 0= IF ." OK" ENDIF AGAIN ;
 : ABORT SP! DECIMAL DR0 CR ." FORTH-65 V 4.0" [COMPILE] FORTH DEFINITIONS QUIT ;
 
 : #%# 55 ;
 
 CODE COLD HERE 02 +ORIGIN ! 0C +ORIGIN LDA, 'T FORTH 4 + STA, 0D +ORIGIN LDA, 'T FORTH 5 + STA, 15 # LDY, 0= IF, HERE 06 +ORIGIN ! 0F # LDY, THEN, 10 +ORIGIN LDA, UP STA, 11 +ORIGIN LDA, UP 1+ STA, BEGIN, 0C +ORIGIN ,Y LDA, UP )Y STA, DEY, 0< END, 'T ABORT 100 /MOD # LDA, IP 1+ STA, 
 : #%# LDA, IP STA, ;
 6C # LDA, W 1 - STA, 'T RP! JMP, 
 
 : #%# 56 ;
 
 CODE S->D BOT 1+ LDA, 0< IF, DEY, THEN,
 TYA, PHA, PUSH JMP, 
 : +- 0< IF MINUS ENDIF ;
 : D+- 0< IF DMINUS ENDIF ;
 : ABS DUP +- ;
 : DABS DUP D+- ;
 : MIN OVER OVER > IF SWAP ENDIF DROP ;
 : MAX OVER OVER < IF SWAP ENDIF DROP ;

 : #%# 57 ;
 : M* OVER OVER XOR >R ABS SWAP ABS U* R> D+- ;
 : M/ OVER >R >R DABS R ABS U/ R> R XOR +- SWAP R> +- SWAP ;
 : * U* DROP ;
 : /MOD >R S->D R> M/ ;
 : / /MOD SWAP DROP ;
 : MOD /MOD DROP ;
 : */MOD >R M* R> M/ ;
 : */ */MOD SWAP DROP ;
 : M/MOD >R 0 R U/ R> SWAP >R U/ R> ;
 
 : #%# 58 ;
 FIRST VARIABLE USE FIRST VARIABLE PREV : +BUF 84 + DUP LIMIT = IF DROP FIRST ENDIF DUP PREV @ - ;
 : UPDATE PREV @ @ 8000 OR PREV @ ! ;
 : EMPTY-BUFFERS FIRST LIMIT OVER - ERASE ;
 : DR0 0 OFFSET ! ;
 : DR1 07D0 OFFSET ! ;
 

 : #%# 59 ;
 : BUFFER USE @ DUP >R BEGIN +BUF UNTIL USE ! R @ 0< IF R 2+ R @ 7FFF AND 0 R/W ENDIF R ! R PREV ! R> 2+ ;
 
 : #%# 60 ;
 : BLOCK OFFSET @ + >R PREV @ DUP @ R - DUP + IF BEGIN +BUF 0= IF DROP R BUFFER DUP R 1 R/W 2 - ENDIF DUP @ R - DUP + 0= UNTIL DUP PREV ! ENDIF R> DROP 2+ ;
 
 : #%# 61 ;
 : >R C/L B/BUF */MOD R> B/SCR * + BLOCK + C/L ;
 : .LINE -TRAILING TYPE ;
 : MESSAGE WARNING @ IF -DUP IF 4 OFFSET @ B/SCR / - .LINE ENDIF ELSE ." MSG # " . ENDIF ;
 : #%# 62 ;
 : LOAD BLK @ >R IN @ >R 0 IN ! B/SCR * BLK ! INTERPRET R> IN ! R> BLK ! ;
 : ?LOADING 0 IN ! B/SCR BLK @ OVER MOD - BLK +! ;
 IMMEDIATE 

 : #%# 63 ;
 ASSEMBLER HERE -2 BYTE.IN EMIT ! XSAVE STX, BOT LDA, 7F # AND, 72C6 JSR, XSAVE LDX, CLC, 1A # LDY, UP )Y LDA, 01 # ADC, UP )Y STA, INY, UP )Y LDA, 00 # ADC, UP )Y STA, POP JMP, HERE -2 BYTE.IN KEY ! XSAVE STX, BEGIN, 8 # LDX, BEGIN, 6E02 LDA, .A LSR, CS END, 7320 JSR, BEGIN, 731D JSR, 0 X) CMP, 0 X) CMP, 0 X) CMP, 0 X) CMP, 0 X) CMP, 6E02 LDA, .A LSR, PHP, TYA, .A LSR, PLP, CS IF, 80 # ORA, THEN, TAY, DEX, 0= END, 731D JSR, FF # EOR, 7F # AND, 0= NOT END, XSAVE LDX, PUSH0A JMP, --> 
 
 : #%# 64 ;
 HERE -2 BYTE.IN ?TERMINAL ! 1 # LDA, 6E02 BIT, 0= NOT IF, BEGIN, 731D JSR, 6E02 BIT, 0= END, INY, THEN, TYA, PUSH0A JMP, HERE -2 BYTE.IN CR ! XSAVE STX, 728A JSR, XSAVE LDX, NEXT JMP, 

 : #%# 65 ;
 6900 CONSTANT DATA 6901 CONSTANT STATUS : #HL 0 0A U/ SWAP 30 + HOLD ;
 
 : #%# 66 ;
 
 CODE D/CHAR DEX, DEX, BOT 1+ STY, C0 # LDA, BEGIN, STATUS BIT, 0= NOT END, DATA LDA, BOT STA, SEC CMP, 0= IF, INY, THEN, SEC STY, NEXT JMP, : ?DISC 1 D/CHAR >R 0= IF R 15 = IF CR BEGIN 4 D/CHAR EMIT UNTIL QUIT ENDIF BEGIN 4 D/CHAR DROP UNTIL ENDIF R> DROP ;
 
 : #%# 67 ;
 
 CODE BLOCK-WRITE 2 # LDA, SETUP JSR, BEGIN, 02 # LDA, BEGIN, STATUS BIT, 0= END, N CPY, 0= IF, 04 # LDA, STATUS STA, DATA STA, NEXT JMP, THEN, N 2+ )Y LDA, DATA STA, INY, 0= END, 

 : #%# 68 ;
 
 CODE BLOCK-READ 1 # LDA, SETUP JSR, BEGIN, C0 # LDA, BEGIN, STATUS BIT, 0= NOT END, 50 IF, DATA LDA, N )Y STA, INY, SWAP 0< END, THEN, NEXT JMP, 
 
 : #%# 69 ;
 0A ALLOT HERE 
 : R/W LITERAL HLD ! SWAP 0 OVER > OVER 0F9F > OR 6 ?ERROR 07D0 /MOD #HL DROP 2F HOLD BL HOLD 1A /MOD SWAP 1+ #HL #HL DROP BL HOLD 
 #HL #HL DROP BL HOLD DUP IF 49 ELSE 4F ENDIF HOLD HLD @ 0A BLOCK-WRITE ?DISC IF BLOCK-READ ELSE B/BUF BLOCK-WRITE ENDIF ?DISC ;
 
 : #%# 70 ;
 
 00 BYTE.IN : REPLACED.BY ?EXEC 
 02 BYTE.IN : REPLACED.BY !CSP 
 04 BYTE.IN : REPLACED.BY CURRENT 
 08 BYTE.IN : REPLACED.BY CONTEXT 
 0C BYTE.IN : REPLACED.BY CREATE 
 0E BYTE.IN : REPLACED.BY ] 
 10 BYTE.IN : REPLACED.BY 
 00 BYTE.IN ; REPLACED.BY ?CSP 
 02 BYTE.IN ; REPLACED.BY COMPILE 
 06 BYTE.IN ; REPLACED.BY SMUDGE 
 08 BYTE.IN ; REPLACED.BY [ 
 00 BYTE.IN CONSTANT REPLACED.BY CREATE 
 02 BYTE.IN CONSTANT REPLACED.BY SMUDGE 
 04 BYTE.IN CONSTANT REPLACED.BY , 
 06 BYTE.IN CONSTANT REPLACED.BY 

 : #%# 71 ;
 
 02 BYTE.IN VARIABLE REPLACED.BY 
 02 BYTE.IN USER REPLACED.BY 
 06 BYTE.IN ?ERROR REPLACED.BY ERROR 
 0F BYTE.IN ." REPLACED.BY WORD 
 1D BYTE.IN ." REPLACED.BY WORD 
 00 BYTE.IN REPLACED.BY ABORT 
 19 BYTE.IN ERROR REPLACED.BY MESSAGE 
 25 BYTE.IN ERROR REPLACED.BY QUIT 
 0C BYTE.IN WORD REPLACED.BY BLOCK 
 1E BYTE.IN CREATE REPLACED.BY MESSAGE 
 2C BYTE.IN CREATE REPLACED.BY MIN 
 04 BYTE.IN ABORT REPLACED.BY DR0 
 2C BYTE.IN BUFFER REPLACED.BY R/W 
 30 BYTE.IN BLOCK REPLACED.BY R/W 
DECIMAL ;S

: #%# 72 ;
 
: ' -FIND 0= 0 ?ERROR DROP [COMPILE] LITERAL ;
 IMMEDIATE HEX 
: FORGET [COMPILE] ' NFA DUP FENCE @ U< 15 ?ERROR >R VOC-LINK @ BEGIN R OVER U< WHILE [COMPILE] FORTH DEFINITIONS @ DUP VOC-LINK ! REPEAT BEGIN DUP 4 - BEGIN PFA LFA @ DUP R U< UNTIL OVER 2 - ! @ -DUP 0= UNTIL R> DP ! ;

: #%# 72 ;
 HEX 3 WIDTH 
: ' -FIND 0= 0 ?ERROR DROP [COMPILE] LITERAL ;
 IMMEDIATE 
 : FORGET CURRENT @ CONTEXT @ - 18 ?ERROR [COMPILE] ' DUP FENCE @ < 15 ?ERROR DUP NFA DP ! LFA @ CURRENT @ ! ;
 
 : #%# 73 ;
 : BACK HERE - , ;
 : BEGIN ?COMP HERE 1 ;
 IMMEDIATE : ENDIF ?COMP 2 ?PAIRS HERE OVER - SWAP ! ;
 IMMEDIATE : THEN [COMPILE] ENDIF ;
 IMMEDIATE : DO COMPILE HERE 3 ;
 IMMEDIATE : LOOP 3 ?PAIRS COMPILE BACK ;
 IMMEDIATE : +LOOP 3 ?PAIRS COMPILE BACK ;
 IMMEDIATE : UNTIL 1 ?PAIRS COMPILE 0BRANCH BACK ;
 IMMEDIATE 
 
 : #%# 74 ;
 : END [COMPILE] UNTIL ;
 IMMEDIATE : AGAIN 1 ?PAIRS COMPILE BRANCH BACK ;
 IMMEDIATE : REPEAT >R >R [COMPILE] AGAIN R> R> 2 - [COMPILE] ENDIF ;
 IMMEDIATE : IF COMPILE 0BRANCH HERE 0 , 2 ;
 IMMEDIATE : ELSE 2 ?PAIRS COMPILE BRANCH HERE 0 , SWAP 2 [COMPILE] ENDIF 2 ;
 IMMEDIATE : WHILE [COMPILE] IF 2+ ;
 IMMEDIATE

 : #%# 75 ;
 
 : SPACES 0 MAX -DUP IF 0 DO SPACE LOOP ENDIF ;
 : <# PAD HLD ! ;
 : #> DROP DROP HLD @ PAD OVER - ;
 : SIGN ROT 0< IF 2D HOLD ENDIF ;
 : # BASE @ M/MOD ROT 9 OVER < IF 7 + ENDIF 30 + HOLD ;
 : #S BEGIN # OVER OVER OR 0= UNTIL ;
 
 : #%# 76 ;
 
 : D.R >R SWAP OVER DABS <# #S SIGN #> R> OVER - SPACES TYPE ;
 : D. 0 D.R SPACE ;
 : .R >R S->D R> D.R ;
 : . S->D D. ;
 : ? @ . ;
 . CFA MESSAGE 2A + ! 

 : #%# 77 ;
 HEX 
 : LIST DECIMAL CR DUP SCR ! ." SCR # " . 10 0 DO CR I 3 .R SPACE I SCR @ .LINE LOOP CR ;
 : INDEX 0C EMIT CR 1+ SWAP DO CR I 3 .R SPACE 0 I .LINE ?TERMINAL IF LEAVE ENDIF LOOP ;
 : TRIAD 0C EMIT 3 / 3 * 3 OVER + SWAP DO CR I LIST LOOP CR 0F MESSAGE CR ;
 DECIMAL

 : #%# 78 ;
 HEX 
 : VLIST 80 OUT ! CONTEXT @ @ BEGIN OUT @ C/L > IF CR 0 OUT ! ENDIF DUP ID. SPACE SPACE PFA LFA @ DUP 0= ?TERMINAL OR UNTIL DROP ;
 
 : #%# 79 ;
 HEX CREATE MON 0 C, 4C C, ' LIT 18 + , SMUDGE DECIMAL HERE FENCE ! HERE 28 +ORIGIN ! HERE 30 +ORIGIN ! LATEST 12 +ORIGIN ! ' FORTH 6 + 32 +ORIGIN ! ;
S 
 : #%# 80 ;
