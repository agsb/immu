 : star-time variable ; 
 : do-star ." 10000 star-time +! ['] star systick-counter star-time @ over - delay-action-from-time ; 
 : dot-time variable ; 
 : do-dot ." 2500 dot-time +! ['] dot systick-counter dot-time @ over - delay-action-from-time ; 
 : exception [: [: ." cr ;] ?raise ;] 100000 delay-action ; 
 : init-test systick-counter star-time ! systick-counter dot-time ! my-schedule init-schedule 0 ['] star star-action init-action 0 ['] dot dot-action init-action 0 ['] exception exception-action init-action my-schedule star-action add-action my-schedule dot-action add-action my-schedule exception-action add-action 0 [: my-schedule run-schedule ;] 420 128 512 spawn run ; 
 : x-already-in-schedule ." cr ; 
 : x-not-in-schedule ." cr ; 
 : x-schedule-already-running ." cr ; 
 : x-operation-set ." cr ; 
 : current-schedule user ; 
 : current-action user ; 
 : schedule. cr ." schedule-running? @ . ; 
 : action. cr ." action-msg-size @ . ; 
 : no-operation constant ; 
 : no-delay constant ; 
 : no-msg constant ; 
 : find-msg current-schedule @ schedule-next @ dup >r r@ if egin 2dup action-msg-dest @ = if nip true else action-next @ dup r@ = if 2drop 0 true else false then then ntil else drop 0 then rdrop ; 
 : copy-msg-src over action-msg-size @ min >r action-msg-data @ r@ move r> ; 
 : copy-msg-dest 2 pick action-msg-size @ min >r swap action-msg-data @ swap action-msg-data @ r@ move r> ; 
 : clear-send-msg no-operation over action-systick-delay ! 0 over action-msg-dest ! dup action-send-xt @ over action-resume-xt ! 0 swap action-send-xt ! ; 
 : fail-send-msg no-operation over action-systick-delay ! 0 over action-msg-dest ! 0 swap action-send-xt ! ; 
 : clear-send-timeout no-operation over action-systick-delay ! 0 over action-msg-dest ! 0 over action-send-xt ! 0 swap action-resume-xt ! ; 
 : clear-recv-msg no-operation over action-systick-delay ! 0 over action-msg-src ! 0 swap action-resume-xt ! ; 
 : fail-all-send-msg dup action-schedule @ schedule-next @ dup >r r@ if egin 2dup action-msg-dest @ = if dup fail-send-msg then action-next @ dup r@ = ntil then rdrop 2drop ; 
 : advance-action [: up current-schedule @ schedule-next @ = if action-next @ current-schedule @ schedule-next ! hen ;] current-schedule @ schedule-slock with-slock ; 
 : only-in-schedule? dup action-next @ = ; 
 : no-action-delay no-delay current-action @ action-systick-delay ! ; 
 : validate-current-action current-action @ action-systick-delay @ no-operation = averts x-operation-set ; 
 : init-schedule dup schedule-slock init-slock false over schedule-running? ! 0 swap schedule-next ! ; 
 : init-action 0 over action-schedule ! tuck action-resume-xt ! no-operation over action-systick-start ! no-operation over action-systick-delay ! 0 over action-recv-xt ! 0 over action-send-xt ! tuck action-data ! 0 over action-msg-src ! 0 over action-msg-dest ! 0 over action-msg-data ! 0 swap action-msg-size ! ; 
 : add-action [: dup action-schedule @ 0= averts x-already-in-schedule tuck action-schedule ! dup action-schedule @ schedule-next @ if up action-schedule @ schedule-next @ over action-next ! up action-schedule @ schedule-next @ action-prev @ over action-prev ! up dup action-schedule @ schedule-next @ action-prev @ action-next ! up dup action-schedule @ schedule-next @ action-prev ! up action-schedule @ schedule-next ! else up dup action-schedule @ schedule-next ! up dup action-next ! up action-prev ! then ;] 2 pick schedule-slock with-slock ; 
 : remove-action dup action-schedule @ 0<> averts x-not-in-schedule [: dup fail-all-send-msg dup only-in-schedule? if up action-schedule @ 0 swap schedule-next ! else up action-schedule @ schedule-next @ over = if dup action-next @ over action-schedule @ schedule-next ! hen up action-next @ over action-prev @ action-next ! up action-prev @ over action-next @ action-prev ! then 0 over action-prev ! 0 over action-next ! 0 swap action-schedule ! ;] over action-schedule @ schedule-slock with-slock ; 
 : send-action-fail validate-current-action no-action-delay current-action @ >r r@ action-schedule @ current-schedule @ = if dup action-schedule @ current-schedule @ = if up action-msg-src @ no-msg = if dup >r swap copy-msg-src r@ action-msg-size ! r> r@ swap action-msg-src ! drop r> action-resume-xt ! lse r@ action-msg-dest ! r@ action-msg-size ! r@ action-msg-data ! r@ action-resume-xt ! r> action-send-xt ! hen else rop 2drop r> action-resume-xt ! drop then else drop 2drop 2drop rdrop then ; 
 : send-action >r >r >r dup r> r> r> send-action-fail ; 
 : send-action-timeout validate-current-action current-action @ >r r@ action-schedule @ current-schedule @ = if over action-schedule @ current-schedule @ = if ver action-msg-src @ no-msg = if drop dup >r swap copy-msg-src r@ action-msg-size ! r> r@ swap action-msg-src ! drop r> action-resume-xt ! no-action-delay lse dup 0>= if r@ action-systick-delay ! systick-counter r@ action-systick-start ! else 0 r@ action-systick-delay ! systick-counter + r@ action-systick-start ! then r@ action-msg-dest ! r@ action-msg-size ! r@ action-msg-data ! r@ action-resume-xt ! r> action-send-xt ! hen else drop 2drop r> action-resume-xt ! drop then else 2drop 2drop 2drop rdrop then ; 
 : recv-action validate-current-action no-action-delay current-action @ >r r@ action-schedule @ current-schedule @ = if r@ find-msg ?dup if up r@ action-msg-src ! ot r@ action-msg-data ! @ over >r rot copy-msg-dest r> clear-send-msg r@ action-msg-size ! else o-msg r@ action-msg-src ! @ action-msg-size ! @ action-msg-data ! then r> action-recv-xt ! else 2drop drop rdrop then ; 
 : recv-action-timeout validate-current-action current-action @ >r r@ action-schedule @ current-schedule @ = if r@ find-msg ?dup if ip up r@ action-msg-src ! ot r@ action-msg-data ! @ over >r rot copy-msg-dest r> clear-send-msg r@ action-msg-size ! rop > action-recv-xt ! o-action-delay else up 0>= if r@ action-systick-delay ! systick-counter r@ action-systick-start ! lse 0 r@ action-systick-delay ! systick-counter + r@ action-systick-start ! hen o-msg r@ action-msg-src ! @ action-msg-size ! @ action-msg-data ! @ action-resume-xt ! > action-recv-xt ! then else 2drop 2drop drop rdrop then ; 
 : delay-action validate-current-action current-action @ >r dup 0>= if r@ action-systick-delay ! systick-counter r@ action-systick-start ! else 0 r@ action-systick-delay ! systick-counter + r@ action-systick-start ! then r> action-resume-xt ! ; 
 : delay-action-from-time validate-current-action current-action @ >r dup 0>= if r@ action-systick-delay ! r@ action-systick-start ! else 0 r@ action-systick-delay ! + r@ action-systick-start ! then r> action-resume-xt ! ; 
 : yield-action validate-current-action no-action-delay current-action @ action-resume-xt ! ; 
 : execute-handle try-and-display-error if current-action @ remove-action then ; 
 : run-schedule dup schedule-running? @ triggers x-schedule-already-running current-schedule ! true current-schedule @ schedule-running? ! begin current-schedule @ schedule-running? @ while current-schedule @ schedule-next @ ?dup if up action-msg-src @ ?dup if no-msg = if dup action-systick-delay @ 0>= swap systick-counter over action-systick-start @ - over action-systick-delay @ >= rot and if dup current-action ! dup advance-action dup action-resume-xt @ swap clear-recv-msg execute-handle else advance-action then else >r r@ action-msg-data @ r@ action-msg-size @ r@ action-msg-src @ r@ advance-action r@ action-recv-xt @ r@ clear-recv-msg r> current-action ! execute-handle then lse dup action-send-xt @ 0= if dup action-resume-xt @ if dup action-systick-delay @ 0< swap systick-counter over action-systick-start @ - over action-systick-delay @ >= rot or if up current-action ! dup advance-action dup action-resume-xt @ wap no-operation over action-systick-delay ! swap action-resume-xt ! xecute-handle else dvance-action then else dup advance-action remove-action then else dup action-resume-xt @ if dup action-systick-delay @ 0>= swap systick-counter over action-systick-start @ - over action-systick-delay @ >= rot and if up current-action ! dup advance-action dup action-resume-xt @ wap clear-send-timeout xecute-handle else dvance-action then else advance-action then then hen else ause then repeat ; 
 : action-schedule@ action-schedule @ ; 
 : action-data@ action-data @ ; 
 : in-schedule? action-schedule @ 0<> ; 
 : stop-schedule false swap schedule-running? ! ; 
 : current-schedule current-schedule @ ; 
 : current-action current-action @ ; 
 : current-data current-action action-data @ ; 
 : my-count constant ; 
 : do-consumer [: 2drop drop consumer ;] current-data cells consumer-buf + cell recv-action ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : do-producer send-count @ producer-buf current-data cells + ! [: 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then producer ;] producer-buf current-data cells + cell consumer-action my-tinymt32 tinymt32-generate-uint32 my-count umod action-size * + send-action ; 
 : init-test my-tinymt32 tinymt32-prepare-example my-tinymt32 tinymt32-init 0 send-count ! systick-counter start-systick ! my-schedule init-schedule my-count 0 ?do i ['] consumer i action-size * consumer-action + init-action i ['] producer i action-size * producer-action + init-action loop my-count 0 ?do my-schedule i action-size * consumer-action + add-action my-schedule i action-size * producer-action + add-action loop 0 [: my-schedule run-schedule ;] 420 128 512 spawn run ; 
 : action@ action-pool-size + swap action-size * + ; 
 : x-no-action-available ." cr ; 
 : action-pool-free begin-critical 0 swap dup action-pool-count @ 0 ?do i over action@ action-disposed? if swap 1+ swap then loop drop end-critical ; 
 : init-action-pool tuck action-pool-count ! tuck action-pool-schedule ! dup action-pool-count @ 0 ?do i over action@ action-size $FF fill loop drop ; 
 : init-from-action-pool begin-critical dup action-pool-count @ 0 ?do i over action@ action-disposed? if over action@ dup >r swap action-pool-schedule @ nit-action r> end-critical unloop exit then loop end-critical ['] x-no-action-available ?raise ; 
 : action-pool-size action-size * action-pool-size + ; 
 : my-count constant ; 
 : do-stars [: ." stars ;] 10000 delay-action ; 
 : do-start-actions [: [: y-pool action-pool-free . y-schedule 0 ['] stars my-pool add-action-from-pool drop tart-actions ;] yield-action ;] 10000 delay-action ; 
 : init-test my-schedule init-schedule my-count my-pool init-action-pool my-schedule 0 ['] start-actions my-pool add-action-from-pool 0 [: my-schedule run-schedule ;] 420 128 512 spawn run ; 
 : do-consumer [: 2drop @ . ['] consumer yield-action ;] consumer-buf cell recv-action ; 
 : producer-time variable ; 
 : do-producer [: ." 1 producer-buf +! 2500 producer-time +! ['] producer systick-counter producer-time @ over - delay-action-from-time ;] producer-buf cell consumer-action send-action ; 
 : init-test 0 producer-buf ! systick-counter producer-time ! my-schedule init-schedule 0 ['] consumer consumer-action init-action 0 ['] producer producer-action init-action my-schedule consumer-action add-action my-schedule producer-action add-action 0 [: my-schedule run-schedule ;] 420 128 512 spawn run ; 
 : do-consumer [: 2drop @ . ['] consumer yield-action ;] [: ." ;] consumer-buf cell 10000 recv-action-timeout ; 
 : producer-time variable ; 
 : do-producer producer-buf @ 10 < if [: " * " producer-buf +! 500 producer-time +! '] producer systick-counter producer-time @ over - elay-action-from-time ;] producer-buf cell consumer-action send-action then ; 
 : init-test 0 producer-buf ! systick-counter producer-time ! my-schedule init-schedule 0 ['] consumer consumer-action init-action 0 ['] producer producer-action init-action my-schedule consumer-action add-action my-schedule producer-action add-action 0 [: my-schedule run-schedule ;] 420 128 512 spawn run ; 
 : do-consumer [: 2drop @ dup . 9 < if ['] consumer yield-action then ;] consumer-buf cell recv-action ; 
 : producer-time variable ; 
 : do-producer [: ." ;] producer-buf cell consumer-action 10000 send-action-timeout ; 
 : init-test 0 producer-buf ! systick-counter producer-time ! my-schedule init-schedule 0 ['] consumer consumer-action init-action 0 ['] producer producer-action init-action my-schedule consumer-action add-action my-schedule producer-action add-action 0 [: my-schedule run-schedule ;] 420 128 512 spawn run ; 
 : do-lockup ['] lockup yield-action ; 
 : do-consumer [: 2drop @ dup . 9 < if ['] consumer else ['] lockup then yield-action ;] consumer-buf cell recv-action ; 
 : producer-time variable ; 
 : do-producer [: ." ;] producer-buf cell consumer-action 10000 send-action-timeout ; 
 : init-test 0 producer-buf ! systick-counter producer-time ! my-schedule init-schedule 0 ['] consumer consumer-action init-action 0 ['] producer producer-action init-action my-schedule consumer-action add-action my-schedule producer-action add-action 0 [: my-schedule run-schedule ;] 420 128 512 spawn run ; 
 : do-consumer [: 2drop drop consumer ;] consumer-buf cell recv-action ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : do-producer [: 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then producer ;] send-count cell consumer-action send-action ; 
 : init-test 0 send-count ! systick-counter start-systick ! my-schedule init-schedule 0 ['] consumer consumer-action init-action 0 ['] producer producer-action init-action my-schedule consumer-action add-action my-schedule producer-action add-action 0 [: my-schedule run-schedule ;] 420 128 512 spawn run ; 
 : star-time variable ; 
 : do-star ." 10000 star-time +! ['] star systick-counter star-time @ over - delay-action-from-time ; 
 : dot-time variable ; 
 : do-dot ." 2500 dot-time +! ['] dot systick-counter dot-time @ over - delay-action-from-time ; 
 : init-test systick-counter star-time ! systick-counter dot-time ! my-schedule init-schedule 0 ['] star star-action init-action 0 ['] dot dot-action init-action my-schedule star-action add-action my-schedule dot-action add-action 0 [: my-schedule run-schedule ;] 420 128 512 spawn run ; 
 : x-invalid-adc ." cr ; 
 : x-invalid-adc-chan ." cr ; 
 : x-pin-has-no-adc-chan ." cr ; 
 : validate-adc 0= averts x-invalid-adc ; 
 : validate-adc-chan 5 u< averts x-invalid-adc-chan ; 
 : ADC_BASE constant ; 
 : ADC_CS_AINSEL! ADC_CS @ [ $7 12 lshift ] literal bic swap 12 lshift or ADC_CS ! ; 
 : ADC_CS_ERR_STICKY! 10 bit ADC_CS bis! ; 
 : ADC_CS_ERR_STICKY@ 10 bit ADC_CS bit@ ; 
 : ADC_CS_ERR@ 9 bit ADC_CS bit@ ; 
 : ADC_CS_READY@ 8 bit ADC_CS bit@ ; 
 : ADC_CS_START_ONCE! 2 bit ADC_CS rot if bis! else bic! then ; 
 : ADC_CS_TS_EN! 1 bit ADC_CS rot if bis! else bic! then ; 
 : ADC_CS_EN! 0 bit ADC_CS rot if bis! else bic! then ; 
 : init-adc adc-lock init-lock true ADC_CS_EN! true ADC_CS_TS_EN! ; 
 : enable-adc validate-adc [: true ADC_CS_EN! true ADC_CS_TS_EN! ;] adc-lock with-lock ; 
 : disable-adc validate-adc [: false ADC_CS_TS_EN! false ADC_CS_EN! ;] adc-lock with-lock ; 
 : adc-pin dup pin-internal::validate-pin dup 26 >= over 29 <= and averts x-pin-has-no-adc-chan validate-adc ; 
 : pin-adc-chan dup pin-internal::validate-pin dup 26 >= over 29 <= and averts x-pin-has-no-adc-chan 26 - ; 
 : default-adc constant ; 
 : temp-adc-chan constant ; 
 : adc-min constant ; 
 : adc-max constant ; 
 : adc@ validate-adc dup validate-adc-chan [: begin ADC_CS_READY@ until ADC_CS_AINSEL! true ADC_CS_START_ONCE! begin ADC_CS_READY@ until ADC_RESULT @ ;] adc-lock with-lock ; 
 : x-default-alarm-task-already-inited ." cr ; 
 : default-alarm-task-inited? variable ; 
 : max-alarm-priority [: 0 { alarm-task max-priority } alarm-task alarm-task-first @ begin ?dup while dup alarm-priority @ max-priority max to max-priority alarm-next @ repeat max-priority ;] over alarm-task-slock with-slock ; 
 : alarm< { alarm1 alarm0 -- lt? } systick-counter { current-systick } current-systick alarm1 alarm-ticks-start @ - { adjusted-start1 } current-systick alarm0 alarm-ticks-start @ - { adjusted-start0 } alarm1 alarm-ticks-delay @ adjusted-start1 - { adjusted-delay1 } alarm0 alarm-ticks-delay @ adjusted-start0 - { adjusted-delay0 } adjusted-delay1 adjusted-delay0 < ; 
 : add-alarm [: { alarm alarm-task } alarm-task alarm-task-first @ begin ?dup while dup alarm-prev @ { prev } alarm over alarm< if prev if prev alarm alarm-prev ! alarm prev alarm-next ! else alarm alarm-task alarm-task-first ! 0 alarm alarm-prev ! then alarm alarm-next ! alarm-task alarm alarm-parent ! exit else alarm-next @ then repeat alarm-task alarm-task-last @ { last } last if last alarm alarm-prev ! alarm last alarm-next ! else alarm alarm-task alarm-task-first ! 0 alarm alarm-prev ! then 0 alarm alarm-next ! alarm alarm-task alarm-task-last ! alarm-task alarm alarm-parent ! ;] over alarm-task-slock with-slock ; 
 : remove-alarm { alarm -- } alarm alarm-parent @ if alarm [: { alarm } alarm alarm-prev @ if alarm alarm-next @ alarm alarm-prev @ alarm-next ! else alarm alarm-next @ alarm alarm-parent @ alarm-task-first ! then alarm alarm-next @ if alarm alarm-prev @ alarm alarm-next @ alarm-prev ! else alarm alarm-prev @ alarm alarm-parent @ alarm-task-last ! then ;] alarm alarm-parent @ alarm-task-slock with-slock then 0 alarm alarm-parent ! ; 
 : run-alarm-task { alarm-task -- } begin alarm-task [: alarm-task-first @ dup if dup alarm-ticks-delay @ over alarm-ticks-start @ true then ;] alarm-task alarm-task-slock with-slock if dup systick-counter swap - 2 pick < if rot drop [: 2dup 0 wait-notify-timeout drop ;] try -rot 2drop dup ['] x-timed-out <> if ?raise else drop then else 2drop dup alarm-data @ swap dup alarm-xt @ over remove-alarm execute alarm-task max-alarm-priority current-task task-priority! then else 0 wait-notify-indefinite drop then again ; 
 : init-alarms default-alarm-task-slock init-slock false default-alarm-task-inited? ! ; 
 : default-dict-size constant ; 
 : default-stack-size constant ; 
 : default-rstack-size constant ; 
 : default-core constant ; 
 : init-alarm-task { dict-size stack-size rstack-size core addr -- } addr alarm-task-slock init-slock 0 addr alarm-task-first ! 0 addr alarm-task-last ! addr 1 ['] run-alarm-task dict-size stack-size rstack-size core spawn-on-core addr alarm-task-task ! addr alarm-task-notify-data 1 addr alarm-task-task @ config-notify c" addr alarm-task-task @ task-name! addr alarm-task-task @ run ; 
 : init-default-alarm-task-impl { dict-size stack-size rstack-size core -- } true default-alarm-task-inited? ! dict-size stack-size rstack-size core default-alarm-task init-alarm-task ; 
 : init-default-alarm-task [: { dict-size stack-size rstack-size core } default-alarm-task-inited? @ triggers x-default-alarm-task-already-inited dict-size stack-size rstack-size core init-default-alarm-task-impl ;] default-alarm-task-slock with-slock ; 
 : default-alarm-task@ [: default-alarm-task-inited? @ not if default-dict-size default-stack-size default-rstack-size default-core init-default-alarm-task-impl then default-alarm-task ;] default-alarm-task-slock with-slock ; 
 : set-alarm { ticks-delay ticks-start priority data xt alarm alarm-task -- } xt alarm alarm-xt ! data alarm alarm-data ! priority alarm alarm-priority ! ticks-start alarm alarm-ticks-start ! ticks-delay alarm alarm-ticks-delay ! alarm alarm-task add-alarm current-task task-priority@ { saved-priority } alarm-task max-alarm-priority { target-priority } target-priority saved-priority max current-task task-priority! target-priority alarm-task alarm-task-task @ task-priority! 0 alarm-task alarm-task-task @ notify saved-priority current-task task-priority! ; 
 : set-alarm-default default-alarm-task@ set-alarm ; 
 : set-alarm-delay { ticks-delay priority data xt alarm alarm-task -- } ticks-delay systick-counter priority data xt alarm alarm-task set-alarm ; 
 : set-alarm-delay-default { ticks-delay priority data xt alarm -- } ticks-delay systick-counter priority data xt alarm set-alarm-default ; 
 : unset-alarm { alarm -- } alarm alarm-parent @ { alarm-task } alarm-task if alarm remove-alarm alarm-task max-alarm-priority alarm-task alarm-task-task @ task-priority! then ; 
 : saved-key user ; 
 : show-cursor-count user ; 
 : preserve-cursor-count user ; 
 : escape constant ; 
 : (dec.) base @ 10 base ! swap (.) base ! ; 
 : csi [: $1B emit [char] [ emit ;] critical ; 
 : show-cursor [: csi [char] ? emit 25 (dec.) [char] h emit ;] critical ; 
 : hide-cursor [: csi [char] ? emit 25 (dec.) [char] l emit ;] critical ; 
 : save-cursor [: csi [char] s emit ;] critical ; 
 : restore-cursor [: csi [char] u emit ;] critical ; 
 : scroll-up [: csi (dec.) [char] S emit ;] critical ; 
 : go-to-coord [: swap csi 1+ (dec.) [char] ; emit 1+ (dec.) [char] f emit ;] critical ; 
 : erase-end-of-line [: csi [char] K emit ;] critical ; 
 : erase-down [: csi [char] J emit ;] critical ; 
 : query-cursor-position [: csi [char] 6 emit [char] n emit ;] critical ; 
 : show-cursor 1 show-cursor-count +! show-cursor-count @ 0 = if show-cursor then ; 
 : hide-cursor -1 show-cursor-count +! show-cursor-count @ -1 = if hide-cursor then ; 
 : execute-hide-cursor hide-cursor try show-cursor ?raise ; 
 : clear-key 0 saved-key ! ; 
 : get-key saved-key @ ?dup if 0 saved-key ! else key then ; 
 : get-key? saved-key @ if true else key? then ; 
 : set-key saved-key ! ; 
 : wait-number ram-here >r get-key dup [char] - = if ram-here c! 1 ram-allot else set-key then 0 begin dup 10 < if et-key dup [char] 0 >= over [char] 9 <= and if ram-here c! 1 ram-allot 1+ false lse set-key true hen else rue then until drop base @ 10 base ! r@ ram-here r@ - parse-unsigned rot base ! r> ram-here! ; 
 : wait-char begin dup get-key = until drop ; 
 : expect-char get-key dup rot = if drop true else set-key false then ; 
 : get-cursor-position [: begin lear-key query-cursor-position escape wait-char char] [ expect-char if wait-number if 1 - [char] ; expect-char if wait-number if char] R expect-char if 1 - true lse 2drop false hen else rop false then else drop false then else drop false then lse false hen until ;] execute-hide-cursor ; 
 : execute-preserve-cursor 1 preserve-cursor-count +! preserve-cursor-count @ 1 = if save-cursor try restore-cursor else get-cursor-position >r >r try r> r> go-to-coord then -1 preserve-cursor-count +! ?raise ; 
 : get-terminal-size [: get-cursor-position 1000 1000 go-to-coord get-cursor-position swap 1+ swap 1+ 2swap go-to-coord ;] execute-hide-cursor ; 
 : reset-ansi-term 0 show-cursor-count ! 0 saved-key ! ; 
 : clear-ticks constant ; 
 : clear-keys systick-counter clear-ticks + begin get-key? if et-key dup escape = if set-key true lse drop dup systick-counter < hen then until drop ; 
 : x-out-of-range-3reg ." cr ; 
 : x-out-of-range-4reg ." cr ; 
 : x-out-of-range-imm ." cr ; 
 : x-unaligned-imm ." cr ; 
 : x-out-of-range-pc-rel ." cr ; 
 : x-incorrect-mark-type ." cr ; 
 : x-invalid-cond ." cr ; 
 : x-out-of-range-special ." ; 
 : mark-type $FFFF and ; 
 : mark-param 16 rshift ; 
 : mark-dest constant ; 
 : mark-adr constant ; 
 : mark-ldr constant ; 
 : mark-bc constant ; 
 : mark-b constant ; 
 : validate-3reg 8 u< averts x-out-of-range-3reg ; 
 : validate-4reg 16 u< averts x-out-of-range-4reg ; 
 : validate-2-3reg validate-3reg validate-3reg ; 
 : validate-2-4reg validate-4reg validate-4reg ; 
 : validate-3-3reg validate-3reg validate-3reg validate-3reg ; 
 : validate-imm-2align $1 and 0= averts x-unaligned-imm ; 
 : validate-imm-4align $3 and 0= averts x-unaligned-imm ; 
 : validate-cond $F u< averts x-invalid-cond ; 
 : validate-mark swap mark-type = averts x-incorrect-mark-type ; 
 : validate-special 256 u< averts x-out-of-range-special ; 
 : resolve-adr 4 align, over 2 + 4 align here swap - dup 1024 u< averts x-out-of-range-pc-rel 2 rshift swap mark-param 8 lshift or $A000 or swap hcurrent! ; 
 : resolve-ldr 4 align, over 2 + 4 align here swap - dup 1024 u< averts x-out-of-range-pc-rel 2 rshift swap mark-param 8 lshift or $4800 or swap hcurrent! ; 
 : resolve-b drop here over - 1 arshift dup 1024 < over -1025 > and averts x-out-of-range-pc-rel $7FF and $E000 or swap 4 - hcurrent! ; 
 : resolve-bc mark-param dup validate-cond >r here over - 1 arshift dup 128 < over -129 > and averts x-out-of-range-pc-rel $FF and r> 8 lshift or $D000 or swap 4 - hcurrent! ; 
 : instr-16-const <builds , does> @ h, ; 
 : instr-32-const <builds 16 lshift or , does> @ dup $FFFF and h, 16 rshift h, ; 
 : instr-2*3r <builds , does> @ >r 2dup validate-2-3reg swap 3 lshift or r> or h, ; 
 : instr-3*3r <builds , does> @ >r 3dup validate-3-3reg swap 3 lshift or swap 6 lshift or r> or h, ; 
 : instr-2*3r-3imm <builds , does> @ >r 2dup validate-2-3reg 2 pick 8 u< averts x-out-of-range-imm swap 3 lshift or swap 6 lshift or r> or h, ; 
 : instr-3r-8imm <builds , does> @ >r dup validate-3reg over 256 u< averts x-out-of-range-imm 8 lshift or r> or h, ; 
 : instr-3r-load/store-4byte-imm <builds , does> @ >r 2dup validate-2-3reg 2 pick validate-imm-4align swap 3 lshift or swap 2 rshift dup 32 u< averts x-out-of-range-imm 6 lshift or r> or h, ; 
 : instr-3r-load/store-sp-4byte-imm <builds , does> @ >r dup validate-3reg over validate-imm-4align 8 lshift swap 2 rshift dup 256 u< averts x-out-of-range-imm or r> or h, ; 
 : instr-3r-load/store-rel <builds , does> @ >r 3dup validate-3-3reg swap 3 lshift or swap 6 lshift or r> or h, ; 
 : instr-3r-load/store-1byte-imm <builds , does> @ >r 2dup validate-2-3reg swap 3 lshift or swap dup 32 u< averts x-out-of-range-imm 6 lshift or r> or h, ; 
 : instr-3r-load/store-2byte-imm <builds , does> @ >r 2dup validate-2-3reg 2 pick validate-imm-2align swap 3 lshift or swap 1 rshift dup 32 u< averts x-out-of-range-imm 6 lshift or r> or h, ; 
 : instr-3r-load/store-multi <builds , does> @ >r dup validate-3reg >r 0 begin over while rot dup validate-3reg bit or swap 1- swap repeat nip r> 8 lshift or r> or h, ; 
 : instr-8imm <builds , does> @ >r dup 256 u< averts x-out-of-range-imm r> or h, ; 
 : instr-4r <builds , does> @ >r dup validate-4reg 3 lshift r> or h, ; 
 : instr-2*4r <builds , does> @ >r 2dup validate-2-4reg dup $7 and swap $8 and 4 lshift or swap 3 lshift or r> or h, ; 
 : r0 constant ; 
 : r1 constant ; 
 : r2 constant ; 
 : r3 constant ; 
 : r4 constant ; 
 : r5 constant ; 
 : r6 constant ; 
 : r7 constant ; 
 : r8 constant ; 
 : r9 constant ; 
 : r10 constant ; 
 : r11 constant ; 
 : r12 constant ; 
 : r13 constant ; 
 : r14 constant ; 
 : r15 constant ; 
 : tos constant ; 
 : dp constant ; 
 : sp constant ; 
 : lr constant ; 
 : pc constant ; 
 : eq constant ; 
 : ne constant ; 
 : cs constant ; 
 : hs constant ; 
 : cc constant ; 
 : lo constant ; 
 : mi constant ; 
 : pl constant ; 
 : vs constant ; 
 : vc constant ; 
 : hi constant ; 
 : ls constant ; 
 : ge constant ; 
 : lt constant ; 
 : gt constant ; 
 : le constant ; 
 : al constant ; 
 : add_,sp,#_ dup validate-3reg over validate-imm-4align over 1024 u< averts x-out-of-range-imm 8 lshift swap 2 rshift or $A800 or h, ; 
 : addsp,sp,#_ dup validate-imm-4align dup 512 u< averts x-out-of-range-imm 2 rshift $B000 or h, ; 
 : add4_,sp dup validate-4reg dup $7 and swap $8 and 4 lshift or $4468 or h, ; 
 : addsp,sp,4_ dup validate-4reg 3 lshift $4485 or h, ; 
 : adr_ dup validate-3reg hreserve swap 16 lshift mark-adr or ; 
 : asrs_,_,#_ 2dup validate-2-3reg 2 pick 1 u>= averts x-out-of-range-imm 2 pick 33 u< averts x-out-of-range-imm swap 3 lshift or swap dup 32 = if drop 0 then 6 lshift or $1000 or h, ; 
 : b< mark-dest validate-mark here 4 + - 1 arshift dup 1024 < over -1025 > and averts x-out-of-range-pc-rel $7FF and $E000 or h, ; 
 : bc< dup validate-cond swap mark-dest validate-mark swap here 4 + - 1 arshift dup 128 < over -129 > and averts x-out-of-range-pc-rel $FF and swap 8 lshift or $D000 or h, ; 
 : b> hreserve 4 + mark-b ; 
 : bc> dup validate-cond hreserve 4 + swap 16 lshift mark-bc or ; 
 : ldr_,[pc] dup validate-3reg hreserve swap 16 lshift mark-ldr or ; 
 : lsls_,_,#_ 2dup validate-2-3reg swap 3 lshift or swap 6 lshift or $0000 or h, ; 
 : lsrs_,_,#_ 2dup validate-2-3reg 2 pick 1 u>= averts x-out-of-range-imm 2 pick 33 u< averts x-out-of-range-imm swap 3 lshift or swap dup 32 = if drop 0 then 6 lshift or $0800 or h, ; 
 : mrs_,_ dup validate-4reg over validate-special $F3EF h, 8 lshift or $8000 or h, ; 
 : msr_,_ dup validate-special over validate-4reg swap $F380 or h, $8800 or h, ; 
 : pop 0 begin over while ot dup pc = if drop 8 bit or lse dup validate-3reg bit or hen wap 1- swap repeat nip $BC00 or h, ; 
 : push 0 begin over while ot dup lr = if drop 8 bit or lse dup validate-3reg bit or hen wap 1- swap repeat nip $B400 or h, ; 
 : subsp,sp,#_ dup validate-imm-4align dup 512 u< averts x-out-of-range-imm 2 rshift $B080 or h, ; 
 : udf.w#_ dup 65536 u< averts x-out-of-range-imm dup 12 rshift $F and $F7F0 or h, $FFF and $A000 or h, ; 
 : mark> here mark-dest ; 
 : >mark dup mark-type case ark-adr of resolve-adr endof ark-ldr of resolve-ldr endof ark-b of resolve-b endof ark-bc of resolve-bc endof '] x-incorrect-mark-type ?raise endcase ; 
 : code[ [compile-only] [immediate] undefer-lit armv6m-instr import postpone [ ; 
 : ]code armv6m-instr unimport ] ; 
 : verify cr type ." then ; 
 : test-adds-tos-tos-#1 1 code[ 1 tos tos adds_,_,#_ ]code 2 = s" verify ; 
 : test-adds-tos-#1 2 code[ 1 tos adds_,#_ ]code 3 = s" verify ; 
 : test-adds-tos-r0-r1 0 code[ 1 r0 movs_,#_ 2 r1 movs_,#_ r1 r0 tos adds_,_,_ ]code 3 = s" verify ; 
 : test-adds-tos-r12 1 code[ r12 r1 mov4_,4_ 2 r0 movs_,#_ r0 r12 mov4_,4_ r12 tos add4_,4_ r1 r12 mov4_,4_ ]code 3 = s" verify ; 
 : test-adcs-tos-r0 0 code[ 0 r0 movs_,#_ 0 r1 movs_,#_ r1 r1 mvns_,_ 1 r1 r1 adds_,_,#_ r0 tos adcs_,_ ]code 1 = s" verify ; 
 : test-subs-tos-tos-#1 3 code[ 1 tos tos subs_,_,#_ ]code 2 = s" verify ; 
 : test-subs-tos-#1 3 code[ 1 tos subs_,#_ ]code 2 = s" verify ; 
 : test-subs-tos-r0-r1 0 code[ 3 r0 movs_,#_ 1 r1 movs_,#_ r1 r0 tos subs_,_,_ ]code 2 = s" verify ; 
 : test-sbcs-tos-r0 0 code[ 0 r0 movs_,#_ 0 r1 movs_,#_ 1 r1 r1 subs_,_,#_ r0 tos sbcs_,_ ]code -1 = s" verify ; 
 : test-ands-tos-r0 $FC0 code[ $FF r0 movs_,#_ r0 tos ands_,_ ]code $C0 = s" verify ; 
 : test-orrs-tos-r0 $F0 code[ $0F r0 movs_,#_ r0 tos orrs_,_ ]code $FF = s" verify ; 
 : test-eors-tos-r0 $F0 code[ $3F r0 movs_,#_ r0 tos eors_,_ ]code $CF = s" verify ; 
 : test-bics-tos-r0 $FF code[ $0F r0 movs_,#_ r0 tos bics_,_ ]code $F0 = s" verify ; 
 : test-lsls-tos-r0 1 code[ 1 r0 movs_,#_ r0 tos lsls_,_ ]code 2 = s" verify ; 
 : test-lsrs-tos-r0 $80000000 code[ 1 r0 movs_,#_ r0 tos lsrs_,_ ]code $40000000 = s" verify ; 
 : test-asrs-tos-r0 $80000000 code[ 1 r0 movs_,#_ r0 tos asrs_,_ ]code $C0000000 = s" verify ; 
 : test-rors-tos-r0 $80000001 code[ 1 r0 movs_,#_ r0 tos rors_,_ ]code $C0000000 = s" verify ; 
 : test-lsls-tos-tos-#1 1 code[ 1 tos tos lsls_,_,#_ ]code 2 = s" verify ; 
 : test-lsrs-tos-tos-#1 $80000000 code[ 1 tos tos lsrs_,_,#_ ]code $40000000 = s" verify ; 
 : test-asrs-tos-tos-#1 $80000000 code[ 1 tos tos asrs_,_,#_ ]code $C0000000 = s" verify ; 
 : test-muls-tos-r0 2 code[ 3 r0 movs_,#_ r0 tos muls_,_ ]code 6 = s" verify ; 
 : test-mvns-tos-r0 2 code[ 0 r0 movs_,#_ r0 tos mvns_,_ ]code -1 = s" verify ; 
 : test-rev-tos-tos $04030201 code[ tos tos rev_,_ ]code $01020304 = s" verify ; 
 : test-rev16-tos-tos $04030201 code[ tos tos rev16_,_ ]code $03040102 = s" verify ; 
 : test-revsh-tos-tos $0000FFFE code[ tos tos revsh_,_ ]code $FFFFFEFF = s" verify ; 
 : test-rsbs-tos-r0-#0 0 code[ 1 r0 movs_,#_ r0 tos rsbs_,_,#0 ]code -1 = s" verify ; 
 : test-sxtb-tos-tos $0000FCF0 code[ tos tos sxtb_,_ ]code $FFFFFFF0 = s" verify ; 
 : test-sxth-tos-tos $00FCF8F0 code[ tos tos sxth_,_ ]code $FFFFF8F0 = s" verify ; 
 : test-uxtb-tos-tos $0000FCF0 code[ tos tos uxtb_,_ ]code $000000F0 = s" verify ; 
 : test-uxth-tos-tos $00FCF8F0 code[ tos tos uxth_,_ ]code $0000F8F0 = s" verify ; 
 : test-nop 1 code[ nop ]code 1 = s" verify ; 
 : test-mov-tos-r12 0 code[ 1 r0 movs_,#_ r0 r12 mov4_,4_ r12 tos mov4_,4_ ]code 1 = s" verify ; 
 : test-str-ldr-imm test-buffer code[ 1 r0 movs_,#_ 4 tos r0 str_,[_,#_] 2 r0 movs_,#_ 4 tos r0 str_,[_,#_] 4 tos tos ldr_,[_,#_] ]code 2 = s" verify ; 
 : test-strb-ldrb-imm test-buffer code[ 1 r0 movs_,#_ 4 tos r0 strb_,[_,#_] 2 r0 movs_,#_ 4 tos r0 strb_,[_,#_] 4 tos tos ldrb_,[_,#_] ]code 2 = s" verify ; 
 : test-strh-ldrh-imm test-buffer code[ 1 r0 movs_,#_ 4 tos r0 strh_,[_,#_] 2 r0 movs_,#_ 4 tos r0 strh_,[_,#_] 4 tos tos ldrh_,[_,#_] ]code 2 = s" verify ; 
 : test-str-ldr-reg test-buffer code[ 1 r0 movs_,#_ 4 r1 movs_,#_ r1 tos r0 str_,[_,_] 2 r0 movs_,#_ r1 tos r0 str_,[_,_] r1 tos tos ldr_,[_,_] ]code 2 = s" verify ; 
 : test-strb-ldrb-reg test-buffer code[ 1 r0 movs_,#_ 4 r1 movs_,#_ r1 tos r0 strb_,[_,_] 2 r0 movs_,#_ r1 tos r0 strb_,[_,_] r1 tos tos ldrb_,[_,_] ]code 2 = s" verify ; 
 : test-strh-ldrh-reg test-buffer code[ 1 r0 movs_,#_ 4 r1 movs_,#_ r1 tos r0 strh_,[_,_] 2 r0 movs_,#_ r1 tos r0 strh_,[_,_] r1 tos tos ldrh_,[_,_] ]code 2 = s" verify ; 
 : test-strb-ldrsb-reg test-buffer code[ 1 r0 movs_,#_ 4 r1 movs_,#_ r1 tos r0 strb_,[_,_] $F0 r0 movs_,#_ r1 tos r0 strb_,[_,_] r1 tos tos ldrsb_,[_,_] ]code $FFFFFFF0 = s" verify ; 
 : test-strh-ldrsh-reg test-buffer code[ 1 r0 movs_,#_ 4 r1 movs_,#_ r1 tos r0 strh_,[_,_] $F0 r0 movs_,#_ $F1 r2 movs_,#_ 8 r2 r2 lsls_,_,#_ r2 r0 orrs_,_ r1 tos r0 strh_,[_,_] r1 tos tos ldrsh_,[_,_] ]code $FFFFF1F0 = s" verify ; 
 : test-simple-cmp-loop 16 code[ 0 r0 movs_,#_ mark> 2 r0 adds_,#_ 1 tos subs_,#_ 0 tos cmp_,#_ ne bc< r0 tos movs_,_ ]code 32 = s" verify ; 
 : test-reg-cmp-loop 16 code[ 0 r0 movs_,#_ mark> 2 r0 adds_,#_ 1 tos subs_,#_ 0 r1 movs_,#_ r1 tos cmp_,_ ne bc< r0 tos movs_,_ ]code 32 = s" verify ; 
 : test-reg4-cmp-loop 16 code[ 0 r0 movs_,#_ r12 r2 mov4_,4_ mark> 2 r0 adds_,#_ 1 tos subs_,#_ 0 r1 movs_,#_ r1 r12 mov4_,4_ r12 tos cmp4_,4_ ne bc< r2 r12 mov4_,4_ r0 tos movs_,_ ]code 32 = s" verify ; 
 : test-reg-tst-loop 16 code[ 0 r0 movs_,#_ mark> 2 r0 adds_,#_ 1 tos subs_,#_ $FF r1 movs_,#_ r1 tos tst_,_ ne bc< r0 tos movs_,_ ]code 32 = s" verify ; 
 : test-reg-cmn-loop 16 code[ 0 r0 movs_,#_ mark> 2 r0 adds_,#_ 1 tos subs_,#_ 0 r1 movs_,#_ r1 tos cmn_,_ ne bc< r0 tos movs_,_ ]code 32 = s" verify ; 
 : test-b-backward 1 [: code[ mark> 0 tos cmp_,#_ ne bc> pc 1 pop >mark 0 tos movs_,#_ b< ]code ;] execute 0 = s" verify ; 
 : test-b-forward 1 code[ b> 2 tos movs_,#_ >mark ]code 1 = s" verify ; 
 : test-bc-forward 1 code[ 0 r0 movs_,#_ eq bc> 2 tos movs_,#_ >mark ]code 1 = s" verify ; 
 : test-add-r12-sp-r12 0 code[ 1 r0 movs_,#_ 2 r1 movs_,#_ 4 r2 movs_,#_ r12 r3 mov4_,4_ r0 r1 r2 r3 4 push r2 r12 mov4_,4_ r12 add4_,sp r12 tos mov4_,4_ 0 tos tos ldr_,[_,#_] 16 addsp,sp,#_ r3 r12 mov4_,4_ ]code 2 = s" verify ; 
 : test-add-tos-sp-#4 0 code[ 1 r0 movs_,#_ 2 r1 movs_,#_ 3 r2 movs_,#_ 4 r3 movs_,#_ r0 r1 r2 r3 4 push 4 tos add_,sp,#_ 0 tos tos ldr_,[_,#_] 16 addsp,sp,#_ ]code 2 = s" verify ; 
 : test-ldr-tos-sp-#4 0 code[ 1 r0 movs_,#_ 2 r1 movs_,#_ 3 r2 movs_,#_ 4 r3 movs_,#_ r0 r1 r2 r3 4 push 4 tos ldr_,[sp,#_] 16 r0 movs_,#_ r0 addsp,sp,4_ ]code 2 = s" verify ; 
 : test-str-r0-sp-#4 0 code[ 8 r0 movs_,#_ 16 subsp,sp,#_ 4 r0 str_,[sp,#_] 4 tos ldr_,[sp,#_] 16 r0 movs_,#_ r0 addsp,sp,4_ ]code 8 = s" verify ; 
 : test-ldr-tos-pc-# 0 [: code[ tos ldr_,[pc] pc 1 pop >mark $7FFFFFFF , ]code ;] execute $7FFFFFFF = s" verify ; 
 : test-adr-tos 0 [: code[ tos adr_ 0 tos tos ldr_,[_,#_] pc 1 pop >mark $7FFFFFFF , ]code ;] execute $7FFFFFFF = s" verify ; 
 : test-push-pop 1 code[ 2 r0 movs_,#_ 3 r1 movs_,#_ 4 r2 movs_,#_ 5 r3 movs_,#_ r3 r2 r1 r0 4 push ]code s" verify ; 
 : test-stm-ldm here code[ tos r0 movs_,_ 2 r1 movs_,#_ 4 r2 movs_,#_ 8 r3 movs_,#_ r1 r2 r3 3 r0 stm tos r0 movs_,_ 0 r1 movs_,#_ 0 r2 movs_,#_ 0 r3 movs_,#_ r1 r2 r3 3 r0 ldm r2 r1 tos adds_,_,_ r3 tos tos adds_,_,_ ]code 14 = s" verify ; 
 : test-blx-tos 0 [: 2drop -1 ;] [: code[ 1 tos tos adds_,_,#_ tos blx_ ]code ;] execute -1 = s" verify ; 
 : test-bx-tos 0 [: 2drop -1 ;] [: code[ 4 addsp,sp,#_ 1 tos tos adds_,_,#_ tos bx_ ]code ;] execute -1 = s" verify ; 
 : test-misc 0 code[ cpsie cpsid dmb dsb isb ]code 0 = s" verify ; 
 : run-tests test-adds-tos-tos-#1 test-adds-tos-#1 test-adds-tos-r0-r1 test-adds-tos-r12 test-adcs-tos-r0 test-subs-tos-tos-#1 test-subs-tos-#1 test-subs-tos-r0-r1 test-sbcs-tos-r0 test-ands-tos-r0 test-orrs-tos-r0 test-eors-tos-r0 test-bics-tos-r0 test-lsls-tos-r0 test-lsrs-tos-r0 test-asrs-tos-r0 test-rors-tos-r0 test-lsls-tos-tos-#1 test-lsrs-tos-tos-#1 test-asrs-tos-tos-#1 test-muls-tos-r0 test-mvns-tos-r0 test-rev-tos-tos test-rev16-tos-tos test-revsh-tos-tos test-rsbs-tos-r0-#0 test-sxtb-tos-tos test-sxth-tos-tos test-uxtb-tos-tos test-uxth-tos-tos test-nop test-mov-tos-r12 test-str-ldr-imm test-strb-ldrb-imm test-strh-ldrh-imm test-str-ldr-reg test-strb-ldrb-reg test-strh-ldrh-reg test-strb-ldrsb-reg test-strh-ldrsh-reg test-simple-cmp-loop test-reg-cmp-loop test-reg4-cmp-loop test-reg-tst-loop test-reg-cmn-loop test-b-backward test-b-forward test-bc-forward test-add-r12-sp-r12 test-add-tos-sp-#4 test-ldr-tos-sp-#4 test-str-r0-sp-#4 test-ldr-tos-pc-# test-adr-tos test-push-pop test-stm-ldm test-blx-tos test-bx-tos test-misc ; 
 : true constant ; 
 : fold-flag constant ; 
 : init-value-flag constant ; 
 : bl constant ; 
 : start-string constant ; 
 : over 65536 u< thumb-2? or if inlined then over lit, postpone + postpone ; + cfield: does> @ dict-base @ + ; 
 : ( user ; 
 : ( variable ; 
 : min-ram-wordlist constant ; 
 : esc-string constant ; 
 : alert constant ; 
 : backspace constant ; 
 : escape constant ; 
 : form-feed constant ; 
 : return constant ; 
 : line-feed constant ; 
 : horizontal-tab constant ; 
 : vertical-tab constant ; 
 : picture-size constant ; 
 : time systick-counter >r over begin ?dup while >r swap >r dup >r execute 2r> swap r> 1- repeat drop systick-counter r> - 0 swap rot 0 swap f/ 10000,0 f/ ; 
 : bitmap-buf-size { cols rows -- bytes } rows 8 align 3 rshift cols * ; 
 : op-set constant ; 
 : op-or constant ; 
 : op-and constant ; 
 : op-bic constant ; 
 : op-xor constant ; 
 : x-invalid-op ." cr ; 
 : set-strip-const { const dst-row row-count col-count dst-col self -- } dst-row 3 rshift self page-addr dst-col + dst-row 7 and to dst-row code[ 8 r0 ldr_,[sp,#_] 12 r1 ldr_,[sp,#_] 16 r2 ldr_,[sp,#_] 20 r3 ldr_,[sp,#_] r5 r4 2 push $FF r5 movs_,#_ 8 r4 movs_,#_ r1 r4 r4 subs_,_,_ r4 r5 lsrs_,_ r2 r5 lsls_,_ r5 r3 ands_,_ 0 r0 cmp_,#_ eq bc> mark> 0 tos r4 ldrb_,[_,#_] r5 r4 bics_,_ r3 r4 orrs_,_ 0 tos r4 strb_,[_,#_] 1 tos adds_,#_ 1 r0 subs_,#_ ne bc< >mark tos 1 dp ldm r5 r4 2 pop ]code ; 
 : or-strip-const { const dst-row row-count col-count dst-col self -- } dst-row 3 rshift self page-addr dst-col + dst-row 7 and to dst-row code[ 8 r0 ldr_,[sp,#_] 12 r1 ldr_,[sp,#_] 16 r2 ldr_,[sp,#_] 20 r3 ldr_,[sp,#_] r5 r4 2 push $FF r5 movs_,#_ 8 r4 movs_,#_ r1 r4 r4 subs_,_,_ r4 r5 lsrs_,_ r2 r5 lsls_,_ r5 r3 ands_,_ 0 r0 cmp_,#_ eq bc> mark> 0 tos r4 ldrb_,[_,#_] r3 r4 orrs_,_ 0 tos r4 strb_,[_,#_] 1 tos adds_,#_ 1 r0 subs_,#_ ne bc< >mark tos 1 dp ldm r5 r4 2 pop ]code ; 
 : and-strip-const { const dst-row row-count col-count dst-col self -- } dst-row 3 rshift self page-addr dst-col + dst-row 7 and to dst-row code[ 8 r0 ldr_,[sp,#_] 12 r1 ldr_,[sp,#_] 16 r2 ldr_,[sp,#_] 20 r3 ldr_,[sp,#_] r5 r4 2 push $FF r5 movs_,#_ 8 r4 movs_,#_ r1 r4 r4 subs_,_,_ r4 r5 lsrs_,_ r2 r5 lsls_,_ r3 r3 mvns_,_ r5 r3 ands_,_ 0 r0 cmp_,#_ eq bc> mark> 0 tos r4 ldrb_,[_,#_] r3 r4 bics_,_ 0 tos r4 strb_,[_,#_] 1 tos adds_,#_ 1 r0 subs_,#_ ne bc< >mark tos 1 dp ldm r5 r4 2 pop ]code ; 
 : bic-strip-const { const dst-row row-count col-count dst-col self -- } dst-row 3 rshift self page-addr dst-col + dst-row 7 and to dst-row code[ 8 r0 ldr_,[sp,#_] 12 r1 ldr_,[sp,#_] 16 r2 ldr_,[sp,#_] 20 r3 ldr_,[sp,#_] r5 r4 2 push $FF r5 movs_,#_ 8 r4 movs_,#_ r1 r4 r4 subs_,_,_ r4 r5 lsrs_,_ r2 r5 lsls_,_ r5 r3 ands_,_ 0 r0 cmp_,#_ eq bc> mark> 0 tos r4 ldrb_,[_,#_] r3 r4 bics_,_ 0 tos r4 strb_,[_,#_] 1 tos adds_,#_ 1 r0 subs_,#_ ne bc< >mark tos 1 dp ldm r5 r4 2 pop ]code ; 
 : xor-strip-const { const dst-row row-count col-count dst-col self -- } dst-row 3 rshift self page-addr dst-col + dst-row 7 and to dst-row code[ 8 r0 ldr_,[sp,#_] 12 r1 ldr_,[sp,#_] 16 r2 ldr_,[sp,#_] 20 r3 ldr_,[sp,#_] r5 r4 2 push $FF r5 movs_,#_ 8 r4 movs_,#_ r1 r4 r4 subs_,_,_ r4 r5 lsrs_,_ r2 r5 lsls_,_ r5 r3 ands_,_ 0 r0 cmp_,#_ eq bc> mark> 0 tos r4 ldrb_,[_,#_] r3 r4 eors_,_ 0 tos r4 strb_,[_,#_] 1 tos adds_,#_ 1 r0 subs_,#_ ne bc< >mark tos 1 dp ldm r5 r4 2 pop ]code ; 
 : set-strip { src-row dst-row row-count col-count src-col dst-col src dst -- } src-row 3 rshift src page-addr src-col + dst-row 3 rshift dst page-addr dst-col + src-row 7 and to src-row dst-row 7 and to dst-row code[ r0 1 dp ldm 16 r1 ldr_,[sp,#_] 20 r2 ldr_,[sp,#_] 24 r3 ldr_,[sp,#_] r4 1 push 32 r4 ldr_,[sp,#_] r5 1 push $FF r5 movs_,#_ r1 1 push 8 r1 movs_,#_ r2 r1 r1 subs_,_,_ r1 r5 lsrs_,_ r1 1 pop 0 r1 cmp_,#_ eq bc> mark> r5 1 push tos r0 2 push 0 tos tos ldrb_,[_,#_] 0 r0 r0 ldrb_,[_,#_] r4 r0 lsrs_,_ r5 r0 ands_,_ r3 r0 lsls_,_ r3 r5 lsls_,_ r5 tos bics_,_ tos r5 movs_,_ r0 r5 orrs_,_ tos r0 2 pop 0 tos r5 strb_,[_,#_] r5 1 pop 1 tos adds_,#_ 1 r0 adds_,#_ 1 r1 subs_,#_ ne bc< >mark tos 1 dp ldm r5 r4 2 pop ]code ; 
 : or-strip { src-row dst-row row-count col-count src-col dst-col src dst -- } src-row 3 rshift src page-addr src-col + dst-row 3 rshift dst page-addr dst-col + src-row 7 and to src-row dst-row 7 and to dst-row code[ r0 1 dp ldm 16 r1 ldr_,[sp,#_] 20 r2 ldr_,[sp,#_] 24 r3 ldr_,[sp,#_] r4 1 push 32 r4 ldr_,[sp,#_] r5 1 push $FF r5 movs_,#_ r1 1 push 8 r1 movs_,#_ r2 r1 r1 subs_,_,_ r1 r5 lsrs_,_ r1 1 pop 0 r1 cmp_,#_ eq bc> mark> r5 1 push tos r0 2 push 0 tos tos ldrb_,[_,#_] 0 r0 r0 ldrb_,[_,#_] r4 r0 lsrs_,_ r5 r0 ands_,_ r3 r0 lsls_,_ tos r5 movs_,_ r0 r5 orrs_,_ tos r0 2 pop 0 tos r5 strb_,[_,#_] r5 1 pop 1 tos adds_,#_ 1 r0 adds_,#_ 1 r1 subs_,#_ ne bc< >mark tos 1 dp ldm r5 r4 2 pop ]code ; 
 : and-strip { src-row dst-row row-count col-count src-col dst-col src dst -- } src-row 3 rshift src page-addr src-col + dst-row 3 rshift dst page-addr dst-col + src-row 7 and to src-row dst-row 7 and to dst-row code[ r0 1 dp ldm 16 r1 ldr_,[sp,#_] 20 r2 ldr_,[sp,#_] 24 r3 ldr_,[sp,#_] r4 1 push 32 r4 ldr_,[sp,#_] r5 1 push $FF r5 movs_,#_ r1 1 push 8 r1 movs_,#_ r2 r1 r1 subs_,_,_ r1 r5 lsrs_,_ r1 1 pop 0 r1 cmp_,#_ eq bc> mark> r5 1 push tos r0 2 push 0 tos tos ldrb_,[_,#_] 0 r0 r0 ldrb_,[_,#_] r0 r0 mvns_,_ r4 r0 lsrs_,_ r5 r0 ands_,_ r3 r0 lsls_,_ tos r5 movs_,_ r0 r5 bics_,_ tos r0 2 pop 0 tos r5 strb_,[_,#_] r5 1 pop 1 tos adds_,#_ 1 r0 adds_,#_ 1 r1 subs_,#_ ne bc< >mark tos 1 dp ldm r5 r4 2 pop ]code ; 
 : bic-strip { src-row dst-row row-count col-count src-col dst-col src dst -- } src-row 3 rshift src page-addr src-col + dst-row 3 rshift dst page-addr dst-col + src-row 7 and to src-row dst-row 7 and to dst-row code[ r0 1 dp ldm 16 r1 ldr_,[sp,#_] 20 r2 ldr_,[sp,#_] 24 r3 ldr_,[sp,#_] r4 1 push 32 r4 ldr_,[sp,#_] r5 1 push $FF r5 movs_,#_ r1 1 push 8 r1 movs_,#_ r2 r1 r1 subs_,_,_ r1 r5 lsrs_,_ r1 1 pop 0 r1 cmp_,#_ eq bc> mark> r5 1 push tos r0 2 push 0 tos tos ldrb_,[_,#_] 0 r0 r0 ldrb_,[_,#_] r4 r0 lsrs_,_ r5 r0 ands_,_ r3 r0 lsls_,_ tos r5 movs_,_ r0 r5 bics_,_ tos r0 2 pop 0 tos r5 strb_,[_,#_] r5 1 pop 1 tos adds_,#_ 1 r0 adds_,#_ 1 r1 subs_,#_ ne bc< >mark tos 1 dp ldm r5 r4 2 pop ]code ; 
 : xor-strip { src-row dst-row row-count col-count src-col dst-col src dst -- } src-row 3 rshift src page-addr src-col + dst-row 3 rshift dst page-addr dst-col + src-row 7 and to src-row dst-row 7 and to dst-row code[ r0 1 dp ldm 16 r1 ldr_,[sp,#_] 20 r2 ldr_,[sp,#_] 24 r3 ldr_,[sp,#_] r4 1 push 32 r4 ldr_,[sp,#_] r5 1 push $FF r5 movs_,#_ r1 1 push 8 r1 movs_,#_ r2 r1 r1 subs_,_,_ r1 r5 lsrs_,_ r1 1 pop 0 r1 cmp_,#_ eq bc> mark> r5 1 push tos r0 2 push 0 tos tos ldrb_,[_,#_] 0 r0 r0 ldrb_,[_,#_] r4 r0 lsrs_,_ r5 r0 ands_,_ r3 r0 lsls_,_ tos r5 movs_,_ r0 r5 eors_,_ tos r0 2 pop 0 tos r5 strb_,[_,#_] r5 1 pop 1 tos adds_,#_ 1 r0 adds_,#_ 1 r1 subs_,#_ ne bc< >mark tos 1 dp ldm r5 r4 2 pop ]code ; 
 : next-page-row { row -- row' } row 8 align dup row = if 8 + then ; 
 : strip-rows-single { row total-row-count -- row-count } row total-row-count + row next-page-row min row - ; 
 : strip-rows { src-row dst-row total-row-count -- row-count } src-row total-row-count strip-rows-single dst-row swap strip-rows-single ; 
 : blit-const { const dst-col col-count dst-row row-count dst op -- } begin row-count 0> while dst-row row-count strip-rows-single { strip-row-count } const dst-row strip-row-count col-count dst-col dst op execute strip-row-count negate +to row-count strip-row-count +to dst-row repeat ; 
 : blit { src-col dst-col col-count src-row dst-row row-count src dst op -- } begin row-count 0> while src-row dst-row row-count strip-rows { strip-row-count } src-row dst-row strip-row-count col-count src-col dst-col src dst op execute strip-row-count negate +to row-count strip-row-count +to src-row strip-row-count +to dst-row repeat ; 
 : clip-dst-only { dst-col col-count dst-row row-count dst -- new-dst-col new-col-count new-dst-row new-row-count } dst-col 0 < if dst-col col-count + 0>= if dst-col +to col-count else 0 to col-count then 0 to dst-col then dst-col dst bitmap-cols @ < if dst-col col-count + dst bitmap-cols @ > if dst bitmap-cols @ dst-col col-count + - +to col-count then else 0 to col-count dst bitmap-cols @ to dst-col then dst-row 0 < if dst-row row-count + 0>= if dst-row +to row-count else 0 to row-count then 0 to dst-row then dst-row dst bitmap-rows @ < if dst-row row-count + dst bitmap-rows @ > if dst bitmap-rows @ dst-row row-count + - +to row-count then else 0 to row-count dst bitmap-rows @ to dst-row then dst-col col-count dst-row row-count ; 
 : clip-src { src-col dst-col col-count src-row dst-row row-count src -- new-src-col new-dst-col new-col-count new-src-row new-dst-row new-row-count } src-col 0 < if src-col negate +to dst-col src-col col-count + 0>= if src-col +to col-count else 0 to col-count then 0 to src-col then src-col src bitmap-cols @ < if src-col col-count + src bitmap-cols @ > if src bitmap-cols @ src-col col-count + - +to col-count then else 0 to row-count src bitmap-cols @ to dst-col then src-row 0 < if src-row negate +to dst-row src-row row-count + 0>= if src-row +to row-count else 0 to row-count then 0 to src-row then src-row src bitmap-rows @ < if src-row row-count + src bitmap-rows @ > if src bitmap-rows @ src-row row-count + - +to row-count then else 0 to row-count src bitmap-rows @ to dst-row then src-col dst-col col-count src-row dst-row row-count ; 
 : clip-dst { src-col dst-col col-count src-row dst-row row-count dst -- new-src-col new-dst-col new-col-count new-src-row new-dst-row new-row-count } dst-col 0 < if dst-col negate +to src-col dst-col col-count + 0>= if dst-col +to col-count else 0 to col-count then 0 to dst-col then dst-col dst bitmap-cols @ < if dst-col col-count + dst bitmap-cols @ > if dst bitmap-cols @ dst-col col-count + - +to col-count then else 0 to row-count dst bitmap-cols @ to src-col then dst-row 0 < if dst-row negate +to src-row dst-row row-count + 0>= if dst-row +to row-count else 0 to row-count then 0 to dst-row then dst-row dst bitmap-rows @ < if dst-row row-count + dst bitmap-rows @ > if dst bitmap-rows @ dst-row row-count + - +to row-count then else 0 to row-count dst bitmap-rows @ to src-row then src-col dst-col col-count src-row dst-row row-count ; 
 : clip { src dst } src clip-src dst clip-dst ; 
 : set-pixel-const { const dst-col dst-row dst -- } 0 dst-col <= 0 dst-row <= and dst-col dst bitmap-cols @ < dst-row dst bitmap-rows @ < and and if dst-col dst-row dst dirty-pixel const dst-row 1 1 dst-col dst set-strip-const then ; 
 : or-pixel-const { const dst-col dst-row dst -- } 0 dst-col <= 0 dst-row <= and dst-col dst bitmap-cols @ < dst-row dst bitmap-rows @ < and and if dst-col dst-row dst dirty-pixel const dst-row 1 1 dst-col dst or-strip-const then ; 
 : and-pixel-const { const dst-col dst-row dst -- } 0 dst-col <= 0 dst-row <= and dst-col dst bitmap-cols @ < dst-row dst bitmap-rows @ < and and if dst-col dst-row dst dirty-pixel const dst-row 1 1 dst-col dst and-strip-const then ; 
 : bic-pixel-const { const dst-col dst-row dst -- } 0 dst-col <= 0 dst-row <= and dst-col dst bitmap-cols @ < dst-row dst bitmap-rows @ < and and if dst-col dst-row dst dirty-pixel const dst-row 1 1 dst-col dst bic-strip-const then ; 
 : xor-pixel-const { const dst-col dst-row dst -- } 0 dst-col <= 0 dst-row <= and dst-col dst bitmap-cols @ < dst-row dst bitmap-rows @ < and and if dst-col dst-row dst dirty-pixel const dst-row 1 1 dst-col dst xor-strip-const then ; 
 : set-rect-const { dst } dst clip-dst-only { const dst-col col-count dst-row row-count } dst-col dup col-count + dst-row dup row-count + dst dirty-area const dst-col col-count dst-row row-count dst ['] set-strip-const blit-const ; 
 : or-rect-const { dst } dst clip-dst-only { const dst-col col-count dst-row row-count } dst-col dup col-count + dst-row dup row-count + dst dirty-area const dst-col col-count dst-row row-count dst ['] or-strip-const blit-const ; 
 : and-rect-const { dst } dst clip-dst-only { const dst-col col-count dst-row row-count } dst-col dup col-count + dst-row dup row-count + dst dirty-area const dst-col col-count dst-row row-count dst ['] and-strip-const blit-const ; 
 : bic-rect-const { dst } dst clip-dst-only { const dst-col col-count dst-row row-count } dst-col dup col-count + dst-row dup row-count + dst dirty-area const dst-col col-count dst-row row-count dst ['] bic-strip-const blit-const ; 
 : xor-rect-const { dst } dst clip-dst-only { const dst-col col-count dst-row row-count } dst-col dup col-count + dst-row dup row-count + dst dirty-area const dst-col col-count dst-row row-count dst ['] xor-strip-const blit-const ; 
 : set-rect { src dst } src dst clip { src-col dst-col col-count src-row dst-row row-count } dst-col dup col-count + dst-row dup row-count + dst dirty-area src-col dst-col col-count src-row dst-row row-count src dst ['] set-strip blit ; 
 : or-rect { src dst } src dst clip { src-col dst-col col-count src-row dst-row row-count } dst-col dup col-count + dst-row dup row-count + dst dirty-area src-col dst-col col-count src-row dst-row row-count src dst ['] or-strip blit ; 
 : and-rect { src dst } src dst clip { src-col dst-col col-count src-row dst-row row-count } dst-col dup col-count + dst-row dup row-count + dst dirty-area src-col dst-col col-count src-row dst-row row-count src dst ['] and-strip blit ; 
 : bic-rect { src dst } src dst clip { src-col dst-col col-count src-row dst-row row-count } dst-col dup col-count + dst-row dup row-count + dst dirty-area src-col dst-col col-count src-row dst-row row-count src dst ['] bic-strip blit ; 
 : xor-rect { src dst } src dst clip { src-col dst-col col-count src-row dst-row row-count } dst-col dup col-count + dst-row dup row-count + dst dirty-area src-col dst-col col-count src-row dst-row row-count src dst ['] xor-strip blit ; 
 : draw-pixel-line-low { const x0 y0 x1 y1 op dst -- } x1 x0 - y1 y0 - 1 y0 { dx dy yi y } dy 0< if -1 to yi dy negate to dy then 2 dy * dx - { d } x1 1+ x0 ?do const i y op dst draw-pixel-const d 0> if yi +to y dy dx - 2 * +to d else 2 dy * +to d then loop ; 
 : draw-pixel-line-high { const x0 y0 x1 y1 op dst -- } x1 x0 - y1 y0 - 1 x0 { dx dy xi x } dx 0< if -1 to xi dx negate to dx then 2 dx * dy - { d } y1 1+ y0 ?do const x i op dst draw-pixel-const d 0> if xi +to x dx dy - 2 * +to d else 2 dx * +to d then loop ; 
 : draw-rect-line-low { const width height x0 y0 x1 y1 op dst -- } width 2 / height 2 / { width2/ height2/ } x1 x0 - y1 y0 - 1 y0 { dx dy yi y } dy 0< if -1 to yi dy negate to dy then 2 dy * dx - { d } x1 1+ x0 ?do const i width2/ - width y height2/ - height op dst draw-rect-const d 0> if yi +to y dy dx - 2 * +to d else 2 dy * +to d then loop ; 
 : draw-rect-line-high { const width height x0 y0 x1 y1 op dst -- } width 2 / height 2 / { width2/ height2/ } x1 x0 - y1 y0 - 1 x0 { dx dy xi x } dx 0< if -1 to xi dx negate to dx then 2 dx * dy - { d } y1 1+ y0 ?do const x width2/ - width i height2/ - height op dst draw-rect-const d 0> if xi +to x dx dy - 2 * +to d else 2 dx * +to d then loop ; 
 : draw-bitmap-line-low { src-x src-y width height x0 y0 x1 y1 op src dst -- } width 2 / height 2 / { width2/ height2/ } x1 x0 - y1 y0 - 1 y0 { dx dy yi y } dy 0< if -1 to yi dy negate to dy then 2 dy * dx - { d } x1 1+ x0 ?do src-x i width2/ - width src-y y height2/ - height op src dst draw-rect d 0> if yi +to y dy dx - 2 * +to d else 2 dy * +to d then loop ; 
 : draw-bitmap-line-high { src-x src-y width height x0 y0 x1 y1 op src dst -- } width 2 / height 2 / { width2/ height2/ } x1 x0 - y1 y0 - 1 x0 { dx dy xi x } dx 0< if -1 to xi dx negate to dx then 2 dx * dy - { d } y1 1+ y0 ?do src-x x width2/ - width src-y i height2/ - height op src dst draw-rect d 0> if xi +to x dx dy - 2 * +to d else 2 dx * +to d then loop ; 
 : draw-pixel-line { const x0 y0 x1 y1 op dst -- } y1 y0 - abs x1 x0 - abs < if x0 x1 > if const x1 y1 x0 y0 op dst draw-pixel-line-low else const x0 y0 x1 y1 op dst draw-pixel-line-low then else y0 y1 > if const x1 y1 x0 y0 op dst draw-pixel-line-high else const x0 y0 x1 y1 op dst draw-pixel-line-high then then ; 
 : draw-rect-line { const width height x0 y0 x1 y1 op dst -- } y1 y0 - abs x1 x0 - abs < if x0 x1 > if const width height x1 y1 x0 y0 op dst draw-rect-line-low else const width height x0 y0 x1 y1 op dst draw-rect-line-low then else y0 y1 > if const width height x1 y1 x0 y0 op dst draw-rect-line-high else const width height x0 y0 x1 y1 op dst draw-rect-line-high then then ; 
 : draw-bitmap-line { src-x src-y width height x0 y0 x1 y1 op src dst -- } y1 y0 - abs x1 x0 - abs < if x0 x1 > if src-x src-y width height x1 y1 x0 y0 op src dst draw-bitmap-line-low else src-x src-y width height x0 y0 x1 y1 op src dst draw-bitmap-line-low then else y0 y1 > if src-x src-y width height x1 y1 x0 y0 op src dst draw-bitmap-line-high else src-x src-y width height x0 y0 x1 y1 op src dst draw-bitmap-line-high then then ; 
 : draw-pixel-circle { const x y radius op dst -- } 1 radius - 0 radius 2* negate 0 radius { f ddx ddy dx dy } const x y radius + op dst draw-pixel-const const x y radius - op dst draw-pixel-const const x radius + y op dst draw-pixel-const const x radius - y op dst draw-pixel-const begin dx dy < while f 0>= if dy 1- to dy ddy 2 + dup to ddy f + to f then dx 1+ to dx ddx 2 + dup to ddx f 1+ + to f const x dx + y dy + op dst draw-pixel-const const x dx - y dy + op dst draw-pixel-const const x dx + y dy - op dst draw-pixel-const const x dx - y dy - op dst draw-pixel-const const x dy + y dx + op dst draw-pixel-const const x dy - y dx + op dst draw-pixel-const const x dy + y dx - op dst draw-pixel-const const x dy - y dx - op dst draw-pixel-const repeat ; 
 : draw-rect-circle { const width height x y radius op dst -- } width 2 / height 2 / { width2/ height2/ } 1 radius - 0 radius 2* negate 0 radius { f ddx ddy dx dy } const x width2/ - width y radius + height2/ - height op dst draw-rect-const const x width2/ - width y radius - height2/ - height op dst draw-rect-const const x radius + width2/ - width y height2/ - height op dst draw-rect-const const x radius - width2/ - width y height2/ - height op dst draw-rect-const begin dx dy < while f 0>= if dy 1- to dy ddy 2 + dup to ddy f + to f then dx 1+ to dx ddx 2 + dup to ddx f 1+ + to f const x dx + width2/ - width y dy + height2/ - height op dst draw-rect-const const x dx - width2/ - width y dy + height2/ - height op dst draw-rect-const const x dx + width2/ - width y dy - height2/ - height op dst draw-rect-const const x dx - width2/ - width y dy - height2/ - height op dst draw-rect-const const x dy + width2/ - width y dx + height2/ - height op dst draw-rect-const const x dy - width2/ - width y dx + height2/ - height op dst draw-rect-const const x dy + width2/ - width y dx - height2/ - height op dst draw-rect-const const x dy - width2/ - width y dx - height2/ - height op dst draw-rect-const repeat ; 
 : draw-bitmap-circle { src-x src-y width height x y radius op src dst -- } width 2 / height 2 / { width2/ height2/ } 1 radius - 0 radius 2* negate 0 radius { f ddx ddy dx dy } src-x x width2/ - width src-y y radius + height2/ - height op src dst draw-rect src-x x width2/ - width src-y y radius - height2/ - height op src dst draw-rect src-x x radius + width2/ - width src-y y height2/ - height op src dst draw-rect src-x x radius - width2/ - width src-y y height2/ - height op src dst draw-rect begin dx dy < while f 0>= if dy 1- to dy ddy 2 + dup to ddy f + to f then dx 1+ to dx ddx 2 + dup to ddx f 1+ + to f src-x x dx + width2/ - width src-y y dy + height2/ - height op src dst draw-rect src-x x dx - width2/ - width src-y y dy + height2/ - height op src dst draw-rect src-x x dx + width2/ - width src-y y dy - height2/ - height op src dst draw-rect src-x x dx - width2/ - width src-y y dy - height2/ - height op src dst draw-rect src-x x dy + width2/ - width src-y y dx + height2/ - height op src dst draw-rect src-x x dy - width2/ - width src-y y dx + height2/ - height op src dst draw-rect src-x x dy + width2/ - width src-y y dx - height2/ - height op src dst draw-rect src-x x dy - width2/ - width src-y y dx - height2/ - height op src dst draw-rect repeat ; 
 : draw-filled-circle { const x y radius op dst -- } 1 radius - 0 radius 2* negate 0 radius { f ddx ddy dx dy } const x 1 y radius + 1 op dst draw-rect-const const x 1 y radius - 1 op dst draw-rect-const const x radius - radius 2* y 1 op dst draw-rect-const begin dx dy < while f 0>= if dy 1- to dy ddy 2 + dup to ddy f + to f then dx 1+ to dx ddx 2 + dup to ddx f 1+ + to f const x dx - dx 2 * y dy + 1 op dst draw-rect-const const x dx - dx 2 * y dy - 1 op dst draw-rect-const const x dy - dy 2 * y dx + 1 op dst draw-rect-const const x dy - dy 2 * y dx - 1 op dst draw-rect-const repeat ; 
 : blinker-delay variable ; 
 : blinker begin green toggle-led blinker-delay @ ms again ; 
 : blinker-task variable ; 
 : init-blinker 500 blinker-delay ! 0 ['] blinker 420 128 512 spawn blinker-task ! blinker-task @ run ; 
 : vary-delay variable ; 
 : vary-min variable ; 
 : vary-max variable ; 
 : vary-step variable ; 
 : vary begin vary-min @ blinker-delay ! begin linker-delay @ vary-max @ < while ary-delay @ ms linker-delay @ vary-step @ + blinker-delay ! repeat vary-max @ blinker-delay ! begin linker-delay @ vary-min @ > while ary-delay @ ms linker-delay @ vary-step @ - blinker-delay ! repeat again ; 
 : vary-task variable ; 
 : init-vary 100 vary-delay ! 50 vary-min ! 500 vary-max ! 25 vary-step ! 0 ['] vary 420 128 512 spawn vary-task ! vary-task @ run ; 
 : x-block-out-of-range ." cr ; 
 : block-size constant ; 
 : x-block-write-fail ." cr ; 
 : sector-block-id-map-offset constant ; 
 : unwritten constant ; 
 : saved-sector variable ; 
 : sector-index qspi-base - sector-size / ; 
 : sector-addr sector-size * qspi-base + ; 
 : block-index qspi-base - dup sector-size umod block-size / 1 - swap sector-size / ; 
 : block-addr sector-addr swap 1 + block-size * + ; 
 : block-id@ sector-addr sector-block-id-map-offset + swap cells + @ ; 
 : old-flag@ sector-addr sector-old-flag-map-offset + swap cells + @ unwritten <> ; 
 : erase-count@ sector-addr sector-erase-count-offset + @ ; 
 : free-count@ sector-free-map + c@ ; 
 : old-count@ sector-old-map + c@ ; 
 : new-count dup free-count@ swap old-count@ + sector-block-count swap - ; 
 : free-count! sector-free-map + c! ; 
 : old-count! sector-old-map + c! ; 
 : free-count+! sector-free-map + c+! ; 
 : old-count+! sector-old-map + c+! ; 
 : next-new-sector begin up sector-count < if dup saved-sector @ <> if dup new-count 0= if 1+ false else true then else 1+ false then lse drop -1 true hen until ; 
 : find-sector-block sector-block-count 0 ?do over block-id@ 2 pick = if i over old-flag@ not if i swap block-addr nip unloop exit then hen loop 2drop 0 ; 
 : find-block 0 begin ext-new-sector dup -1 <> if 2dup find-sector-block ?dup if nip nip true else 1+ false then lse drop drop 0 true hen until ; 
 : reuse-sector 0 over old-count! sector-block-count over free-count! sector-addr dup erase-qspi-sector sector-erase-count-offset + qspi! ; 
 : find-old-sector $FFFFFFFF -1 sector-count 0 ?do old-count@ sector-block-count = if i saved-sector @ <> if i erase-count@ 1+ >r over r> u> if 2drop i erase-count@ 1+ i then then hen loop ; 
 : find-saved-sector $FFFFFFFF -1 sector-count 0 ?do old-count@ sector-block-count = free-count@ sector-block-count = or if i erase-count@ 1+ >r over r> u> if 2drop i erase-count@ 1+ i then hen loop nip ; 
 : find-reorganize-sector -1 -1 sector-count 0 ?do saved-sector @ <> if i new-count over u< i new-count sector-block-count u< and if 2drop i dup new-count then hen loop drop ; 
 : find-sector-with-free-block sector-count 0 ?do saved-sector @ <> i free-count@ 0> and if i unloop exit then loop -1 ; 
 : find-free-block-in-sector sector-block-count 0 ?do over block-id@ unwritten = if i nip unloop exit then loop drop -1 ; 
 : x-should-never-happen ." cr ; 
 : find-free-block find-sector-with-free-block dup -1 <> if up find-free-block-in-sector dup -1 <> verts x-should-never-happen swap else rop find-old-sector dup -1 <> if tuck reuse-sector dup find-free-block-in-sector dup -1 <> if swap else true triggers x-should-never-happen then lse nip -1 hen then ; 
 : find-saved-block saved-sector @ find-free-block-in-sector dup -1 <> averts x-should-never-happen saved-sector @ ; 
 : old-flag! 0 -rot sector-addr sector-old-flag-map-offset + swap cells + qspi! ; 
 : block-id! sector-addr sector-block-id-map-offset + swap cells + qspi! ; 
 : data! 1024 swap mass-qspi! ; 
 : copy-blocks-into-saved-sector sector-block-count 0 ?do over old-flag@ not if find-saved-block -1 over free-count+! 2dup i 5 pick block-id@ -rot block-id! i 3 pick block-addr ram-here block-size move ram-here -rot block-addr data! hen loop drop ; 
 : mark-all-old sector-block-count 0 ?do over old-flag@ not if dup i swap old-flag! hen loop sector-block-count over old-count! 0 swap free-count! ; 
 : reorganize-sector saved-sector @ erase-count@ 1+ saved-sector @ reuse-sector find-reorganize-sector dup -1 <> averts x-block-write-fail dup copy-blocks-into-saved-sector dup mark-all-old saved-sector ! ; 
 : blocks-available? sector-count 0 ?do saved-sector @ <> if i new-count sector-block-count <> if true unloop exit then hen loop false ; 
 : reorganize-block! >r reorganize-sector find-free-block dup -1 <> averts x-block-write-fail -1 over free-count+! 2dup r> -rot block-id! block-addr data! ; 
 : block! blocks-available? averts x-block-write-fail dup >r find-block ?dup if lock-index 1 over old-count+! old-flag! ind-free-block dup -1 <> if -1 over free-count+! 2dup r> -rot block-id! block-addr data! lse 2drop r> reorganize-block! hen else ind-free-block dup -1 <> if -1 over free-count+! 2dup r> -rot block-id! block-addr data! lse 2drop r> reorganize-block! hen then ; 
 : discover-sector-free-count >r 0 begin dup sector-block-count < while up cells r@ sector-addr sector-block-id-map-offset + + @ unwritten = if 1 r@ free-count+! hen 1+ repeat drop rdrop ; 
 : discover-free-count sector-free-map sector-count 0 fill sector-count 0 ?do i discover-sector-free-count loop ; 
 : discover-sector-old-count >r 0 begin dup sector-block-count < while up cells r@ sector-addr sector-old-flag-map-offset + + @ unwritten <> f 1 r@ old-count+! hen 1+ repeat drop rdrop ; 
 : discover-old-count sector-old-map sector-count 0 fill sector-count 0 ?do i discover-sector-old-count loop ; 
 : x-unable-to-find-saved-sector space ." cr ; 
 : find-saved-sector 0 saved-sector ! find-saved-sector dup -1 <> averts x-unable-to-find-saved-sector saved-sector ! ; 
 : erase-all-blocks erase-qspi-bulk sector-count 0 ?do i old-count! sector-block-count i free-count! loop ; 
 : truncate-invalid swap tuck swap begin up 0> if over c@ dup $20 >= swap $7F <> and if 1- swap 1+ swap false else true then lse true hen until drop over - ; 
 : init-block discover-free-count discover-old-count find-saved-sector ; 
 : x-block-not-found ." cr ; 
 : x-invalid-block-id ." cr ; 
 : delete-block dup unwritten <> averts x-invalid-block-id begin-critical find-block ?dup if block-index 1 over old-count+! qspi-base block-size + -rot old-flag! end-critical else end-critical ['] x-block-not-found ?raise then ; 
 : block? find-block 0<> ; 
 : delete-blocks over + swap ?do i block? if i delete-block then loop ; 
 : find-block dup unwritten <> averts x-invalid-block-id begin-critical find-block end-critical ; 
 : block! begin-critical block! end-critical ; 
 : erase-all-blocks begin-critical erase-all-blocks end-critical ; 
 : block-size block-size ; 
 : x-block-not-found ." cr ; 
 : copy-block over block? if ram-here >r block-size ram-allot over find-block r@ block-size move r> over block! block-size negate ram-allot else dup block? if up delete-block then then 2drop ; 
 : copy-blocks-from-start 0 ?do 2dup copy-block 1+ swap 1+ swap loop 2drop ; 
 : copy-blocks-from-end >r r@ + swap r@ + swap r> 0 ?do 1- swap 1- swap 2dup copy-block loop 2drop ; 
 : find-empty-block-seq begin dup 0<> while ver block? not if 1- hen wap 1+ swap repeat drop ; 
 : get-extant-block-count 0 rot rot swap ?do i block? if 1+ then loop ; 
 : copy-blocks-no-delete-from-end swap 1- dup rot begin dup 0<> while r ver block? if 2dup copy-block 1- swap 1- swap r> 1- lse swap 1- swap r> hen repeat drop 2drop ; 
 : copy-blocks -rot 2dup < if rot copy-blocks-from-end else rot copy-blocks-from-start then ; 
 : insert-blocks dup >r 2dup find-empty-block-seq nip 2dup get-extant-block-count copy-blocks-no-delete-from-end r> delete-blocks ; 
 : current-block eval-data @ @ find-block ; 
 : current-line eval-data @ cell+ @ ; 
 : advance-line 64 eval-data @ cell+ +! ; 
 : block-refill advance-line current-block current-line + 64 truncate-invalid feed-input ; 
 : block-eof current-line [ 1024 64 - ] literal >= ; 
 : load dup block? averts x-block-not-found [: 0 >r >r rp@ dup @ find-block 64 truncate-invalid ['] block-refill ['] block-eof evaluate-with-input rdrop rdrop ;] try ?raise ; 
 : list dup block? averts x-block-not-found find-block 16 0 ?do cr i 9 < if space then i 1+ . dup i 64 * + 64 truncate-invalid type loop cr drop ; 
 : load-range 1+ swap ?do i find-block dup if up block-size + swap ?do i 64 truncate-invalid evaluate 4 +loop else rop then loop ; 
 : list-range 1+ swap ?do i find-block dup if up block-size + swap ?do cr i 64 truncate-invalid type 4 +loop else rop then loop cr ; 
 : find-data-change begin ource >parse @ > if >parse @ + c@ case [char] + of 1+ false 1 >parse +! endof [char] - of 1- false 1 >parse +! endof [char] [ of true endof [char] ] of true endof [char] > of true endof [char] < of true endof [char] . of true endof [char] , of true endof [char] ; of true endof false 1 >parse +! swap endcase lse drop prompt-hook @ ?execute refill false hen until ; 
 : find-addr-change begin ource >parse @ > if >parse @ + c@ case [char] > of 1+ false 1 >parse +! endof [char] < of 1- false 1 >parse +! endof [char] [ of true endof [char] ] of true endof [char] + of true endof [char] - of true endof [char] . of true endof [char] , of true endof [char] ; of true endof false 1 >parse +! swap endcase lse drop prompt-hook @ ?execute refill false hen until ; 
 : :bf token dup 0= triggers x-token-expected start-compile begin source >parse @ > if parse @ + c@ 1 >parse +! ase [char] [ of postpone begin postpone dup postpone c@ postpone while false endof [char] ] of postpone repeat false endof [char] + of 1 find-data-change lit, postpone over postpone c+! false endof [char] - of -1 find-data-change lit, postpone over postpone c+! false endof [char] > of 1 find-addr-change lit, postpone + false endof [char] < of -1 find-addr-change lit, postpone + false endof [char] . of postpone dup postpone c@ postpone emit false endof [char] , of postpone key postpone over postpone c! false endof [char] ; of true endof false swap ndcase else rop prompt-hook @ ?execute refill false then until visible end-compile, ; 
 : :bf-cell token dup 0= triggers x-token-expected start-compile begin source >parse @ > if parse @ + c@ 1 >parse +! ase [char] [ of postpone begin postpone dup postpone @ postpone while false endof [char] ] of postpone repeat false endof [char] + of 1 find-data-change lit, postpone over postpone +! false endof [char] - of -1 find-data-change lit, postpone over postpone +! false endof [char] > of 1 find-addr-change cells lit, postpone + false endof [char] < of -1 find-addr-change cells lit, postpone + false endof [char] . of postpone dup postpone @ $FF lit, postpone and postpone emit false endof [char] , of postpone key postpone over postpone ! false endof [char] ; of true endof false swap ndcase else rop prompt-hook @ ?execute refill false then until visible end-compile, ; 
 : init-test my-buffer 30000 0 fill my-buffer test drop ; 
 : capture-read-index variable ; 
 : capture-write-index variable ; 
 : capture-buffer-size constant ; 
 : init init 0 capture-read-index h! 0 capture-write-index h! emit-hook @ saved-emit-hook ! 0 capture-fail-hook ! 0 capture-enabled ! ' capture-emit emit-hook ! ; 
 : my-task-count constant ; 
 : my-chan-size constant ; 
 : producer 0 begin dup $FF and dup cr ." . [: my-chan send-chan ;] provide-allot-byte 1+ 500 ms again ; 
 : consumer 4000 ms begin [: my-chan recv-chan ;] extract-allot-byte cr ." . 500 ms again ; 
 : closer 8000 ms my-chan close-chan ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : closer-task variable ; 
 : init-test 420 128 512 my-task-count my-task-pool init-task-pool my-chan my-chan-size init-chan 0 ['] producer my-task-pool spawn-from-task-pool producer-task ! 0 ['] consumer my-task-pool spawn-from-task-pool consumer-task ! 0 ['] closer my-task-pool spawn-from-task-pool closer-task ! producer-task @ run consumer-task @ run closer-task @ run pause ; 
 : element-size constant ; 
 : inter-count constant ; 
 : end-count constant ; 
 : end-interval constant ; 
 : producer-task variable ; 
 : inter-task variable ; 
 : consumer-task variable ; 
 : producer source-send-buf element-size 0 fill begin source-send-buf element-size inter-chan send-chan again ; 
 : inter begin inter-recv-buf element-size inter-chan recv-chan inter-recv-buf swap end-chan send-chan again ; 
 : consumer end-interval 0 begin end-recv-buf element-size end-chan recv-chan + 2dup <= if up . swap end-interval + swap then again ; 
 : init-test element-size inter-count inter-chan init-chan element-size end-count end-chan init-chan 0 ['] consumer 420 128 512 0 spawn-on-core consumer-task ! 0 ['] inter 420 128 512 1 spawn-on-core inter-task ! 0 ['] producer 420 128 512 0 spawn-on-core producer-task ! consumer-task @ run inter-task @ run producer-task @ run ; 
 : element-size constant ; 
 : inter-count constant ; 
 : end-count constant ; 
 : end-interval constant ; 
 : producer-task variable ; 
 : inter-task variable ; 
 : consumer-task variable ; 
 : recv-count variable ; 
 : start-systick variable ; 
 : producer source-send-buf element-size 0 fill begin source-send-buf element-size inter-chan send-chan again ; 
 : inter begin inter-recv-buf element-size inter-chan recv-chan inter-recv-buf swap end-chan send-chan again ; 
 : consumer begin 1 recv-count +! end-recv-buf element-size end-chan recv-chan drop recv-count @ end-interval > if recv-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 end-interval f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 recv-count ! systick-counter start-systick ! element-size inter-count inter-chan init-chan element-size end-count end-chan init-chan 0 ['] consumer 420 128 512 0 spawn-on-core consumer-task ! 0 ['] inter 420 128 512 1 spawn-on-core inter-task ! 0 ['] producer 420 128 512 0 spawn-on-core producer-task ! consumer-task @ run inter-task @ run producer-task @ run ; 
 : x-chan-closed ." cr ; 
 : chan-full? dup chan-current-count @ swap chan-count @ = ; 
 : chan-empty? chan-current-count @ 0= ; 
 : wait-send-chan { chan -- } begin chan chan-full? while chan chan-send-ready +! han chan-send-tqueue ['] wait-tqueue try 1 chan chan-send-ready +! raise repeat chan chan-closed @ triggers x-chan-closed ; 
 : wait-recv-chan { chan -- } begin chan chan-empty? while han chan-closed @ triggers x-chan-closed chan chan-recv-ready +! han chan-recv-tqueue ['] wait-tqueue try 1 chan chan-recv-ready +! raise repeat ; 
 : send-chan-addr dup chan-send-index @ over chan-data-size @ * chan-header-size + + ; 
 : recv-chan-addr dup chan-recv-index @ over chan-data-size @ * chan-header-size + + ; 
 : advance-send-chan 1 over chan-current-count +! dup chan-send-index @ 1+ over chan-count @ umod swap chan-send-index ! ; 
 : advance-recv-chan -1 over chan-current-count +! dup chan-recv-index @ 1+ over chan-count @ umod swap chan-recv-index ! ; 
 : chan-size * chan-header-size + 4 align ; 
 : init-chan dup chan-slock init-slock tuck chan-count ! tuck chan-data-size ! 0 over chan-current-count ! 0 over chan-recv-index ! 0 over chan-send-index ! 0 over chan-recv-ready ! 0 over chan-send-ready ! dup chan-slock over chan-recv-tqueue 1 -rot 0 -rot init-tqueue-full dup chan-slock over chan-send-tqueue 1 -rot 0 -rot init-tqueue-full false swap chan-closed ! ; 
 : send-chan [: s" trace ;] over chan-slock with-slock ; 
 : recv-chan [: s" trace ;] over chan-slock with-slock ; 
 : peek-chan [: s" trace ;] over chan-slock with-slock ; 
 : skip-chan [: s" trace ;] over chan-slock with-slock ; 
 : send-chan-no-block [: s" trace ;] over chan-slock with-slock ; 
 : recv-chan-no-block [: s" trace ;] over chan-slock with-slock ; 
 : peek-chan-no-block [: s" trace ;] over chan-slock with-slock ; 
 : skip-chan-no-block [: s" trace ;] over chan-slock with-slock ; 
 : close-chan [: true over chan-closed ! dup chan-send-tqueue wake-tqueue-all chan-recv-tqueue wake-tqueue-all ;] over chan-slock with-slock ; 
 : chan-closed? chan-closed @ ; 
 : reopen-chan false swap chan-closed ! ; 
 : chan-count chan-count @ ; 
 : chan-data-size chan-data-size @ ; 
 : my-chan-size constant ; 
 : init-test 1 my-chan-size my-chan init-chan 0 [: 0 0 { counter W^ my-buffer } begin my-buffer 1 my-chan recv-chan drop my-buffer c@ { my-byte } my-byte counter <> if cr ." my-byte h.2 then my-byte 1+ $FF and to counter again ;] 320 128 512 spawn run 0 [: 0 { W^ counter } begin counter 1 my-chan send-chan counter c@ 1+ $FF and counter c! again ;] 320 128 512 spawn run ; 
 : element-size constant ; 
 : element-count constant ; 
 : consumer begin [: my-chan recv-chan ;] extract-allot-cell drop again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer begin 0 [: my-chan send-chan ;] provide-allot-cell 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : consumer-task variable ; 
 : producer-task variable ; 
 : init-test 0 send-count ! systick-counter start-systick ! element-size element-count my-chan init-chan 0 ['] consumer 420 128 512 1 spawn-on-core consumer-task ! 0 ['] producer 420 128 512 spawn producer-task ! consumer-task @ run producer-task @ run pause ; 
 : element-size constant ; 
 : element-count constant ; 
 : consumer begin [: my-chan recv-chan ;] extract-allot-cell drop again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer begin 0 [: my-chan send-chan ;] provide-allot-cell 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! element-size element-count my-chan init-chan consumer-task run producer-task run pause ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 5000 timeout ! 25 ms 0 [: my-chan send-chan ;] provide-allot-cell cr ." ; 
 : do-task-3 no-timeout timeout ! 50 ms 0 [: my-chan send-chan ;] provide-allot-cell cr ." ; 
 : init-test 1 cells 1 my-chan init-chan 0 [: my-chan send-chan ;] provide-allot-cell 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms 0 [: my-chan send-chan ;] provide-allot-cell cr ." ; 
 : do-task-3 5000 timeout ! 50 ms 0 [: my-chan send-chan ;] provide-allot-cell cr ." ; 
 : init-test 1 cells 1 my-chan init-chan 0 [: my-chan send-chan ;] provide-allot-cell 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms [: my-chan recv-chan ;] extract-allot-cell cr ." . ; 
 : do-task-3 5000 timeout ! 50 ms [: my-chan recv-chan ;] extract-allot-cell cr ." . ; 
 : do-task-4 no-timeout timeout ! 75 ms [: my-chan recv-chan ;] extract-allot-cell cr ." . ; 
 : init-test 1 cells 1 my-chan init-chan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! 0 ['] do-task-4 420 128 512 spawn my-task-4 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run my-task-4 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 5000 timeout ! 25 ms [: my-chan recv-chan ;] extract-allot-cell cr ." . ; 
 : do-task-3 no-timeout timeout ! 50 ms [: my-chan recv-chan ;] extract-allot-cell cr ." . ; 
 : init-test 1 cells 1 my-chan init-chan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms [: my-chan recv-chan ;] extract-allot-cell cr ." . ; 
 : do-task-3 5000 timeout ! 50 ms [: my-chan recv-chan ;] extract-allot-cell cr ." . ; 
 : init-test 1 cells 1 my-chan init-chan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms 0 [: my-chan send-chan ;] provide-allot-cell cr ." ; 
 : do-task-3 5000 timeout ! 50 ms 0 [: my-chan send-chan ;] provide-allot-cell cr ." ; 
 : do-task-4 no-timeout timeout ! 75 ms 0 [: my-chan send-chan ;] provide-allot-cell cr ." ; 
 : init-test 1 cells 1 my-chan init-chan 0 [: my-chan send-chan ;] provide-allot-cell 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! 0 ['] do-task-4 420 128 512 spawn my-task-4 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run my-task-4 @ run ; 
 : element-count constant ; 
 : my-task variable ; 
 : test 0 wait-notify drop cr ." ; 
 : init-test 0 ['] test 420 128 512 spawn dup my-task ! my-mailboxes 2 my-task @ config-notify my-task @ run 1 my-task @ notify 0 my-task @ notify 20 0 ?do ." 100 ms loop 1 my-task @ notify ; 
 : FLASH_Base constant ; 
 : FLASH_ACR_PRFTEN constant ; 
 : FLASH_ACR_ICEN constant ; 
 : FLASH_ACR_LATENCY constant ; 
 : RCC_Base constant ; 
 : RCC_CR_HSIRDY constant ; 
 : RCC_CR_HSION constant ; 
 : RCC_CFGR_SW constant ; 
 : RCC_CFGR_SW_HSE constant ; 
 : RCC_CFGR_SW_PLL constant ; 
 : RCC_CFGR_SWS constant ; 
 : RCC_CFGR_SWS_HSE constant ; 
 : RCC_CFGR_SWS_PLL constant ; 
 : USART2_Base constant ; 
 : USART2_CR1_RE constant ; 
 : USART2_CR1_TE constant ; 
 : time-multiplier constant ; 
 : time-divisor constant ; 
 : systick-divisor constant ; 
 : find-closure-size [: here [: cell align, here { here-start } 0 h, $FEDCBA98 lit, $FEDCBA99 lit, undefer-lit [ armv6m-instr import ] tos r0 movs_,_ tos 1 dp ldm r0 bx_ [ armv6m-instr unimport ] thumb-2? not if consts, then here here-start - cell align ;] with-here ;] with-ram ; 
 : find-dclosure-size [: here [: cell align, here { here-start } 0 h, $FEDCBA98 lit, $FEDCBA99 lit, $FEDCBA9A lit, undefer-lit [ armv6m-instr import ] tos r0 movs_,_ tos 1 dp ldm r0 bx_ [ armv6m-instr unimport ] thumb-2? not if consts, then here here-start - cell align ;] with-here ;] with-ram ; 
 : find-refclosure-size [: here [: cell align, here { here-start } 0 h, $FEDCBA98 lit, $FEDCBA99 lit, undefer-lit [ armv6m-instr import ] tos r0 movs_,_ tos 1 dp ldm r0 bx_ [ armv6m-instr unimport ] thumb-2? not if consts, then cell align, 0 , here here-start - cell align ;] with-here ;] with-ram ; 
 : find-2refclosure-size [: here [: cell align, here { here-start } $FEDCBA98 lit, $FEDCBA9A lit, undefer-lit [ armv6m-instr import ] tos r0 movs_,_ 0 dp tos ldr_,[_,#_] cell tos adds_,#_ r0 bx_ [ armv6m-instr unimport ] thumb-2? not if consts, then cell align, 0. 2, here here-start - cell align ;] with-here ;] with-ram ; 
 : find-drefclosure-size [: here [: cell align, here { here-start } 0 h, $FEDCBA98 lit, $FEDCBA9A lit, undefer-lit [ armv6m-instr import ] tos r0 movs_,_ tos 1 dp ldm r0 bx_ [ armv6m-instr unimport ] thumb-2? not if consts, then cell align, 0. 2, here here-start - cell align ;] with-here ;] with-ram ; 
 : closure-size constant ; 
 : dclosure-size constant ; 
 : nclosure-size 2 + cells closure-size + ; 
 : ndclosure-size 2 * 2 + cells closure-size + ; 
 : refclosure-size constant ; 
 : 2refclosure-size constant ; 
 : drefclosure-size constant ; 
 : nrefclosure-size nclosure-size ; 
 : ndrefclosure-size 2 * 2 + cells closure-size + ; 
 : bind [: swap [: { data xt } data lit, xt 1 or lit, undefer-lit [ armv6m-instr import ] tos r0 movs_,_ tos 1 dp ldm r0 bx_ [ armv6m-instr unimport ] thumb-2? not if consts, then ;] with-here ;] with-ram ; 
 : dbind [: swap [: { data1 data0 xt } data1 lit, data0 lit, xt 1 or lit, undefer-lit [ armv6m-instr import ] tos r0 movs_,_ tos 1 dp ldm r0 bx_ [ armv6m-instr unimport ] thumb-2? not if consts, then ;] with-here ;] with-ram ; 
 : nbind { count addr xt -- } addr closure-size + { data-addr } xt data-addr ! count data-addr cell+ ! 0 { index } begin index count < while index 2 + cells data-addr + ! 1 +to index repeat data-addr addr [: >r r@ cell+ @ begin dup while 1- dup 2 + cells r@ + @ swap repeat drop r> @ execute ;] bind ; 
 : ndbind { count addr xt -- } addr closure-size + { data-addr } xt data-addr ! count data-addr cell+ ! 0 { index } begin index count < while index 1 lshift 2 + cells data-addr + 2! 1 +to index repeat data-addr addr [: >r r@ cell+ @ begin dup while 1- dup 1 lshift 2 + cells r@ + 2@ rot repeat drop r> @ execute ;] bind ; 
 : refbind [: over [: { data addr xt } addr refclosure-size cell - + lit, xt 1 or lit, undefer-lit [ armv6m-instr import ] tos r0 movs_,_ tos 1 dp ldm r0 bx_ [ armv6m-instr unimport ] thumb-2? not if consts, then cell align, data , ;] with-here ;] with-ram ; 
 : drefbind [: over [: { D: data addr xt } addr drefclosure-size 2 cells - + lit, xt 1 or lit, undefer-lit [ armv6m-instr import ] tos r0 movs_,_ tos 1 dp ldm r0 bx_ [ armv6m-instr unimport ] thumb-2? not if consts, then cell align, data 2, ;] with-here ;] with-ram ; 
 : nrefbind { count addr xt -- } addr closure-size + { data-addr } xt data-addr ! count data-addr cell+ ! 0 { index } begin index count < while index 2 + cells data-addr + ! 1 +to index repeat data-addr addr [: >r r@ cell+ @ begin dup while 1- dup 2 + cells r@ + swap repeat drop r> @ execute ;] bind ; 
 : ndrefbind { count addr xt -- } addr closure-size + { data-addr } xt data-addr ! count data-addr cell+ ! 0 { index } begin index count < while index 1 lshift 2 + cells data-addr + 2! 1 +to index repeat data-addr addr [: >r r@ cell+ @ begin dup while 1- dup 1 lshift 2 + cells r@ + swap repeat drop r> @ execute ;] bind ; 
 : with-closure closure-size [: swap >r >r r@ swap bind r> r> execute ;] with-aligned-allot ; 
 : with-dclosure dclosure-size [: swap >r >r r@ swap dbind r> r> execute ;] with-aligned-allot ; 
 : with-nclosure 2 pick nclosure-size [: swap >r >r r@ swap nbind r> r> execute ;] with-aligned-allot ; 
 : with-ndclosure 2 pick ndclosure-size [: swap >r >r r@ swap ndbind r> r> execute ;] with-aligned-allot ; 
 : with-refclosure refclosure-size [: swap >r >r r@ swap refbind r> r> execute ;] with-aligned-allot ; 
 : with-drefclosure drefclosure-size [: swap >r >r r@ swap drefbind r> r> execute ;] with-aligned-allot ; 
 : with-nrefclosure 2 pick nrefclosure-size [: swap >r >r r@ swap nrefbind r> r> execute ;] with-aligned-allot ; 
 : with-ndrefclosure 2 pick ndrefclosure-size [: swap >r >r r@ swap ndrefbind r> r> execute ;] with-aligned-allot ; 
 : test0 1 ['] + [: 1 swap execute . ;] with-closure ; 
 : test1 2,0 ['] f* [: 3,0 rot execute f. ;] with-dclosure ; 
 : test2 1 2 3 3 [: + + + ;] [: 3 swap execute . ;] with-nclosure ; 
 : test3 3,0 2,0 2 [: { D: x D: y } y f* x d+ ;] [: 3,0 rot execute f. ;] with-ndclosure ; 
 : test4 1 [: @ + ;] [: 1 swap execute . ;] with-refclosure ; 
 : test5 2,0 [: 2@ f* ;] [: 3,0 rot execute f. ;] with-drefclosure ; 
 : test6 1 2 3 3 [: { x y z } x @ + y @ + z @ + ;] [: 3 swap execute . ;] with-nrefclosure ; 
 : test7 3,0 2,0 2 [: { x y } y 2@ f* x 2@ d+ ;] [: 3,0 rot execute f. ;] with-ndrefclosure ; 
 : x-end-of-input ." cr ; 
 : console-alarm-delay constant ; 
 : console-buffer-size constant ; 
 : flush-console-stream-output begin dup console-alarm-set? @ while pause repeat [: { data } data console-buffer data console-end @ data console-stream @ send-stream-parts 0 data console-end ! false data console-alarm-set? ! ;] over console-slock with-slock ; 
 : init-console-stream-input { stream data -- } data console-slock init-slock 0 data console-start ! 0 data console-end ! false data console-alarm-set? ! stream data console-stream ! data data console-io [: [: { data } data console-start @ data console-end @ = if data console-buffer console-buffer-size data console-stream @ recv-stream dup 0> averts x-end-of-input data console-end ! 0 data console-start ! then data console-buffer data console-start @ + c@ 1 data console-start +! ;] over console-slock with-slock ;] bind data data console-io? [: { data } data console-stream @ stream-empty? not data console-start @ data console-end @ <> or ;] bind ; 
 : init-console-stream-output { stream data -- } data console-slock init-slock 0 data console-start ! 0 data console-end ! false data console-alarm-set? ! stream data console-stream ! data data console-io [: [: { byte data } byte data console-buffer data console-end @ + c! 1 data console-end +! data console-end @ console-buffer-size < if data console-alarm-set? @ not if true data console-alarm-set? ! console-alarm-delay current-task task-priority@ data [: drop [: { data } data console-buffer data console-end @ data console-stream @ send-stream-parts 0 data console-end ! false data console-alarm-set? ! ;] over console-slock with-slock ;] data console-alarm set-alarm-delay-default then else data console-alarm-set? @ if data console-alarm unset-alarm then data console-buffer console-buffer-size data console-stream @ send-stream-parts 0 data console-end ! false data console-alarm-set? ! then ;] over console-slock with-slock ;] bind data data console-io? [: { data } data console-stream @ stream-full? not data console-end @ console-buffer-size <> or ;] bind data data console-io-flush ['] flush-console-stream-output bind ; 
 : with-input key-hook @ key?-hook @ { saved-input-hook saved-input?-hook } [: swap key?-hook ! swap key-hook ! execute ;] try saved-input?-hook key?-hook ! saved-input-hook key-hook ! ?raise ; 
 : with-output flush-console-hook @ { saved-flush-console-hook } emit-hook @ emit?-hook @ { saved-output-hook saved-output?-hook } [: swap flush-console-hook ! swap emit?-hook ! swap emit-hook ! execute ;] try saved-flush-console-hook flush-console-hook ! saved-output?-hook emit?-hook ! saved-output-hook emit-hook ! ?raise ; 
 : with-error-output error-flush-console-hook @ { saved-flush-console-hook } error-emit-hook @ error-emit?-hook @ { saved-output-hook saved-output?-hook } [: swap error-flush-console-hook ! swap error-emit?-hook ! swap error-emit-hook ! execute ;] try saved-flush-console-hook error-flush-console-hook ! saved-output?-hook error-emit?-hook ! saved-output-hook error-emit-hook ! ?raise ; 
 : with-null-input ['] false ['] false rot with-input ; 
 : with-null-output ['] drop ['] true rot [: ;] swap with-output ; 
 : with-null-error-output ['] drop ['] true rot [: ;] swap with-error-output ; 
 : with-serial-input ['] int-io::int-io-internal::do-key ['] int-io::int-io-internal::do-key? rot with-input ; 
 : with-serial-output ['] int-io::int-io-internal::do-emit ['] int-io::int-io-internal::do-emit? rot ['] int-io::int-io-internal::do-flush-console swap with-output ; 
 : with-serial-error-output ['] int-io::int-io-internal::do-emit ['] int-io::int-io-internal::do-emit? rot ['] int-io::int-io-internal::do-flush-console swap with-error-output ; 
 : with-stream-input console-stream-data-size [: { data } swap data init-console-stream-input data console-io data console-io? rot with-input ;] with-aligned-allot ; 
 : with-stream-output console-out-stream-data-size [: { data } swap data init-console-stream-output data console-io data console-io? rot data console-io-flush swap with-output data flush-console-stream-output ;] with-aligned-allot ; 
 : with-stream-error-output console-out-stream-data-size [: { data } swap data init-console-stream-output data console-io data console-io? rot data console-io-flush swap with-error-output data flush-console-stream-output ;] with-aligned-allot ; 
 : with-output-as-error-output emit-hook @ emit?-hook @ rot flush-console-hook @ swap with-error-output ; 
 : init-core-lock 0 over core-lock-index ! 0 swap core-lock-count ! ; 
 : claim-core-lock begin disable-int cpu-index 1+ over core-lock-index @ <> if cpu-index 1+ over core-lock-index test-set-raw dup not if enable-int pause then else 1 over core-lock-count +! enable-int true then until drop ; 
 : claim-core-lock-spin begin disable-int cpu-index 1+ over core-lock-index @ <> if cpu-index 1+ over core-lock-index test-set-raw enable-int else 1 over core-lock-count +! enable-int true then until drop ; 
 : claim-core-lock-timeout begin current-task compare-timeout if ['] x-timed-out ?raise else disable-int cpu-index 1+ over core-lock-index @ <> if cpu-index 1+ over core-lock-index test-set-raw dup not if enable-int pause then else 1 over core-lock-count +! enable-int true then then until drop ; 
 : release-core-lock disable-int -1 over core-lock-count +! dup core-lock-count @ 0< if 0 over core-lock-count ! 0 over core-lock-index ! then drop enable-int ; 
 : with-core-lock >r r@ claim-core-lock try r> release-core-lock ?raise ; 
 : with-core-lock-spin >r r@ claim-core-lock-spin try r> release-core-lock ?raise ; 
 : config-uart 1 4 uart-pin 1 5 uart-pin 921600 1 uart-baud! ; 
 : config-temp [ s" find ] [if] 480 temp-adc-chan default-adc adc-sampling-time! [then] [then] [then] ; 
 : type-uart 0 [: over + c@ 1 >uart ;] qcount drop ; 
 : cr-uart s\" \x0D\x0A" type-uart ; 
 : uart. 0 <# #s #> type-uart ; 
 : send-temp-over-uart [: temp-adc-chan default-adc adc@ uart. cr-uart 1000 ms 1 uart>? ;] quntil 1 uart> drop ; 
 : init-test config-uart config-temp 0 ['] send-temp-over-uart 320 128 512 spawn run ; 
 : test-0-task variable ; 
 : test-1-task variable ; 
 : test 0 begin [: cr ." dup . ;] critical 1+ again ; 
 : init-test 0 1 ['] test 420 128 512 spawn test-0-task ! 1 1 ['] test 420 128 512 spawn test-1-task ! test-0-task @ run test-1-task @ run ; 
 : cstr-map-hash @ dup >r c@ dup begin ?dup while r> 1+ >r swap dup 7 lshift swap 25 rshift or r@ c@ xor swap 1- repeat rdrop ; 
 : cstr-map-equals @ count rot @ count equal-strings? ; 
 : cstr-map-size cell swap map-size ; 
 : init-cstr-map 2>r 2>r ['] cstr-map-hash ['] cstr-map-equals 2r> cell 2r> init-map ; 
 : find-cstr-map cell [: rot over ! swap find-map ;] with-aligned-allot ; 
 : insert-cstr-map cell [: rot over ! swap insert-map ;] with-aligned-allot ; 
 : remove-cstr-map cell [: rot over ! swap remove-map ;] with-aligned-allot ; 
 : at-cstr-map at-map @ ; 
 : entry-count constant ; 
 : find-cstr-map find-cstr-map ?dup if @ else -1 then ; 
 : insert-cstr-map rot cell [: tuck ! -rot insert-cstr-map ;] with-aligned-allot ; 
 : handle-remove cr ." @ count type @ . ; 
 : init-test ['] handle-remove entry-count cell my-map init-cstr-map 10 c" . ; 
 : task1 variable ; 
 : task2 variable ; 
 : run-task systick-divisor * systick-counter begin over + 2dup current-task delay 2 pick emit again ; 
 : init-test [char] * 250 2 ['] run-task 420 128 512 spawn task1 ! [char] x 1000 2 ['] run-task 420 128 512 spawn task2 ! task1 @ run task2 @ run ; 
 : for-gas variable ; 
 : local-count constant ; 
 : local-index variable ; 
 : prev-underscore variable ; 
 : lookup-local local-index @ 0 ?do i cells local-buffer + @ over = if rop i 1 + unloop exit then loop drop 0 ; 
 : (cond.) case %0000 of ." endof endcase ; 
 : null-cond? 0< ; 
 : (dec.) base @ >r decimal (.) r> base ! ; 
 : (udec.) base @ >r decimal (u.) r> base ! ; 
 : reg. case 15 of ." (udec.) endcase ; 
 : val. for-gas @ if ." then base @ >r hex (u.) r> base ! ; 
 : size. case 0 of endof SB of ." endof dup emit endcase ; 
 : data. { current end -- } begin current end u< while cr current h.8 space current 16 + end min current ?do i c@ h.2 space loop current 16 + end u> if current 16 + end ?do ." 16 +to current repeat ; 
 : w-size <builds , , does> 2@ execute ; 
 : lead-underscore swap 0<> prev-underscore @ not and if ." 1+ then ; 
 : tail-underscore -rot 1 + <> if ." 1+ true prev-underscore ! then ; 
 : convert-type-char-case case [char] ` of dup 6 lead-underscore ." tail-underscore endof dup emit nip nip 1 swap false prev-underscore ! endcase ; 
 : convert-type-char 2 pick [char] - = 2 pick 1 = and over 0 = and if ." 2drop drop else rot convert-type-char-case then ; 
 : label-type false prev-underscore ! for-gas @ if dup 0 0 -rot ?do 2 pick i + c@ 2 pick i convert-type-char + loop nip nip else tuck type then ; 
 : not-in-reglist. 0 ?do over i rshift 1 and if dup i = if unloop exit then then loop 2drop ." ; 
 : reglist. ." ; 
 : addr. dup find-by-xt ?dup if rot drop word-name count label-type drop for-gas @ if drop else space ." then drop then then ; 
 : label. dup find-by-xt ?dup if nip word-name count for-gas @ if abel-type ." 21 swap - 0 ?do space loop hen else 2 0 ?do space loop then then ; 
 : sep. ." ; 
 : sep-imm. ." ; 
 : instr16. for-gas @ if drop else h.4 ." then ; 
 : instr32. for-gas @ if 2drop else swap h.4 space h.4 ." then ; 
 : extend 32 swap - tuck lshift swap arshift ; 
 : match16 2 + true ; 
 : match32 4 + true ; 
 : not-match16 2drop false ; 
 : not-match32 drop 2drop false ; 
 : rotate7-in-12 dup %1111111 and %10000000 or swap 7 rshift %11111 and 2dup rshift -rot 32 swap - lshift or ; 
 : decode-const12 %111111111111 and dup 10 rshift 0 = if dup 8 rshift case 00 of (u.) endof 01 of dup %11111111 and 0 = if ." drop else dup 24 lshift over 16 lshift or over 8 lshift or or val. then ndof endcase else rotate7-in-12 val. then ; 
 : decode-imm-shift swap case %00 of dup if ." hen endof endcase ; 
 : bitfield -rot rshift swap $FFFFFFFF 32 rot - rshift and ; 
 : cond. dup null-cond? not if (cond.) else drop then ; 
 : conds. dup null-cond? not if (cond.) else drop ." then ; 
 : s?. 1 bitfield if ." then ; 
 : 4s?. 4 1 bitfield if ." then ; 
 : rel. rot dup >r 4 + -rot extend + r> swap addr. ; 
 : rel4. rot dup >r 4 + 4 align -rot extend + r> swap addr. ; 
 : nrel. swap dup >r 4 + swap + r> swap addr. ; 
 : nrel4. swap dup >r 2 + 4 align swap + r> swap addr. ; 
 : .w ." ; 
 : nconst4. swap 2 + 4 align swap + @ space ." h.8 ; 
 : reg-sep. reg. sep. ; 
 : reg-sep-imm. reg. sep-imm. ; 
 : csp. swap cond. space ; 
 : cssp. swap conds. space ; 
 : c.w rot cond. .w ; 
 : c.sp rot cond. space ; 
 : 4sc.w over 4s?. rot cond. .w ; 
 : 4sc.sp over 4s?. rot cond. space ; 
 : 0_3_bf 0 3 bitfield ; 
 : 3_3_bf 3 3 bitfield ; 
 : 3_4_bf 3 4 bitfield ; 
 : 8_3_bf 8 3 bitfield ; 
 : 8_4_bf 8 4 bitfield ; 
 : 0_4_bf 0 4 bitfield ; 
 : 0_8_bf 0 8 bitfield ; 
 : 12_4_bf 12 4 bitfield ; 
 : 10_1_bf 10 1 bitfield ; 
 : 4_2_bf 4 2 bitfield ; 
 : 6_2_bf 6 2 bitfield ; 
 : 12_3_bf 12 3 bitfield ; 
 : 6_3_bf 6 3 bitfield ; 
 : 0_12_bf 0 12 bitfield ; 
 : size-bitshift case 0 of 2 lshift endof [char] H of 1 lshift endof [char] B of endof endcase ; 
 : decode-and-reg-16 dup 0_3_bf reg-sep. 3_3_bf reg. ; 
 : decode-and-reg-32 dup 8_4_bf reg-sep. swap 0_4_bf reg-sep. dup 0_4_bf reg. dup 4_2_bf over 6_2_bf rot 12_3_bf 2 lshift or decode-imm-shift ; 
 : decode-asr-imm-16 dup 0_3_bf reg-sep. dup 3_3_bf reg-sep-imm. 6 5 bitfield val. ; 
 : decode-asr-imm-32 dup 8_4_bf reg-sep. dup 0_4_bf reg-sep-imm. dup 6_2_bf swap 12_3_bf 2 lshift or (udec.) ; 
 : decode-asr-reg-32 dup 8_4_bf reg-sep. swap 0_4_bf reg-sep. 0_4_bf reg. ; 
 : decode-cmn-imm-32 over 0_4_bf reg-sep-imm. dup 0_8_bf swap 12_3_bf 8 lshift or swap 10_1_bf 11 lshift or decode-const12 ; 
 : decode-cmn-reg-32 swap 0_4_bf reg-sep. dup 0_4_bf reg. dup 4_2_bf over 6_2_bf rot 12_3_bf 2 lshift or and decode-imm-shift ; 
 : decode-add-imm-1 dup 0_3_bf reg-sep. dup 3_3_bf reg-sep-imm. 6_3_bf val. ; 
 : decode-add-imm-2 dup 8_3_bf reg-sep-imm. 0_8_bf val. ; 
 : decode-add-imm-3 dup 8_4_bf reg-sep. over 0_4_bf reg-sep-imm. dup 0_8_bf swap 12_3_bf 8 lshift or swap 10_1_bf 11 lshift or decode-const12 ; 
 : decode-add-imm-4 dup 8_4_bf reg-sep. over 0_4_bf reg-sep-imm. dup 0_8_bf swap 12_4_bf 8 lshift or swap 10_1_bf 11 lshift or val. ; 
 : decode-add-reg-16 dup 0_3_bf reg-sep. dup 3_3_bf reg-sep. 6_3_bf reg. ; 
 : decode-add-reg-32 dup 8_4_bf reg-sep. decode-cmn-reg-32 ; 
 : decode-mov-imm-32 dup 8_4_bf reg-sep-imm. dup 0_8_bf swap 12_3_bf 8 lshift or over 10_1_bf 11 lshift or swap 0_4_bf 12 lshift or val. ; 
 : decode-cbz nip space dup 0_3_bf reg-sep. dup 3 5 bitfield swap 9 1 bitfield 5 lshift or 1 lshift nrel. ; 
 : decode-smull dup 12_4_bf reg-sep. dup 8_4_bf reg-sep. swap 0_4_bf reg-sep. 0_4_bf reg. ; 
 : decode-ldr-imm-1 >r dup 0_3_bf reg-sep. ." ; 
 : decode-ldr-imm-2 dup 8_3_bf reg-sep. ." ; 
 : decode-ldr-imm-3 dup 12_4_bf reg-sep. ." ; 
 : decode-ldr-imm-4 dup 12_4_bf reg-sep. ." sep-imm. dup 0_8_bf swap 9 1 bitfield 0= if negate then (dec.) then ; 
 : decode-ldr-reg-1 dup 0_3_bf reg. ." ; 
 : decode-ldr-reg-2 dup 12_3_bf reg. ." ; 
 : p-adc-imm ." 4sc.sp decode-add-imm-3 drop ; 
 : p-adc-reg-1 ." cssp. decode-and-reg-16 drop ; 
 : p-adc-reg-2 ." 4sc.w decode-add-reg-32 drop ; 
 : p-add-imm-1 ." cssp. decode-add-imm-1 drop ; 
 : p-add-imm-2 ." cssp. decode-add-imm-2 drop ; 
 : p-add-imm-3 ." 4sc.w decode-add-imm-3 drop ; 
 : p-add-imm-4 ." c.sp decode-add-imm-4 drop ; 
 : p-add-reg-1 ." cssp. decode-add-reg-16 drop ; 
 : p-add-reg-2 ." csp. dup 0_3_bf over 7 1 bitfield 3 lshift or reg-sep. 3_4_bf reg. drop ; 
 : p-add-reg-3 ." 4sc.w decode-add-reg-32 drop ; 
 : p-add-sp-imm-1 ." 0_8_bf 2 lshift val. drop ; 
 : p-add-sp-imm-2 ." 0 7 bitfield 2 lshift val. drop ; 
 : p-add-sp-reg-2 ." 2 4 bitfield reg. drop ; 
 : p-adr-1 ." 0_8_bf 2 lshift val. drop ; 
 : p-adr-2 ." dup 0_8_bf swap 12_3_bf 8 lshift or swap 10_1_bf 12 lshift or val. drop ; 
 : p-adr-3 ." dup 0_8_bf swap 12_3_bf 8 lshift or swap 10_1_bf 12 lshift or val. drop ; 
 : p-and-imm ." 4sc.sp dup 8_4_bf reg-sep. over 0_4_bf reg-sep-imm. dup 0_8_bf swap 12_3_bf 8 lshift or swap 10_1_bf 12 lshift or decode-const12 drop ; 
 : p-and-reg-1 ." cssp. decode-and-reg-16 drop ; 
 : p-and-reg-2 ." 4sc.w decode-and-reg-32 drop ; 
 : p-asr-imm-1 ." cssp. decode-asr-imm-16 drop ; 
 : p-asr-imm-2 ." swap 4s?. swap cond. .w decode-asr-imm-32 drop ; 
 : p-asr-reg-1 ." cssp. decode-and-reg-16 drop ; 
 : p-asr-reg-2 ." 4sc.w decode-asr-reg-32 drop ; 
 : p-svc ." val. drop ; 
 : p-sxtb-reg-1 ." csp. decode-and-reg-16 drop ; 
 : p-sxth-reg-1 ." csp. decode-and-reg-16 drop ; 
 : p-uxtb-reg-1 ." csp. decode-and-reg-16 drop ; 
 : p-uxth-reg-1 ." csp. decode-and-reg-16 drop ; 
 : p-rev-reg-1 ." csp. decode-and-reg-16 drop ; 
 : p-rev16-reg-1 ." csp. decode-and-reg-16 drop ; 
 : p-revsh-reg-1 ." csp. decode-and-reg-16 drop ; 
 : p-ror-reg-1 ." cssp. decode-and-reg-16 drop ; 
 : p-b-1 dup 8_4_bf $F = if p-svc else ." nip dup 8_4_bf cond. space 0_8_bf 1 lshift 9 rel. then ; 
 : p-b-2 ." csp. 0 11 bitfield 1 lshift 12 rel. ; 
 : p-b-3 ." rot drop over 6 4 bitfield cond. .w dup 0 11 bitfield 2 pick 0 6 bitfield 11 lshift or over 13 1 bitfield 17 lshift or swap 11 1 bitfield 18 lshift or swap 10_1_bf 19 lshift or 1 lshift 21 rel. ; 
 : p-b-4 ." c.w dup 0 11 bitfield 2 pick 0 10 bitfield 11 lshift or over 11 1 bitfield 3 pick 10_1_bf xor not 1 and 21 lshift or swap 13 1 bitfield 2 pick 10_1_bf xor not 1 and 22 lshift or swap 10_1_bf 23 lshift or 1 lshift 25 rel. ; 
 : p-bfc ." c.sp nip 8_4_bf reg-sep-imm. dup 6_2_bf over 12_3_bf 2 lshift or dup val. sep-imm. over 0 5 bitfield 1+ swap - val. drop ; 
 : p-bfi ." c.sp dup 8_4_bf reg-sep. swap 0_4_bf reg-sep-imm. dup 6_2_bf over 12_3_bf 2 lshift or dup val. sep-imm. over 0 5 bitfield 1+ swap - val. drop ; 
 : p-bic-imm ." over 4s?. space decode-add-imm-3 drop ; 
 : p-bic-reg-1 ." cssp. decode-and-reg-16 drop ; 
 : p-bic-reg-2 ." 4sc.w decode-add-reg-32 drop ; 
 : p-bkpt ." val. drop ; 
 : p-bl-imm ." c.sp dup 0 11 bitfield 2 pick 0 10 bitfield 11 lshift or over 11 1 bitfield 3 pick 10 1 bitfield xor not 1 and 21 lshift or swap 13 1 bitfield 2 pick 10 1 bitfield xor not 1 and 22 lshift or swap 10 1 bitfield 23 lshift or 1 lshift 25 rel. ; 
 : p-blx-reg ." csp. 3_4_bf reg. drop ; 
 : p-bx ." csp. 3_4_bf reg. drop ; 
 : p-cbnz ." decode-cbz ; 
 : p-cbz ." decode-cbz ; 
 : p-cmn-imm ." csp. decode-cmn-imm-32 drop ; 
 : p-cmn-reg-1 ." csp. decode-and-reg-16 drop ; 
 : p-cmn-reg-2 ." swap cond. .w decode-cmn-reg-32 ; 
 : p-cmp-imm-1 ." nip decode-add-imm-2 drop ; 
 : p-cmp-imm-2 ." c.w decode-cmn-imm-32 drop ; 
 : p-cmp-reg-1 ." csp. decode-and-reg-16 drop ; 
 : p-cmp-reg-2 ." csp. dup 0_3_bf over 7 1 bitfield 3 lshift or reg-sep. 3_4_bf reg. drop ; 
 : p-cmp-reg-3 ." c.w decode-cmn-reg-32 drop ; 
 : p-cps-1 ." nip dup 4 1 bitfield if [char] D else [char] E then emit space dup 2 1 bitfield if [char] A emit then dup 1 1 bitfield if [char] I emit then 0 1 bitfield if [char] F emit then drop ; 
 : p-dmb ." 2drop 2drop ; 
 : p-dsb ." endof endcase drop ; 
 : p-isb ." 2drop 2drop ; 
 : p-eor-imm ." rot drop over 4s?. decode-add-imm-3 drop ; 
 : p-eor-reg-1 ." cssp. decode-and-reg-16 drop ; 
 : p-eor-reg-2 ." 4sc.w decode-add-reg-32 drop ; 
 : p-ldmia-1 ." csp. dup 8_3_bf dup reg. swap 0_8_bf dup rot 8 not-in-reglist. sep. 8 reglist. drop ; 
 : p-ldr-imm-1 ." dup >r size. csp. r> decode-ldr-imm-1 drop ; 
 : p-ldr-imm-2 ." size. csp. decode-ldr-imm-2 drop ; 
 : p-ldr-imm-3 ." size. c.w decode-ldr-imm-3 drop ; 
 : p-ldr-imm-4 ." size. c.sp decode-ldr-imm-4 drop ; 
 : p-ldr-lit-1 ." drop else 2dup nrel4. nconst4. then ; 
 : p-ldr-lit-2 ." drop else 2dup nrel4. nconst4. then ; 
 : p-ldr-reg-1 ." size. csp. decode-ldr-reg-1 drop ; 
 : p-ldr-reg-2 ." size. c.w decode-ldr-reg-2 drop ; 
 : p-lsl-imm-1 ." cssp. decode-asr-imm-16 drop ; 
 : p-lsl-imm-2 ." 4sc.w decode-asr-imm-32 drop ; 
 : p-lsl-reg-1 ." cssp. decode-and-reg-16 drop ; 
 : p-lsl-reg-2 ." 4sc.w decode-asr-reg-32 drop ; 
 : p-lsr-imm-1 ." cssp. decode-asr-imm-16 drop ; 
 : p-lsr-imm-2 ." 4sc.w decode-asr-imm-32 drop ; 
 : p-lsr-reg-1 ." cssp. decode-and-reg-16 drop ; 
 : p-lsr-reg-2 ." 4sc.w decode-asr-reg-32 drop ; 
 : p-mls ." rot drop space dup 8_4_bf reg-sep. swap 0_4_bf reg-sep. dup 0_4_bf reg-sep. 12_4_bf reg. drop ; 
 : p-mov-imm-1 ." cssp. decode-add-imm-2 drop ; 
 : p-mov-imm-2 ." 4sc.w dup 8_4_bf reg-sep-imm. dup 0_8_bf swap 12_3_bf 8 lshift or swap 10_1_bf 11 lshift or decode-const12 drop ; 
 : p-mov-imm-3 ." c.sp decode-mov-imm-32 drop ; 
 : p-mov-reg-1 ." csp. dup 0_3_bf over 7 1 bitfield 3 lshift or reg-sep. 3_4_bf reg. drop ; 
 : p-mov-reg-2 ." space nip decode-and-reg-16 drop ; 
 : p-mov-reg-3 ." 4sc.w nip dup 8_4_bf reg-sep. 0_4_bf reg. drop ; 
 : p-movt ." c.sp decode-mov-imm-32 drop ; 
 : p-mul-1 ." cssp. decode-and-reg-16 drop ; 
 : p-mul-2 ." over 4s?. space decode-asr-reg-32 drop ; 
 : p-mvn-reg-1 ." cssp. decode-and-reg-16 drop ; 
 : p-nop-1 ." drop cond. drop ; 
 : p-orr-imm ." 4sc.sp decode-add-imm-3 drop ; 
 : p-orr-reg-1 ." cssp. decode-and-reg-16 drop ; 
 : p-orr-reg-2 ." 4sc.w decode-and-reg-32 drop ; 
 : p-pop-1 ." csp. dup 0_8_bf swap 8 1 bitfield 15 lshift or 16 reglist. drop ; 
 : p-pop-2 ." c.w nip dup 0_12_bf swap 14 2 bitfield 14 lshift or 16 reglist. drop ; 
 : p-push-1 ." csp. dup 0_8_bf swap 8 1 bitfield 14 lshift or 16 reglist. drop ; 
 : p-push-2 ." c.w nip dup 0_12_bf swap 14 1 bitfield 14 lshift or 16 reglist. drop ; 
 : p-rsb-imm-1 ." drop ; 
 : p-sbc-imm ." 4sc.sp decode-add-imm-3 drop ; 
 : p-sbc-reg-1 ." cssp. decode-and-reg-16 drop ; 
 : p-sbc-reg-2 ." 4sc.w decode-and-reg-32 drop ; 
 : p-sdiv ." c.sp decode-asr-reg-32 drop ; 
 : p-smull ." c.sp decode-smull drop ; 
 : p-sev-1 ." swap cond. 2drop ; 
 : p-str-imm-1 ." dup >r size. csp. r> decode-ldr-imm-1 drop ; 
 : p-str-imm-2 ." size. csp. decode-ldr-imm-2 drop ; 
 : p-str-imm-3 ." size. c.w decode-ldr-imm-3 drop ; 
 : p-str-imm-4 ." size. c.sp decode-ldr-imm-4 drop ; 
 : p-str-reg-1 ." size. csp. decode-ldr-reg-1 drop ; 
 : p-str-reg-2 ." size. c.w decode-ldr-reg-2 drop ; 
 : p-sub-imm-1 ." cssp. decode-add-imm-1 drop ; 
 : p-sub-imm-2 ." cssp. decode-add-imm-2 drop ; 
 : p-sub-imm-3 ." 4sc.w decode-add-imm-3 drop ; 
 : p-sub-imm-4 ." c.sp decode-add-imm-4 drop ; 
 : p-sub-reg-1 ." cssp. decode-add-reg-16 drop ; 
 : p-sub-reg-2 ." 4sc.w decode-add-reg-32 drop ; 
 : p-tst-imm ." csp. decode-cmn-imm-32 drop ; 
 : p-tst-reg-1 ." csp. decode-and-reg-16 drop ; 
 : p-tst-reg-2 ." c.w decode-cmn-reg-32 drop ; 
 : p-udiv ." c.sp decode-asr-reg-32 drop ; 
 : p-umull ." c.sp decode-smull drop ; 
 : p-wfe-1 ." swap cond. 2drop ; 
 : p-wfi-1 ." swap cond. 2drop ; 
 : p-yield-1 ." swap cond. 2drop ; 
 : p-start-string ." 2drop 2 + dup c@ 1+ over + 2 align data. ; 
 : highest constant ; 
 : current-cond -1 ; 
 : disassemble16 over h@ over cell+ h@ and over 6 + h@ = if current-cond 2 pick h@ instr16. 2 pick label. 2 pick h@ rot @ execute true else 2drop false then ; 
 : disassemble32 over h@ over cell+ h@ and over 8 + h@ = if over 2 + h@ over 6 + h@ and over 10 + h@ = if urrent-cond 2 pick h@ 3 pick 2 + h@ instr32. pick label. 2 pick h@ 3 pick 2 + h@ 3 roll @ execute true else drop false then else 2drop false then ; 
 : add-local local-index @ local-count < if local-index @ 0 ?do cells local-buffer + @ over = if drop unloop exit hen loop local-index @ cells local-buffer + ! 1 local-index +! else drop then ; 
 : parse-local16 dup start-string <> if dup %1111000000000000 and %1101000000000000 = if 0_8_bf 1 lshift swap 4 + swap 9 extend + add-local else dup %1111100000000000 and %1110000000000000 = if 0 11 bitfield 1 lshift swap 4 + swap 12 extend + add-local else 2drop then then else 2drop then ; 
 : parse-local32 over %1111100000000000 and %1111000000000000 = if dup %1101000000000000 and %1000000000000000 = if up 0 11 bitfield 2 pick 0 6 bitfield 11 lshift or ver 13 1 bitfield 17 lshift or swap 11 1 bitfield 18 lshift or wap 10_1_bf 19 lshift or 1 lshift swap 4 + swap 21 extend + add-local else up %1101000000000000 and %1001000000000000 = if dup 0 11 bitfield 2 pick 0 10 bitfield 11 lshift or over 11 1 bitfield 3 pick 10_1_bf xor not 1 and 21 lshift or swap 13 1 bitfield 2 pick 10_1_bf xor not 1 and 22 lshift or swap 10_1_bf 23 lshift or 1 lshift swap 4 + swap 25 extend + add-local lse 2drop drop hen then else 2drop drop then ; 
 : find-local16 over h@ over cell+ h@ and over 6 + h@ = if drop dup h@ parse-local16 true else 2drop false then ; 
 : find-local32 over h@ over cell+ h@ and over 8 + h@ = if over 2 + h@ over 6 + h@ and over 10 + h@ = if rop dup h@ over 2 + h@ parse-local32 true else drop false then else 2drop false then ; 
 : find-local all-ops16 begin dup @ 0<> if dup find-local16 if drop dup h@ start-string <> if 2 + true true else 2 + dup c@ 1+ + 2 align true true then lse [ 2 cells ] literal + false hen else rop false true then until not if all-ops32 begin up @ 0<> if 2dup find-local32 if drop 4 + true true else [ 3 cells ] literal + false then lse drop false true hen until not if + then then ; 
 : disassemble-main for-gas @ not if dup h.8 space then all-ops16 begin dup @ 0<> if dup disassemble16 if drop dup h@ start-string <> if 2 + true true else 2 + dup c@ 1+ + 2 align true true then lse [ 2 cells ] literal + false hen else rop false true then until not if all-ops32 begin up @ 0<> if 2dup disassemble32 if drop 4 + true true else [ 3 cells ] literal + false then lse drop false true hen until not if up h@ instr16. ." 2 + then then cr ; 
 : see-end? dup h@ $003F <> if drop false else 2 - h@ dup $FF00 and $BD00 = if rop true else FF80 and $4700 = then then ; 
 : x-out-of-range-dma-channel cr ." ; 
 : x-out-of-range-treq cr ." ; 
 : x-out-of-range-timer cr ." ; 
 : x-invalid-transfer-size cr ." ; 
 : x-out-of-range-timer-value cr ." ; 
 : dma-count constant ; 
 : treq-count constant ; 
 : timer-count constant ; 
 : DMA_BASE constant ; 
 : CH_READ_ADDR 6 lshift [ DMA_BASE $00 + ] literal + ; 
 : CH_WRITE_ADDR 6 lshift [ DMA_BASE $04 + ] literal + ; 
 : CH_TRANS_COUNT 6 lshift [ DMA_BASE $08 + ] literal + ; 
 : CH_CTRL_TRIG 6 lshift [ DMA_BASE $0C + ] literal + ; 
 : DMA_TIMER 2 lshift [ DMA_BASE $420 + ] literal + ; 
 : CH_CTRL_TRIG_TREQ_SEL_LSB constant ; 
 : CH_CTRL_TRIG_DATA_SIZE_LSB constant ; 
 : validate-dma dma-count u< averts x-out-of-range-dma-channel ; 
 : validate-treq treq-count u< averts x-out-of-range-treq ; 
 : validate-timer timer u< averts x-out-of-range-timer ; 
 : bits-of-transfer-size case 1 of CH_CTRL_TRIG_SIZE_BYTE endof 2 of CH_CTRL_TRIG_SIZE_HALFWORD endof 4 of CH_CTRL_TRIG_SIZE_WORD endof ['] x-invalid-transfer-size ?raise endcase ; 
 : DREQ_PIO_TX 3 lshift + ; 
 : DREQ_PIO_RX 3 lshift + 4 + ; 
 : DREQ_SPI_TX 1 lshift 16 + ; 
 : DREQ_SPI_RX 1 lshift 17 + ; 
 : DREQ_UART_TX 1 lshift 20 + ; 
 : DREQ_UART_RX 1 lshift 21 + ; 
 : DREQ_PWM_WRAP 24 + ; 
 : DREQ_I2C_TX 1 lshift 32 + ; 
 : DREQ_I2C_RX 1 lshift 33 + ; 
 : DREQ_ADC 36 ; 
 : DREQ_XIP_STREAM 37 ; 
 : DREQ_XIP_SSITX 38 ; 
 : DREQ_XIP_SSIRX 39 ; 
 : TREQ_TIMER $3B + ; 
 : TREQ_UNPACED $3F ; 
 : start-register>register-dma { src dest count size treq channel -- } channel validate-dma treq validate-treq size bits-of-transfer-size { size-bits } src channel CH_READ_ADDR ! dest channel CH_WRITE_ADDR ! count channel CH_TRANS_COUNT ! size-bits treq CH_CTRL_TRIG_TREQ_SEL_LSB lshift or CH_CTRL_TRIG_EN or channel CH_CTRL_TRIG ! ; 
 : start-register>buffer-dma { src dest count size treq channel -- } channel validate-dma treq validate-treq size bits-of-transfer-size { size-bits } src channel CH_READ_ADDR ! dest channel CH_WRITE_ADDR ! count channel CH_TRANS_COUNT ! size-bits treq CH_CTRL_TRIG_TREQ_SEL_LSB lshift or [ CH_CTRL_TRIG_INCR_WRITE CH_CTRL_TRIG_EN or ] literal or channel CH_CTRL_TRIG ! ; 
 : start-buffer>register-dma { src dest count size treq channel -- } channel validate-dma treq validate-treq size bits-of-transfer-size { size-bits } src channel CH_READ_ADDR ! dest channel CH_WRITE_ADDR ! count channel CH_TRANS_COUNT ! size-bits treq CH_CTRL_TRIG_TREQ_SEL_LSB lshift or [ CH_CTRL_TRIG_INCR_READ CH_CTRL_TRIG_EN or ] literal or channel CH_CTRL_TRIG ! ; 
 : start-buffer>buffer-dma { src dest count size treq channel -- } channel validate-dma treq validate-treq size bits-of-transfer-size { size-bits } src channel CH_READ_ADDR ! dest channel CH_WRITE_ADDR ! count channel CH_TRANS_COUNT ! size-bits treq CH_CTRL_TRIG_TREQ_SEL_LSB lshift [ CH_CTRL_TRIG_INCR_WRITE CH_CTRL_TRIG_INCR_READ or CH_CTRL_TRIG_EN or ] literal or channel CH_CTRL_TRIG ! ; 
 : dma-timer! { dividend divisor timer -- } timer validate-timer dividend 65536 u< averts x-out-of-range-timer-value divisor 65536 u< averts x-out-of-range-timer-value dividend 16 lshift divisor or timer DMA_TIMER ! ; 
 : spin-wait-dma { channel -- } begin CH_CTRL_TRIG_BUSY channel CH_CTRL_TRIG bit@ while repeat ; 
 : wait-dma { channel -- } begin CH_CTRL_TRIG_BUSY channel CH_CTRL_TRIG bit@ while pause repeat ; 
 : x-no-dma-channels-available cr ." ; 
 : x-dma-channel-already-free cr ." ; 
 : dma-pool-bits variable ; 
 : allocate-dma [: dma-internal::dma-count 0 ?do i bit dma-pool-bits bit@ not if i bit dma-pool-bits bis! i unloop exit then loop ['] x-no-dma-channels-available ?raise ;] dma-pool-slock with-slock ; 
 : free-dma dup dma-internal::validate-dma [: dup bit dma-pool-bits bit@ averts x-dma-channel-already-free bit dma-pool-bits bic! ;] dma-pool-slock with-slock ; 
 : init-dma-pool dma-pool-slock init-slock 0 dma-pool-bits ! ; 
 : buffer-count constant ; 
 : buffer-width constant ; 
 : tab-size constant ; 
 : edit-state variable ; 
 : tab constant ; 
 : delete constant ; 
 : newline constant ; 
 : return constant ; 
 : ctrl-a constant ; 
 : ctrl-b constant ; 
 : ctrl-e constant ; 
 : ctrl-f constant ; 
 : ctrl-k constant ; 
 : ctrl-n constant ; 
 : ctrl-p constant ; 
 : ctrl-u constant ; 
 : ctrl-v constant ; 
 : ctrl-w constant ; 
 : ctrl-x constant ; 
 : get-buffer block-size * edit-state @ edit-buffers + ; 
 : get-row buffer-width * edit-state @ edit-current @ get-buffer + ; 
 : current-row-index@ edit-state @ edit-cursor-row @ edit-state @ edit-start-row @ - ; 
 : current-column-index@ edit-state @ edit-cursor-column @ edit-state @ edit-start-column @ - ; 
 : current-row-index! edit-state @ edit-start-row @ + edit-state @ edit-cursor-row ! ; 
 : current-column-index! edit-state @ edit-start-column @ + edit-state @ edit-cursor-column ! ; 
 : current-row current-row-index@ get-row ; 
 : dirty? bit edit-state @ edit-dirty bit@ ; 
 : dirty! bit swap if edit-state @ edit-dirty bis! else edit-state @ edit-dirty bic! then ; 
 : id! cells edit-state @ edit-ids + ! ; 
 : id@ cells edit-state @ edit-ids + @ ; 
 : current-id edit-state @ edit-current @ id@ ; 
 : x-buffer-not-found ." cr ; 
 : buffer-of-id buffer-count 0 ?do i id@ over = if drop i unloop exit then loop drop -1 ; 
 : current-by-id! buffer-of-id dup -1 <> if edit-state @ edit-current ! else drop then ; 
 : row-len get-row 0 buffer-width 0 ?do over i + c@ dup $20 > swap $7F <> and if rop i 1+ then loop nip ; 
 : unicode-start? $C0 and $C0 = ; 
 : unicode? $80 and 0<> ; 
 : draw-empty cr [char] + emit buffer-width 3 + 0 ?do [char] - emit loop [char] + emit buffer-height 0 ?do cr [char] | emit buffer-width 3 + 0 ?do space loop [char] | emit loop cr [char] + emit buffer-width 3 + 0 ?do [char] - emit loop [char] + emit ; 
 : draw-row [: dup edit-state @ edit-start-row @ + edit-state @ edit-start-column @ go-to-coord dup 9 < if space then dup 1+ . 0 swap get-row dup buffer-width + swap ?do c@ dup $20 >= over $7F <> and over unicode? not and if emit 1+ lse dup unicode? if dup emit unicode-start? if 1+ then else drop leave then hen loop buffer-width swap - 0 ?do space loop ;] execute-hide-cursor ; 
 : draw-all-rows [: buffer-height 0 ?do i draw-row loop ;] execute-hide-cursor ; 
 : draw-header [: edit-state @ edit-start-row @ 1- edit-state @ edit-start-column @ 1- go-to-coord ." buffer-width r> 2 + - 0 ?do [char] - emit loop ;] execute-hide-cursor ; 
 : update-row [: draw-row ;] execute-preserve-cursor ; 
 : update-all-rows [: draw-all-rows ;] execute-preserve-cursor ; 
 : update-all [: draw-all-rows draw-header ;] execute-preserve-cursor ; 
 : update-header [: draw-header ;] execute-preserve-cursor ; 
 : update-current-row current-row-index@ update-row ; 
 : init-buffer get-buffer block-size $20 fill ; 
 : lowest-id -1 buffer-count 0 ?do dup i id@ u> if drop i id@ then loop ; 
 : highest-id 0 buffer-count 0 ?do dup i id@ u< if drop i id@ then loop ; 
 : load-buffer false over dirty! 2dup id! over block? if swap find-block swap get-buffer block-size move else nip init-buffer then ; 
 : blocks-first dup half-buffer-count u< if drop 0 else dup -1 half-buffer-count - u>= if rop -1 buffer-count - else alf-buffer-count - then then ; 
 : load-all-buffers dup blocks-first buffer-count 0 ?do dup i load-buffer 1+ loop drop current-by-id! ; 
 : save-buffer dup buffer-of-id dirty? if false over buffer-of-id dirty! dup buffer-of-id get-buffer swap block! else drop then ; 
 : save-all-buffers buffer-count 0 ?do i cells edit-state @ edit-ids + @ save-buffer loop ; 
 : change-buffer dup highest-id u> if lowest-id save-buffer dup lowest-id buffer-of-id load-buffer else dup lowest-id u< if ighest-id save-buffer up highest-id buffer-of-id load-buffer else then then current-by-id! update-all ; 
 : current-column-bytes 0 current-column-index@ begin dup 0> while over buffer-width < if wap 1+ swap over current-row + c@ up $20 >= over $80 < and if drop 1- lse dup unicode? swap unicode-start? and if 1- begin over buffer-width < if ver current-row + c@ up unicode? swap unicode-start? not and if swap 1+ swap false lse true hen else rue then until then hen else rop 0 then repeat drop ; 
 : max-columns current-row-index@ row-len ; 
 : left-bytes 0 current-column-bytes begin dup 0> if wap 1+ swap 1- dup current-row + c@ up unicode-start? if drop true lse unicode? not hen else rue then until drop ; 
 : right-bytes current-column-bytes buffer-width < if current-row current-column-bytes + c@ dup $80 u< if rop 1 else current-column-bytes 1+ begin dup buffer-width u< if dup current-row + c@ dup unicode-start? if drop drop true else unicode? if + swap 1+ swap false else rop true then then else drop true then ntil then else 0 then ; 
 : save-current-column edit-state @ edit-cursor-column @ edit-state @ edit-saved-cursor-column ! ; 
 : go-to-current-coord edit-state @ edit-cursor-row @ edit-state @ edit-cursor-column @ 3 + go-to-coord ; 
 : dirty edit-state @ edit-current @ dirty? true edit-state @ edit-current @ dirty! not if update-header then ; 
 : finish-insert save-current-column update-current-row go-to-current-coord dirty false edit-state @ edit-unicode-entered ! ; 
 : resolve-unicode-entered edit-state @ edit-unicode-entered @ if systick-counter begin ystick-counter over - 100 u< if key? not if pause else get-key dup unicode? over unicode-start? not and if current-row-index@ row-len buffer-width u< if urrent-row current-column-bytes + urrent-row current-column-bytes 1+ + uffer-width current-column-bytes - 1- move up current-row current-column-bytes + c! else rop then false else set-key finish-insert true then then lse finish-insert true hen until drop then ; 
 : handle-insert current-row-index@ row-len buffer-width u< if current-row current-column-bytes + current-row current-column-bytes 1+ + buffer-width current-column-bytes - 1- move dup current-row current-column-bytes + c! dup $20 >= over $80 < and if rop edit-state @ edit-cursor-column +! ave-current-column pdate-current-row o-to-current-coord irty else nicode-start? if 1 edit-state @ edit-cursor-column +! true edit-state @ edit-unicode-entered ! hen then else drop then ; 
 : handle-delete current-column-index@ 0 > if left-bytes current-row current-column-bytes + 2dup swap - buffer-width current-column-bytes - move current-row buffer-width + over - swap $20 fill -1 edit-state @ edit-cursor-column +! save-current-column update-current-row go-to-current-coord dirty then ; 
 : handle-delete-forward current-column-bytes buffer-width < if right-bytes current-row current-column-bytes + 2dup swap + swap buffer-width current-column-bytes - 3 pick - move current-row buffer-width + over - swap $20 fill save-current-column update-current-row dirty then ; 
 : handle-insert-row current-row-index@ buffer-height 1- < if buffer-height 1- row-len 0= if urrent-row current-row buffer-width + uffer-height current-row-index@ - 1- buffer-width * move urrent-row buffer-width $20 fill current-column-index! ave-current-column pdate-all irty then then ; 
 : handle-delete-row max-columns 0> if current-column-bytes current-row over + buffer-width rot - $20 fill update-all dirty else current-row-index@ buffer-height 1- < if urrent-row buffer-width + current-row uffer-height current-row-index@ - 1- buffer-width * move uffer-height 1- get-row buffer-width $20 fill current-column-index! ave-current-column pdate-all irty o-to-current-coord then then ; 
 : handle-forward current-column-bytes buffer-width < if 1 edit-state @ edit-cursor-column +! save-current-column go-to-current-coord then ; 
 : handle-backward current-column-index@ 0> if -1 edit-state @ edit-cursor-column +! save-current-column go-to-current-coord then ; 
 : use-saved-cursor-column edit-state @ edit-saved-cursor-column @ edit-state @ edit-start-column @ - max-columns < if edit-state @ edit-saved-cursor-column @ edit-state @ edit-cursor-column ! else max-columns edit-state @ edit-start-column @ + edit-state @ edit-cursor-column ! then ; 
 : handle-next current-id 1+ dup $FFFFFFFF u< if change-buffer else drop then use-saved-cursor-column go-to-current-coord ; 
 : handle-prev current-id dup 0<> if 1- change-buffer else drop then use-saved-cursor-column go-to-current-coord ; 
 : handle-up current-row-index@ 0> if -1 edit-state @ edit-cursor-row +! use-saved-cursor-column go-to-current-coord then ; 
 : handle-down current-row-index@ buffer-height 1- < if 1 edit-state @ edit-cursor-row +! use-saved-cursor-column go-to-current-coord then ; 
 : handle-newline 0 current-column-index! save-current-column current-row-index@ buffer-height 1- < if 1 edit-state @ edit-cursor-row +! go-to-current-coord else 0 current-row-index! handle-next then ; 
 : handle-start 0 current-column-index! save-current-column go-to-current-coord ; 
 : handle-end max-columns current-column-index! save-current-column go-to-current-coord ; 
 : handle-tab current-column-index@ 1 and 0= if $20 handle-insert then $20 handle-insert ; 
 : handle-revert current-id edit-state @ edit-current @ load-buffer update-all ; 
 : handle-write current-id save-buffer update-all ; 
 : config-edit reset-ansi-term draw-empty get-cursor-position false edit-state @ edit-unicode-entered ! buffer-width 4 + - 0 max edit-state @ edit-start-column ! buffer-height - 0 max edit-state @ edit-start-row ! get-terminal-size edit-state @ edit-terminal-columns ! edit-state @ edit-terminal-rows ! edit-state @ edit-start-row @ edit-state @ edit-cursor-row ! edit-state @ edit-start-column @ edit-state @ edit-cursor-column ! go-to-current-coord save-current-column 0 edit-state @ edit-current ! 0 edit-state @ edit-dirty ! buffer-count 0 ?do i edit-state @ edit-ids i cells + ! loop load-all-buffers current-id change-buffer ; 
 : leave-edit edit-state @ edit-start-row @ buffer-height + edit-state @ edit-start-column @ buffer-width 4 + + go-to-coord edit-state @ ram-here! ; 
 : handle-special get-key case [char] A of handle-up endof [char] B of handle-down endof [char] C of handle-forward endof [char] D of handle-backward endof [char] 3 of et-key case [char] ~ of handle-delete-forward endof clear-keys ndcase endof [char] 5 of et-key case [char] ~ of handle-prev endof clear-keys ndcase endof [char] 6 of et-key case [char] ~ of handle-next endof clear-keys ndcase endof clear-keys endcase ; 
 : handle-escape get-key case [char] [ of handle-special endof clear-keys endcase ; 
 : edit dup $FFFFFFFF <> averts x-invalid-block-id edit-size [: edit-state ! config-edit begin esolve-unicode-entered et-key up $20 u< if case return of handle-newline false endof newline of handle-newline false endof tab of handle-tab false endof ctrl-a of handle-start false endof ctrl-e of handle-end false endof ctrl-f of handle-forward false endof ctrl-b of handle-backward false endof ctrl-n of handle-next false endof ctrl-p of handle-prev false endof ctrl-v of true endof ctrl-w of handle-write false endof ctrl-x of handle-revert false endof ctrl-u of handle-insert-row false endof ctrl-k of handle-delete-row false endof escape of handle-escape false endof swap false swap endcase lse dup delete = if drop handle-delete else handle-insert then false hen until save-all-buffers leave-edit ;] with-aligned-allot ; 
 : x-out-of-range-floor-count ." cr ; 
 : max-floor-count constant ; 
 : no-elevator-dir constant ; 
 : elevator-up-dir constant ; 
 : elevator-down-dir constant ; 
 : elevator-delay constant ; 
 : init-test { count -- } count <elevator> [: { elevator } elevator run-world ;] with-object ; 
 : pad-flash-erase-block begin flash-here $FFF and while 0 cflash, repeat ; 
 : erase-all prepare-reboot erase-all ; 
 : erase-dict-after prepare-reboot erase-dict-after ; 
 : restore-flash erase-dict-after rdrop ; 
 : cornerstone-does> does> @ $1000 align erase-dict-after ; 
 : x-esp-at-not-owned ." cr ; 
 : x-esp-at-timeout ." cr ; 
 : x-esp-at-not-ready ." cr ; 
 : x-esp-at-error ." cr ; 
 : x-out-of-range-value ." cr ; 
 : no-connect constant ; 
 : tcp constant ; 
 : tcpv6 constant ; 
 : udp constant ; 
 : udpv6 constant ; 
 : ssl constant ; 
 : sslv6 constant ; 
 : client constant ; 
 : server constant ; 
 : station-not-inited constant ; 
 : station-not-connected constant ; 
 : station-connected constant ; 
 : station-active constant ; 
 : station-disconnected constant ; 
 : station-attempted-wifi constant ; 
 : prefer-resolve-ipv4 constant ; 
 : resolve-ipv4-only constant ; 
 : resolve-ipv6-only constant ; 
 : null-mode constant ; 
 : station-mode constant ; 
 : softap-mode constant ; 
 : softap-station-mode constant ; 
 : not-auto-connect constant ; 
 : auto-connect constant ; 
 : disable-sleep-mode constant ; 
 : modem-sleep-dtim-mode constant ; 
 : light-sleep-mode constant ; 
 : modem-sleep-listen-interval-mode constant ; 
 : not-close-all constant ; 
 : close-all constant ; 
 : SPI_MASTER_WRITE_DATA_TO_SLAVE_CMD constant ; 
 : SPI_MASTER_READ_DATA_FROM_SLAVE_CMD constant ; 
 : SPI_MASTER_WRITE_STATUS_TO_SLAVE_CMD constant ; 
 : SPI_MASTER_READ_STATUS_FROM_SLAVE_CMD constant ; 
 : clear-timeout constant ; 
 : emit-visible { byte -- } byte $20 >= byte $0D = or byte $0A = or if byte internal::serial-emit then ; 
 : type-visible { c-addr u -- } c-addr u + c-addr ?do i c@ emit-visible loop ; 
 : find-string { in-addr in-bytes find-addr find-bytes -- offset|-1 } in-bytes find-addr find-bytes { total-bytes cur-addr cur-bytes } begin in-bytes 0> cur-bytes 0> and while in-addr c@ cur-addr c@ = if 1 +to cur-addr -1 +to cur-bytes else find-addr to cur-addr find-bytes to cur-bytes in-addr c@ cur-addr c@ = if 1 +to cur-addr -1 +to cur-bytes then then 1 +to in-addr -1 +to in-bytes repeat cur-bytes 0= if total-bytes in-bytes - else -1 then ; 
 : find-data { resp-addr resp-bytes head-addr head-bytes -- addr' bytes' } resp-addr resp-bytes head-addr head-bytes find-string dup -1 <> averts x-esp-at-error { head-end } resp-addr head-end + resp-bytes head-end - s\" \r\n" find-string { field-end } field-end -1 = if resp-bytes head-end - to field-end else -2 +to field-end then resp-addr head-end + field-end ; 
 : find-data-no-error { resp-addr resp-bytes head-addr head-bytes -- addr' bytes' found? } resp-addr resp-bytes head-addr head-bytes find-string dup -1 <> if { head-end } resp-addr head-end + resp-bytes head-end - s\" \r\n" find-string { field-end } field-end -1 = if resp-bytes head-end - to field-end else -2 +to field-end then resp-addr head-end + field-end true else 0 0 false then ; 
 : find-nth-data { resp-addr resp-bytes head-addr head-bytes index -- addr' bytes' found? } resp-addr resp-bytes { cur-addr cur-bytes } index 1+ 0 ?do cur-addr cur-bytes head-addr head-bytes find-string { head-end } head-end -1 = if 0 0 false exit then head-end +to cur-addr head-end negate +to cur-bytes loop cur-addr cur-bytes s\" \r\n" find-string { field-end } field-end -1 = if cur-bytes to field-end else -2 +to field-end then cur-addr field-end true ; 
 : count-data { resp-addr resp-bytes head-addr head-bytes -- count } 0 { head-count } begin resp-addr resp-bytes head-addr head-bytes find-string { head-end } head-end -1 <> if head-end +to resp-addr head-end negate +to resp-bytes 1 +to head-count false else true then until head-count ; 
 : parse-field { c-addr bytes -- next-addr next-bytes field-addr field-bytes } c-addr bytes s" find-string dup -1 <> if { offset } c-addr offset + bytes offset - c-addr offset 1- else drop c-addr bytes + 0 c-addr bytes then ; 
 : parse-quote-field { c-addr bytes -- next-addr next-bytes field-addr field-bytes } bytes 2 > if c-addr c@ [char] " = if c-addr bytes s\" \"," find-string dup -1 <> if { offset } c-addr offset + bytes offset - c-addr 1+ offset 3 - else c-addr bytes + 1- c@ [char] " = if c-addr bytes + 0 c-addr 1+ bytes 2 - else c-addr bytes + 0 c-addr bytes then then else c-addr bytes parse-field then else c-addr bytes + 0 c-addr bytes then ; 
 : parse-connect-type case s" ofstr sslv6 endof ['] x-esp-at-error ?raise endcasestr ; 
 : format-connect-type case tcp of s" endof ['] x-out-of-range-value ?raise endcase ; 
 : format-status-station case station-not-inited of s" endof ['] x-out-of-range-value ?raise endcase ; 
 : format-client-server case client of s" endof ['] x-out-of-range-value ?raise endcase ; 
 : format-decimal base @ { saved-base } 10 base ! ['] format-integer try saved-base base ! ?raise ; 
 : parse-decimal base @ { saved-base } 10 base ! ['] parse-integer try saved-base base ! ?raise ; 
 : esp-at-default-timeout constant ; 
 : esp-at-default-log constant ; 
 : esp-at-status-max-count constant ; 
 : filter-ok s\" \r\nOK" find-string dup -1 <> if 0 else drop 0 -1 then ; 
 : filter-ok-error { D: string -- index found } string s\" \r\nOK" find-string dup -1 <> if 0 exit else drop then string s\" \r\nERROR" find-string dup -1 <> if 1 else drop 0 -1 then ; 
 : filter-gt-error { D: string -- index found } string s" find-string dup -1 <> if 1 else drop 0 -1 then ; 
 : filter-send-ok-error { D: string -- index found } string s" find-string dup -1 <> if 1 else drop 0 -1 then ; 
 : esp-at-buffer-size constant ; 
 : esp-at-max-send-once-size constant ; 
 : esp-at-frame-buffer-size constant ; 
 : hard-fault-vector constant ; 
 : mem-fault-vector constant ; 
 : bus-fault-vector constant ; 
 : usage-fault-vector constant ; 
 : CFSR constant ; 
 : HFSR constant ; 
 : saved-emit-hook variable ; 
 : saved-emit?-hook variable ; 
 : saved-key-hook variable ; 
 : saved-key?-hook variable ; 
 : saved-pause-hook variable ; 
 : prepare-faulted-state emit-hook @ saved-emit-hook ! emit?-hook @ saved-emit?-hook ! key-hook @ saved-key-hook ! key?-hook @ saved-key?-hook ! pause-hook @ saved-pause-hook ! ['] serial-emit emit-hook ! ['] serial-emit? emit?-hook ! ['] serial-key key-hook ! ['] serial-key? key?-hook ! [: ;] pause-hook ! ; 
 : restore-hooks saved-emit-hook @ emit-hook ! saved-emit?-hook @ emit?-hook ! saved-key-hook @ key-hook ! saved-key?-hook @ key?-hook ! saved-pause-hook @ pause-hook ! ; 
 : dump-addr-info dup find-approx-addr ?dup if space dup word-name c@ if dup word-name count type else ." h.8 else drop then ; 
 : dump-registers code[ 4 dp subs_,#_ 0 dp tos str_,[_,#_] 5 tos mrs_,_ ]code cr cr ." dup h.8 dump-addr-info ; 
 : collect-registers code[ r7 r0 movs_,_ 68 dp subs_,#_ 64 dp r6 str_,[_,#_] 32 dp r0 str_,[_,#_] $0 8 + r0 ldr_,[sp,#_] 60 dp r0 str_,[_,#_] $4 8 + r0 ldr_,[sp,#_] 56 dp r0 str_,[_,#_] $8 8 + r0 ldr_,[sp,#_] 52 dp r0 str_,[_,#_] $C 8 + r0 ldr_,[sp,#_] 48 dp r0 str_,[_,#_] 44 dp r4 str_,[_,#_] 40 dp r5 str_,[_,#_] 36 dp r6 str_,[_,#_] r8 r0 mov4_,4_ 28 dp r0 str_,[_,#_] r9 r0 mov4_,4_ 24 dp r0 str_,[_,#_] r10 r0 mov4_,4_ 20 dp r0 str_,[_,#_] r11 r0 mov4_,4_ 16 dp r0 str_,[_,#_] $10 8 + r0 ldr_,[sp,#_] 12 dp r0 str_,[_,#_] sp r0 mov4_,4_ 36 r0 adds_,#_ $1C 8 + r1 ldr_,[sp,#_] 1 r2 movs_,#_ 9 r2 r2 lsls_,_,#_ r1 r2 tst_,_ eq bc> 4 r0 adds_,#_ >mark 8 dp r0 str_,[_,#_] $14 8 + r0 ldr_,[sp,#_] 4 dp r0 str_,[_,#_] $18 8 + r0 ldr_,[sp,#_] 0 dp r0 str_,[_,#_] r1 r6 movs_,_ ]code ; 
 : dump-stack cr cr ." i @ dup h.8 dump-addr-info 4 +loop ; 
 : dump-rstack cr cr ." i @ dup h.8 dump-addr-info 4 +loop ; 
 : recover-from-fault code[ 4 dp subs_,#_ 0 dp tos str_,[_,#_] $1C 8 + tos ldr_,[sp,#_] tos r0 movs_,_ 1 r1 movs_,#_ 24 r1 r1 lsls_,_,#_ r1 r0 orrs_,_ $1C 8 + r0 str_,[sp,#_] ]code $1FF and 0= if CFSR @ CFSR ! HFSR @ HFSR ! in-main? if display-red cr cr ." display-normal cr abort then ; 
 : handle-hard-fault collect-registers prepare-faulted-state display-red cr ." dump-registers dump-stack dump-rstack display-normal recover-from-fault ; 
 : handle-mem-fault collect-registers prepare-faulted-state display-red cr ." dump-registers dump-stack dump-rstack display-normal recover-from-fault ; 
 : handle-bus-fault collect-registers prepare-faulted-state display-red cr ." dump-registers dump-stack dump-rstack display-normal recover-from-fault ; 
 : handle-usage-fault collect-registers prepare-faulted-state display-red cr ." dump-registers dump-stack dump-rstack display-normal recover-from-fault ; 
 : init-exception ['] handle-hard-fault hard-fault-vector vector! ['] handle-mem-fault mem-fault-vector vector! ['] handle-bus-fault bus-fault-vector vector! ['] handle-usage-fault usage-fault-vector vector! ; 
 : total-count variable ; 
 : rising-edge-count variable ; 
 : falling-edge-count variable ; 
 : logic-high? variable ; 
 : edge-tracker rising-edge-count @ falling-edge-count @ begin over rising-edge-count @ < if wap 1+ swap ." then again ; 
 : handle-exti-2 1 total-count +! 2 EXTI_PR@ if 2 GPIOE IDR@ if ogic-high? @ not if 1 rising-edge-count +! true logic-high? ! hen else ogic-high? @ if 1 falling-edge-count +! false logic-high? ! hen then 2 EXTI_PR! then ; 
 : edge-tracker-task variable ; 
 : init-test false 2 EXTI_IMR! EXTI_2 NVIC_ICER_CLRENA! syscfg-clock-enable INPUT_MODE 2 GPIOE MODER! OUTPUT_MODE 3 GPIOE MODER! 2 GPIOE IDR@ logic-high? ! 0 total-count ! 0 rising-edge-count ! 0 falling-edge-count ! PE 2 SYSCFG_EXTICRx! 0 ['] edge-tracker 420 128 512 spawn edge-tracker-task ! edge-tracker-task @ run ['] handle-exti-2 exti-2-handler-hook ! EXTI_2 NVIC_ISER_SETENA! true 2 EXTI_IMR! true 2 EXTI_EMR! true 2 EXTI_RTSR! true 2 EXTI_FTSR! ; 
 : pe3-high true 3 GPIOE BSRR! ; 
 : pe3-low false 3 GPIOE BSRR! ; 
 : fill-bytes code[ tos r0 movs_,_ cortex-m7? [if] 0 dp r1 ldr_,[_,#_] 4 dp r2 ldr_,[_,#_] 8 dp tos ldr_,[_,#_] 12 dp adds_,#_ [else] tos r2 r1 3 dp ldm [then] mark> 0 r1 cmp_,#_ eq bc> 1 r1 subs_,#_ r1 r2 r0 strb_,[_,_] 2swap b< >mark ]code ; 
 : fill-cells code[ tos r0 movs_,_ cortex-m7? [if] 0 dp r1 ldr_,[_,#_] 4 dp r2 ldr_,[_,#_] 8 dp tos ldr_,[_,#_] 12 dp adds_,#_ [else] tos r2 r1 3 dp ldm [then] mark> 0 r1 cmp_,#_ eq bc> 4 r1 subs_,#_ r1 r2 r0 str_,[_,_] 2swap b< >mark ]code ; 
 : byte>cell dup over 8 lshift or over 16 lshift or swap 24 lshift or ; 
 : fill over 0> if 2 pick 3 and 0= if over 3 and 0= if byte>cell fill-cells else 3dup swap dup 3 and - swap byte>cell fill-cells swap >r r@ dup 3 and - rot + swap r> 3 and swap fill-bytes then else over cell <= if fill-bytes else 3dup nip over cell align 2 pick - dup >r swap fill-bytes rot r@ + rot r> - rot recurse then then else 2drop drop then ; 
 : goto [immediate] [compile-only] token-word undefer-lit word-exit-hook @ ?execute [ armv6m-instr import ] r0 1 pop r0 lr mov4_,4_ >xt dup here 4 + - 1 arshift dup 1024 < over -1025 > and if nip $7FF and $E000 or h, else drop 1 or r0 literal, r0 bx_ then [ armv6m-instr unimport ] ; 
 : begin-jumptable token dup averts x-token-expected start-compile-no-push [ armv6m-instr import ] r6 r1 movs_,_ r6 1 r7 ldm [ armv6m-instr unimport ] ; 
 : end-jumptable word-exit-hook @ ?execute word-end-hook @ ?execute [ armv6m-instr import ] lr bx_ [ armv6m-instr unimport ] $003F h, visible finalize, ; 
 : => token-word swap undefer-lit [ armv6m-instr import ] dup 0 >= over 255 <= and if r1 cmp_,#_ else r0 literal, r0 r1 cmp_,_ then ne bc> rot word-exit-hook @ ?execute >xt dup here 4 + - 1 arshift dup 1024 < over -1025 > and if nip $7FF and $E000 or h, else drop 1 or r0 literal, r0 bx_ then >mark [ armv6m-instr unimport ] ; 
 : default=> token-word undefer-lit [ armv6m-instr import ] word-exit-hook @ ?execute >xt dup here 4 + - 1 arshift dup 1024 < over -1025 > and if nip $7FF and $E000 or h, else drop 1 or r0 literal, r0 bx_ then [ armv6m-instr unimport ] ; 
 : life-width variable ; 
 : life-height variable ; 
 : life-display-x variable ; 
 : life-display-y variable ; 
 : life-display-width variable ; 
 : life-display-height variable ; 
 : life-display-x-end variable ; 
 : life-display-y-end variable ; 
 : life-buffer-0 variable ; 
 : life-buffer-1 variable ; 
 : life-line-buffer variable ; 
 : current-buffer variable ; 
 : new-buffer variable ; 
 : wrap-coord dup life-height @ >= if drop 0 then dup 0< if drop life-height @ 1- then swap dup life-width @ >= if drop 0 then dup 0< if drop life-width @ 1- then swap ; 
 : alive? life-width @ * + current-buffer @ + c@ 16 >= ; 
 : +alive life-width @ * + current-buffer @ + 1 swap c+! ; 
 : -alive life-width @ * + current-buffer @ + -1 swap c+! ; 
 : set-dead 2dup 1+ wrap-coord -alive 2dup 1+ swap 1+ swap wrap-coord -alive 2dup 1+ swap 1- swap wrap-coord -alive 2dup swap 1+ swap wrap-coord -alive 2dup 1- wrap-coord -alive 2dup 1- swap 1+ swap wrap-coord -alive 2dup 1- swap 1- swap wrap-coord -alive 2dup swap 1- swap wrap-coord -alive life-width @ * + current-buffer @ + 16 swap cbic! ; 
 : set-alive 2dup 1+ wrap-coord +alive 2dup 1+ swap 1+ swap wrap-coord +alive 2dup 1+ swap 1- swap wrap-coord +alive 2dup swap 1+ swap wrap-coord +alive 2dup 1- wrap-coord +alive 2dup 1- swap 1+ swap wrap-coord +alive 2dup 1- swap 1- swap wrap-coord +alive 2dup swap 1- swap wrap-coord +alive life-width @ * + current-buffer @ + 16 swap cbis! ; 
 : alive! rot if 2dup alive? not if set-alive else 2drop then else 2dup alive? if set-dead else 2drop then then ; 
 : new-alive? life-width @ * + new-buffer @ + c@ 16 >= ; 
 : +new-alive life-width @ * + new-buffer @ + 1 swap c+! ; 
 : -new-alive life-width @ * + new-buffer @ + -1 swap c+! ; 
 : set-new-dead 2dup 1+ wrap-coord -new-alive 2dup 1+ swap 1+ swap wrap-coord -new-alive 2dup 1+ swap 1- swap wrap-coord -new-alive 2dup swap 1+ swap wrap-coord -new-alive 2dup 1- wrap-coord -new-alive 2dup 1- swap 1+ swap wrap-coord -new-alive 2dup 1- swap 1- swap wrap-coord -new-alive 2dup swap 1- swap wrap-coord -new-alive life-width @ * + new-buffer @ + 16 swap cbic! ; 
 : set-new-alive 2dup 1+ wrap-coord +new-alive 2dup 1+ swap 1+ swap wrap-coord +new-alive 2dup 1+ swap 1- swap wrap-coord +new-alive 2dup swap 1+ swap wrap-coord +new-alive 2dup 1- wrap-coord +new-alive 2dup 1- swap 1+ swap wrap-coord +new-alive 2dup 1- swap 1- swap wrap-coord +new-alive 2dup swap 1- swap wrap-coord +new-alive life-width @ * + new-buffer @ + 16 swap cbis! ; 
 : new-alive! rot if 2dup alive? not if set-new-alive else 2drop then else 2dup alive? if set-new-dead else 2drop then then ; 
 : set-new-dead-nonborder 2dup 1+ -new-alive 2dup 1+ swap 1+ swap -new-alive 2dup 1+ swap 1- swap -new-alive 2dup swap 1+ swap -new-alive 2dup 1- -new-alive 2dup 1- swap 1+ swap -new-alive 2dup 1- swap 1- swap -new-alive 2dup swap 1- swap -new-alive life-width @ * + new-buffer @ + 16 swap cbic! ; 
 : set-new-alive-nonborder 2dup 1+ +new-alive 2dup 1+ swap 1+ swap +new-alive 2dup 1+ swap 1- swap +new-alive 2dup swap 1+ swap +new-alive 2dup 1- +new-alive 2dup 1- swap 1+ swap +new-alive 2dup 1- swap 1- swap +new-alive 2dup swap 1- swap +new-alive life-width @ * + new-buffer @ + 16 swap cbis! ; 
 : cycle-cell 2dup life-width @ * + current-buffer @ + c@ 2 lshift nonborder-state-table + @ execute ; 
 : switch-buffers current-buffer @ new-buffer @ current-buffer ! new-buffer ! ; 
 : cycle-life current-buffer @ new-buffer @ life-width @ life-height @ * move 0 begin dup life-height @ < while 0 over false -rot new-alive! life-width @ 1- over false -rot new-alive! 1+ repeat drop 0 begin dup life-width @ < while dup 0 false -rot new-alive! dup life-height @ 1- false -rot new-alive! 1+ repeat drop 1 begin dup life-width @ 1- < while 1 begin dup life-height @ 1- < while dup cycle-cell 1+ repeat drop 1+ repeat drop switch-buffers ; 
 : display-life hide-cursor 0 0 go-to-coord life-display-y @ begin dup life-display-y-end @ < while life-display-x @ begin dup life-display-x-end @ < while dup swap alive? if ." else space then 1+ repeat drop 1+ cr repeat show-cursor ; 
 : init-sixel escape emit ." ; 
 : sixel-rle-count variable ; 
 : sixel-rle-value variable ; 
 : init-sixel-rle 0 sixel-rle-count ! 0 sixel-rle-value ! ; 
 : add-sixel-rle sixel-rle-count @ 0= if 1 sixel-rle-count ! sixel-rle-value ! else dup sixel-rle-value @ <> if ixel-rle-count @ 3 > if ." sixel-rle-count @ (dec.) lse sixel-rle-count @ 2 > if sixel-rle-value @ emit then sixel-rle-count @ 1 > if sixel-rle-value @ emit then hen ixel-rle-value @ emit sixel-rle-count ! then sixel-rle-value ! 1 sixel-rle-count +! then ; 
 : add-sixel-rle2 sixel-rle-count @ 0= if 2 sixel-rle-count ! sixel-rle-value ! else dup sixel-rle-value @ <> if ixel-rle-count @ 3 > if ." sixel-rle-count @ (dec.) lse sixel-rle-count @ 2 > if sixel-rle-value @ emit then sixel-rle-count @ 1 > if sixel-rle-value @ emit then hen ixel-rle-value @ emit sixel-rle-count ! then sixel-rle-value ! 2 sixel-rle-count +! then ; 
 : force-sixel-rle-out sixel-rle-count @ 0<> if sixel-rle-count @ 3 > if " !" sixel-rle-count @ (dec.) else ixel-rle-count @ 2 > if sixel-rle-value @ emit hen ixel-rle-count @ 1 > if sixel-rle-value @ emit hen then sixel-rle-value @ emit then ; 
 : display-life-sixel-part1 ." escape emit $5C emit show-cursor ; 
 : display-life-sixel hide-cursor 0 0 go-to-coord init-sixel life-display-y @ 6 / 6 * begin dup life-display-y-end @ 6 / 6 * < while ." 6 + repeat drop display-life-sixel-part1 ; 
 : display-life-sixel2-part1 ." escape emit $5C emit show-cursor ; 
 : display-life-sixel2 hide-cursor 0 0 go-to-coord init-sixel life-display-y @ 3 / 3 * begin dup life-display-y-end @ 3 / 3 * < while ." 3 + repeat drop display-life-sixel2-part1 ; 
 : run-life cr reset-ansi-term get-cursor-position drop 0 begin cycle-life over 0 go-to-coord 1+ ." dup . erase-end-of-line key? until key 2drop ; 
 : run-life-term reset-ansi-term hide-cursor 0 0 go-to-coord erase-end-of-line erase-down begin cycle-life display-life key? until key show-cursor drop ; 
 : run-life-sixel reset-ansi-term hide-cursor 0 0 go-to-coord erase-end-of-line erase-down begin cycle-life display-life-sixel key? until key show-cursor drop ; 
 : run-life-sixel2 reset-ansi-term hide-cursor 0 0 go-to-coord erase-end-of-line erase-down begin cycle-life display-life-sixel2 key? until key show-cursor drop ; 
 : step-life reset-ansi-term 0 0 go-to-coord erase-end-of-line erase-down cycle-life display-life ; 
 : step-life-sixel reset-ansi-term 0 0 go-to-coord erase-end-of-line erase-down cycle-life display-life-sixel ; 
 : step-life-sixel2 reset-ansi-term 0 0 go-to-coord erase-end-of-line erase-down cycle-life display-life-sixel2 ; 
 : life-viewport! dup 3 pick + life-height @ <= if life-display-height ! else drop life-height @ 2 pick - life-display-height ! then dup 3 pick + life-width @ <= if life-display-width ! else drop life-width @ 2 pick - life-display-width ! then dup 0>= if dup life-height @ <= if ife-display-y ! else rop life-height @ life-display-y ! then else drop 0 life-display-y ! then dup 0>= if dup life-width @ <= if ife-display-x ! else rop life-width @ life-display-x ! then else drop 0 life-display-x ! then life-display-x @ life-display-width @ + life-display-x-end ! life-display-y @ life-display-height @ + life-display-y-end ! ; 
 : clear-life current-buffer @ life-width @ life-height @ * 0 fill ; 
 : init-life ram-here life-line-buffer ! over ram-allot 0 life-display-x ! 0 life-display-y ! 2dup life-height ! life-width ! 2dup life-display-height ! life-display-width ! ram-here dup life-buffer-0 ! current-buffer ! * dup ram-allot ram-here dup life-buffer-1 ! new-buffer ! ram-allot clear-life life-display-x @ life-display-width @ + life-display-x-end ! life-display-y @ life-display-height @ + life-display-y-end ! ; 
 : get-char begin dup 0 > if ver c@ dup $20 <> if rot 1 + rot 1 - rot true lse drop 1 - swap 1 + swap false hen else true then until ; 
 : set-multiple over >r 2swap begin get-char dup 0<> while case char] _ of 2swap 2dup false -rot alive! swap 1 + swap 2swap endof char] * of 2swap 2dup true -rot alive! swap 1 + swap 2swap endof char] / of 2swap 1 + nip r@ swap 2swap endof endcase repeat drop 2drop 2drop rdrop ; 
 : block s" 2swap set-multiple ; 
 : tub s" 2swap set-multiple ; 
 : boat s" 2swap set-multiple ; 
 : blinker rot case 0 of s" endof endcase 2swap set-multiple ; 
 : glider rot case 0 of s" endof endcase 2swap set-multiple ; 
 : r-pentomino s" 2swap set-multiple ; 
 : x-sector-size-not-supported ." cr ; 
 : x-fs-version-not-supported ." cr ; 
 : x-bad-info-sector ." cr ; 
 : x-no-clusters-free ." cr ; 
 : x-file-name-format ." cr ; 
 : x-out-of-range-entry ." cr ; 
 : x-out-of-range-partition ." cr ; 
 : x-entry-not-found ." cr ; 
 : x-entry-already-exists ." cr ; 
 : x-entry-not-file ." cr ; 
 : x-entry-not-dir ." cr ; 
 : x-dir-is-not-empty ." cr ; 
 : x-forbidden-dir ." cr ; 
 : x-empty-path ." cr ; 
 : x-invalid-path ." cr ; 
 : seek-set constant ; 
 : seek-cur constant ; 
 : seek-end constant ; 
 : sector-size constant ; 
 : entry-size constant ; 
 : unaligned-h@ dup c@ swap 1+ c@ 8 lshift or ; 
 : free-cluster? $0FFFFFFF and 0= ; 
 : end-cluster? $0FFFFFF8 and $0FFFFFF8 = ; 
 : link-cluster? $0FFFFFFF and dup $00000002 >= swap $0FFFFFEF <= and ; 
 : cluster-link $0FFFFFFF and ; 
 : free-cluster-mark constant ; 
 : end-cluster-mark constant ; 
 : count-end-spaces repeat nip nip ; 
 : strip-end-spaces 2dup count-end-spaces - ; 
 : >string 2dup 2>r rot min dup >r move r> 2r> 2 pick - swap rot + swap ; 
 : dot-index 0 begin over 0> while 2 pick c@ [char] . = if nip nip exit else 1+ rot 1+ rot 1- rot then repeat 2drop drop -1 ; 
 : dot-count 0 begin over 0> while 2 pick c@ [char] . = if 1+ then rot 1+ rot 1- rot repeat nip nip ; 
 : validate-file-name-char s\" \"*/:<>?\\|" begin ?dup while over c@ 3 pick <> averts x-file-name-format 1- swap 1+ swap repeat 2drop ; 
 : validate-file-name-chars begin ?dup while over c@ validate-file-name-char 1- swap 1+ swap repeat drop ; 
 : upcase-char dup [char] a >= over [char] z <= and if [char] a - [char] A + then ; 
 : upcase-string ; 
 : validate-file-name 2dup validate-file-name-chars dup 12 <= averts x-file-name-format 2dup dot-count 1 = averts x-file-name-format 2dup dot-index dup 0 > averts x-file-name-format dup 8 <= averts x-file-name-format 2dup swap 1- < averts x-file-name-format swap 4 - >= averts x-file-name-format drop ; 
 : validate-dir-name 2dup validate-file-name-chars 2dup s" equal-strings? not if 2dup dot-count 0= averts x-file-name-format nip 8 <= averts x-file-name-format else 2drop then else 2drop then ; 
 : copy-space-pad 2dup $20 fill rot min move ; 
 : used-string rot - rot drop ; 
 : convert-file-name >r 2dup validate-file-name r> 11 [: dup 11 $20 fill swap 2>r 2dup dot-index 2 pick swap r@ swap move 2dup dot-index 1+ rot over + -rot - r@ 8 + swap move r@ c@ $E5 = if $05 r@ c! then r> 11 0 ?do dup i + c@ upcase-char over i + c! loop r> execute ;] with-allot ; 
 : convert-dir-name >r 2dup validate-dir-name r> 11 [: dup 11 $20 fill swap 2>r r@ swap move r@ c@ $E5 = if $05 r@ c! then r> 11 0 ?do dup i + c@ upcase-char over i + c! loop r> execute ;] with-allot ; 
 : dir-name? s" 2over equal-strings? if 2drop true else dot-index -1 = then then ; 
 : convert-name >r 2dup dir-name? if r> convert-dir-name else r> convert-file-name then ; 
 : forbidden-dir? s" equal-strings? then ; 
 : find-path-separator 0 begin over 0> while 2 pick c@ [char] / = if nip nip exit else 1+ rot 1+ rot 1- rot then repeat 2drop drop -1 ; 
 : strip-final-path-separator begin dup 0> while 2dup 1- + c@ [char] / = if 1- else exit then repeat ; 
 : validate-path dup 0> if over c@ [char] . = if 1- swap 1+ swap dup 0> if over c@ [char] . = if 1- swap 1+ swap dup 0> if over c@ [char] / = averts x-invalid-path then else over c@ [char] / = averts x-invalid-path then then else 1- swap 1+ swap then then begin dup 0> while over c@ [char] / = if 1- swap 1+ swap dup 0> if over c@ [char] . = if 1- swap 1+ swap dup 0> if over c@ [char] . = if 1- swap 1+ swap dup 0> if over c@ [char] / = averts x-invalid-path then else over c@ [char] / = averts x-invalid-path then then else 1- swap 1+ swap then then else over c@ [char] . = if 1- swap 1+ swap begin dup 0> while over c@ [char] / <> averts x-invalid-path 1- swap 1+ swap repeat else 1- swap 1+ swap then then repeat 2drop ; 
 : init-fat32 fat32-lock init-lock ; 
 : console-alarm-delay constant ; 
 : console-buffer-size constant ; 
 : flush-console-file-output begin dup console-alarm-set? @ while pause repeat [: { data } data console-buffer data console-start @ + data console-end @ data console-start @ - data console-file @ ['] write-file try dup ['] x-no-clusters-free = if true data console-io-end? ! then ?raise data console-start +! data console-buffer data console-start @ + data console-buffer data console-end @ data console-start @ - move data console-start @ negate data console-end +! 0 data console-start ! false data console-alarm-set? ! data console-file @ file-fs@ flush ;] over console-slock with-slock ; 
 : init-console-file-input { file data -- } data console-slock init-slock 0 data console-start ! 0 data console-end ! false data console-alarm-set? ! false data console-io-end? ! file data console-file ! file file-size@ data console-file-size ! data data console-io [: [: { data } data console-start @ data console-end @ = if data console-buffer console-buffer-size data console-file @ read-file dup 0= if true data console-io-end? ! ['] console::x-end-of-input ?raise then data console-end ! 0 data console-start ! then data console-buffer data console-start @ + c@ 1 data console-start +! ;] over console-slock with-slock ;] bind data data console-io? [: [: { data } data console-file @ tell-file data console-file-size @ < data console-io-end? @ not and data console-start @ data console-end @ <> or ;] over console-slock with-slock ;] bind ; 
 : init-console-file-output { file data -- } data console-slock init-slock 0 data console-start ! 0 data console-end ! false data console-alarm-set? ! false data console-io-end? ! file data console-file ! data data console-io [: [: { byte data } byte data console-buffer data console-end @ + c! 1 data console-end +! data console-end @ console-buffer-size < if data console-alarm-set? @ not if true data console-alarm-set? ! console-alarm-delay current-task task-priority@ data [: drop [: { data } data console-buffer data console-start @ + data console-end @ data console-start @ - data console-file @ ['] write-file try dup ['] x-no-clusters-free = if true data console-io-end? ! then ?raise data console-start +! data console-buffer data console-start @ + data console-buffer data console-end @ data console-start @ - move data console-start @ negate data console-end +! 0 data console-start ! false data console-alarm-set? ! ;] over console-slock with-slock ;] data console-alarm set-alarm-delay-default then else data console-alarm-set? @ if data console-alarm unset-alarm then data console-buffer data console-start @ + data console-end @ data console-start @ - data console-file @ ['] write-file try dup ['] x-no-clusters-free = if true data console-io-end? ! then ?raise data console-start +! data console-buffer data console-start @ + data console-buffer data console-end @ data console-start @ - move data console-start @ negate data console-end +! 0 data console-start ! false data console-alarm-set? ! then ;] over console-slock with-slock ;] bind data data console-io? [: { data } data console-io-end? @ not ;] bind data data console-io-flush ['] flush-console-file-output bind ; 
 : with-file-input console-file-data-size [: { data } swap data init-console-file-input data console-io data console-io? rot console::with-input ;] with-aligned-allot ; 
 : with-file-output console-out-file-data-size [: { data } swap data init-console-file-output data console-io data console-io? rot data console-io-flush swap console::with-output data flush-console-file-output ;] with-aligned-allot ; 
 : with-file-error-output console-out-file-data-size [: { data } swap data init-console-file-output data console-io data console-io? rot data console-io-flush swap console::with-error-output data flush-console-file-output ;] with-aligned-allot ; 
 : my-read-size constant ; 
 : my-total-size constant ; 
 : run-speed-test fat32-tools::current-fs@ averts fat32-tools::x-fs-not-set my-file -rot [: 3 pick swap open-file ;] fat32-tools::current-fs@ with-root-path drop 0 systick-counter { bytes-read last-systick } begin key? not while my-buffer my-read-size my-file read-file { cur-bytes-read } cur-bytes-read 0> if cur-bytes-read +to bytes-read bytes-read my-total-size >= if my-total-size negate +to bytes-read systick-counter { current-systick } 0 my-total-size 1024,0 f/ 0 current-systick last-systick - 10000,0 f/ f/ cr ." f. current-systick to last-systick then else 0 seek-set my-file seek-file then repeat key drop ; 
 : my-read-size constant ; 
 : small-read-size constant ; 
 : my-spi constant ; 
 : init-test my-spi 2 spi-pin my-spi 3 spi-pin my-spi 4 spi-pin 5 output-pin 6 2 ?do i pull-up-pin loop 5 my-spi <sd> my-sd init-object my-sd init-sd true my-sd write-through! my-sd <mbr> my-mbr init-object <partition> my-partition init-object my-partition 0 my-mbr partition@ my-partition partition-first-sector @ . my-partition my-sd <fat32-fs> my-fs init-object ; 
 : ls-root <fat32-entry> my-entry init-object my-dir my-fs root-dir@ begin my-entry my-dir read-dir if 12 [: 12 my-entry file-name@ cr type space false ;] with-allot else true then until ; 
 : create-file [: my-file swap create-file ;] my-fs with-root-path my-file write-file ; 
 : create-dir [: my-dir swap create-dir ;] my-fs with-root-path ; 
 : ls [: my-dir swap open-dir ;] my-fs with-root-path begin my-entry my-dir read-dir if 12 [: 12 my-entry file-name@ cr type space false ;] with-allot else true then until ; 
 : cat cr [: my-file swap open-file ;] my-fs with-root-path begin my-read-buffer my-read-size my-file read-file dup 0> if my-read-buffer swap type false else drop true then until ; 
 : remove-file ['] remove-file my-fs with-root-path ; 
 : remove-dir ['] remove-dir my-fs with-root-path ; 
 : rename ['] rename my-fs with-root-path ; 
 : seek-test my-dir my-fs root-dir@ s" my-read-buffer small-read-size my-file read-file my-read-buffer swap type ; 
 : create-big-file false my-sd write-through! [: my-file swap fat32::create-file ;] my-fs with-root-path $10000 0 ?do key? if key drop leave then hex i 0 <# # # # # # # # # #> decimal my-file write-file drop i $FF and 0= if i h.8 then loop true my-sd write-through! ; 
 : x-fs-not-set ." cr ; 
 : x-include-stack-overflow ." cr ; 
 : max-include-depth constant ; 
 : include-buffer-size constant ; 
 : read-buffer-size constant ; 
 : current-fs variable ; 
 : frame-depth variable ; 
 : include-buffer-content-len variable ; 
 : include-stack-top@ include-stack frame-depth @ 1- include-frame-size * + ; 
 : include-stack-next@ include-stack frame-depth @ include-frame-size * + ; 
 : read-file-into-buffer include-buffer include-buffer-content-len @ + include-buffer-size include-buffer-content-len @ - include-stack-top@ frame-file read-file include-buffer-content-len +! ; 
 : execute-line-len include-buffer-content-len @ 0 ?do include-buffer i + c@ dup $0A = swap $0D = or if i 1+ unloop exit then loop include-buffer-content-len @ ; 
 : update-line execute-line-len dup include-stack-top@ frame-offset @ + include-stack-top@ frame-file file-size@ = include-stack-top@ frame-eof ! dup dup 0> if 1- include-buffer + c@ dup $0A = swap $0D = or if 1- then then ; 
 : frame-eval-refill [: execute-line-len dup include-stack-top@ frame-offset +! dup negate include-buffer-content-len +! include-buffer + include-buffer include-buffer-content-len @ move read-file-into-buffer include-buffer update-line feed-input ;] fs-lock with-lock ; 
 : frame-eval-eof include-stack-top@ frame-eof @ ; 
 : unnest-include frame-depth @ 1- 0 max frame-depth ! frame-depth @ 0> if include-stack-top@ frame-offset @ seek-set include-stack-top@ frame-file seek-file 0 include-buffer-content-len ! read-file-into-buffer then ; 
 : execute-file [: [: read-file-into-buffer ;] fs-lock with-lock include-buffer-content-len @ 0> if 0 include-buffer update-line ['] frame-eval-refill ['] frame-eval-eof evaluate-with-input then ;] try [: unnest-include ;] fs-lock with-lock ?raise ; 
 : list-dir cr ." 1 +to file-name-len then 14 file-name-len - spaces date-time 2 pick create-date-time@ date-time date-time. 2 spaces date-time 2 pick modify-date-time@ date-time date-time. false ;] with-aligned-allot ;] with-allot else 2drop true then until ;] with-aligned-allot ; 
 : list-root <fat32-dir> class-size [: dup current-fs @ root-dir@ list-dir ;] with-aligned-allot ; 
 : list-path <fat32-dir> class-size [: -rot [: 3 pick swap open-dir ;] current-fs @ with-root-path list-dir ;] with-aligned-allot ; 
 : strip-leading-separators begin dup 0<> if over c@ [char] / = if swap 1+ swap 1- false else true then else true then until ; 
 : init-fat32-tools fs-lock init-lock 0 current-fs ! 0 include-buffer-content-len ! 0 frame-depth ! ; 
 : current-fs! current-fs ! ; 
 : current-fs@ current-fs @ ; 
 : load-file current-fs @ averts x-fs-not-set frame-depth @ max-include-depth < averts x-include-stack-overflow [: include-stack-next@ frame-file <fat32-file> class-size move include-stack-next@ frame-file tell-file include-stack-next@ frame-offset ! 1 frame-depth +! 0 include-buffer-content-len ! ;] fs-lock with-lock execute-file ; 
 : included current-fs @ averts x-fs-not-set frame-depth @ max-include-depth < averts x-include-stack-overflow [: [: include-stack-next@ frame-file swap open-file ;] current-fs@ with-root-path 0 include-stack-next@ frame-offset ! 1 frame-depth +! 0 include-buffer-content-len ! ;] fs-lock with-lock execute-file ; 
 : include token dup 0<> averts x-token-expected included ; 
 : list-dir current-fs @ averts x-fs-not-set strip-leading-separators [: dup 0= if 2drop list-root else list-path then ;] fs-lock with-lock ; 
 : create-file current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap create-file ;] current-fs @ with-root-path write-file drop current-fs @ flush ;] with-aligned-allot ;] fs-lock with-lock ; 
 : create-dir current-fs @ averts x-fs-not-set [: <fat32-dir> class-size [: -rot [: 3 roll swap create-dir ;] current-fs @ with-root-path current-fs @ flush ;] with-aligned-allot ;] fs-lock with-lock ; 
 : copy-file current-fs @ averts x-fs-not-set [: 2swap <fat32-file> class-size [: <fat32-file> class-size [: 2swap [: 3 pick swap open-file ;] current-fs @ with-root-path >r -rot [: 3 pick swap fat32::create-file ;] current-fs @ with-root-path r> begin read-buffer read-buffer-size 2 pick read-file dup 0> if read-buffer swap 3 pick write-file drop false else drop true then until 2drop current-fs @ flush ;] with-aligned-allot ;] with-aligned-allot ;] fs-lock with-lock ; 
 : append-file current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path 0 seek-end 2 pick seek-file write-file drop current-fs @ flush ;] with-aligned-allot ;] fs-lock with-lock ; 
 : write-file-window current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path >r seek-set r@ seek-file r> write-file drop current-fs @ flush ;] with-aligned-allot ;] fs-lock with-lock ; 
 : write-file current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path dup >r write-file drop r> truncate-file current-fs @ flush ;] with-aligned-allot ;] fs-lock with-lock ; 
 : dump-file-raw current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path begin read-buffer read-buffer-size 2 pick read-file dup 0> if read-buffer swap type false else drop true then until drop ;] with-aligned-allot ;] fs-lock with-lock ; 
 : dump-file-raw-window current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path >r swap seek-set r@ seek-file r> begin read-buffer read-buffer-size 3 pick min 2 pick read-file dup 0> if rot over - -rot read-buffer swap type over 0= else drop true then until 2drop ;] with-aligned-allot ;] fs-lock with-lock ; 
 : dump-file current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path cr begin dup tell-file >r read-buffer read-buffer-size 0 fill read-buffer read-buffer-size 2 pick read-file dup 0> if read-buffer swap r> dump-with-offset false else rdrop drop true then until drop ;] with-aligned-allot ;] fs-lock with-lock ; 
 : dump-file-window current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path >r swap seek-set r@ seek-file r> cr begin dup tell-file >r read-buffer read-buffer-size 0 fill read-buffer read-buffer-size 3 pick min 2 pick read-file dup 0> if rot over - -rot read-buffer swap r> dump-with-offset over 0= else rdrop drop true then until 2drop ;] with-aligned-allot ;] fs-lock with-lock ; 
 : dump-file-ascii current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path cr begin dup tell-file >r read-buffer read-buffer-size 0 fill read-buffer read-buffer-size 2 pick read-file dup 0> if read-buffer swap r> dump-ascii-with-offset false else rdrop drop true then until drop ;] with-aligned-allot ;] fs-lock with-lock ; 
 : dump-file-ascii-window current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path >r swap seek-set r@ seek-file r> cr begin dup tell-file >r read-buffer read-buffer-size 0 fill read-buffer read-buffer-size 3 pick min 2 pick read-file dup 0> if rot over - -rot read-buffer swap r> dump-ascii-with-offset over 0= else rdrop drop true then until 2drop ;] with-aligned-allot ;] fs-lock with-lock ; 
 : dump-file-halfs current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path cr begin dup tell-file >r read-buffer read-buffer-size 0 fill read-buffer read-buffer-size 2 pick read-file dup 0> if read-buffer swap 1 bic r> dump-halfs-with-offset false else rdrop drop true then until drop ;] with-aligned-allot ;] fs-lock with-lock ; 
 : dump-file-halfs-window current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path >r swap seek-set r@ seek-file r> cr begin dup tell-file >r read-buffer read-buffer-size 0 fill read-buffer read-buffer-size 3 pick min 2 pick read-file dup 0> if rot over - -rot read-buffer swap 1 bic r> dump-halfs-with-offset over 0= else rdrop drop true then until 2drop ;] with-aligned-allot ;] fs-lock with-lock ; 
 : dump-file-cells current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path cr begin dup tell-file >r read-buffer read-buffer-size 0 fill read-buffer read-buffer-size 2 pick read-file dup 0> if read-buffer swap 3 bic r> dump-cells-with-offset false else rdrop drop true then until drop ;] with-aligned-allot ;] fs-lock with-lock ; 
 : dump-file-cells-window current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path >r swap seek-set r@ seek-file r> cr begin dup tell-file >r read-buffer read-buffer-size 0 fill read-buffer read-buffer-size 3 pick min 2 pick read-file dup 0> if rot over - -rot read-buffer swap 3 bic r> dump-cells-with-offset over 0= else rdrop drop true then until 2drop ;] with-aligned-allot ;] fs-lock with-lock ; 
 : read-file current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path >r seek-set r@ seek-file r> read-file ;] with-aligned-allot ;] fs-lock with-lock ; 
 : file-size@ current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: -rot [: 3 pick swap open-file ;] current-fs @ with-root-path file-size@ ;] with-aligned-allot ;] fs-lock with-lock ; 
 : remove-file current-fs @ averts x-fs-not-set [: ['] remove-file current-fs @ with-root-path current-fs @ flush ;] fs-lock with-lock ; 
 : remove-dir current-fs @ averts x-fs-not-set [: ['] remove-dir current-fs @ with-root-path current-fs @ flush ;] fs-lock with-lock ; 
 : rename current-fs @ averts x-fs-not-set 2swap [: ['] rename current-fs @ with-root-path current-fs @ flush ;] fs-lock with-lock ; 
 : exists? current-fs @ averts x-fs-not-set [: current-fs @ root-path-exists? ;] fs-lock with-lock ; 
 : file? current-fs @ averts x-fs-not-set [: ['] file? current-fs @ with-root-path ;] fs-lock with-lock ; 
 : dir? current-fs @ averts x-fs-not-set [: ['] dir? current-fs @ with-root-path ;] fs-lock with-lock ; 
 : with-file-input current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: 2swap [: 3 pick swap open-file ;] current-fs @ with-root-path swap with-file-input ;] with-aligned-allot ;] fs-lock with-lock ; 
 : with-file-output current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: 2swap [: 3 pick swap open-file ;] current-fs @ with-root-path swap with-file-output ;] with-aligned-allot ;] fs-lock with-lock ; 
 : with-file-error-output current-fs @ averts x-fs-not-set [: <fat32-file> class-size [: 2swap [: 3 pick swap open-file ;] current-fs @ with-root-path swap with-file-error-output ;] with-aligned-allot ;] fs-lock with-lock ; 
 : my-task-count constant ; 
 : producer 0 begin dup cr ." . dup [: my-fchan send-fchan ;] provide-allot-cell 1+ 500 ms again ; 
 : consumer begin [: my-fchan recv-fchan ;] extract-allot-cell cr ." . again ; 
 : closer 8000 ms my-fchan close-fchan ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : closer-task variable ; 
 : init-test 420 128 512 my-task-count my-task-pool init-task-pool my-fchan init-fchan 0 ['] producer my-task-pool spawn-from-task-pool producer-task ! 0 ['] consumer my-task-pool spawn-from-task-pool consumer-task ! 0 ['] closer my-task-pool spawn-from-task-pool closer-task ! producer-task @ run consumer-task @ run closer-task @ run pause ; 
 : init-fchan-queue 0 over fchan-queue-first ! 0 swap fchan-queue-last ! ; 
 : find-fchan-queue-next ; 
 : push-fchan-queue then ; 
 : pop-fchan-queue then ; 
 : remove-fchan-queue ; 
 : wake-all-fchan-queue >r r@ fchan-queue-first @ begin ?dup while up fchan-wait-task @ ready chan-wait-prev @ repeat 0 r@ fchan-queue-first ! 0 r> fchan-queue-last ! ; 
 : x-fchan-closed ." cr ; 
 : init-fchan dup fchan-slock init-slock false over fchan-closed ! dup fchan-send-queue init-fchan-queue fchan-recv-queue init-fchan-queue ; 
 : send-fchan hen ;] with-aligned-allot then s" trace ; 
 : recv-fchan hen ;] with-aligned-allot then s" trace ; 
 : close-fchan [: >r true r@ fchan-closed ! r@ fchan-send-queue wake-all-fchan-queue r> fchan-recv-queue wake-all-fchan-queue ;] over fchan-slock with-slock ; 
 : fchan-closed? fchan-closed @ ; 
 : reopen-fchan [: true swap fchan-closed ! ;] over fchan-slock with-slock ; 
 : consumer cr ." type again ; 
 : do-producer does> @ execute dup current-task task-name! cr ." dup count type again ; 
 : make-producer s" <builds-with-name , do-producer 0 latest >body 420 128 512 spawn constant ; 
 : init-test my-fchan init-fchan consumer-task run producer-a-task run producer-b-task run producer-c-task run pause ; 
 : consumer begin 1000 timeout ! [: my-fchan recv-fchan ;] extract-allot-cell [: space ." . ;] my-lock with-lock again ; 
 : producer 0 begin [: space ." dup . ;] my-lock with-lock 1+ again ; 
 : consumer-task variable ; 
 : producer-a-task variable ; 
 : producer-b-task variable ; 
 : producer-c-task variable ; 
 : consumer begin [: my-fchan recv-fchan ;] extract-allot-cell [: cr ." . ;] my-lock with-lock again ; 
 : producer begin [: cr ." dup . ;] my-lock with-lock dup [: my-fchan send-fchan ;] provide-allot-cell again ; 
 : init-test my-fchan init-fchan my-lock init-lock 0 ['] consumer 420 128 512 spawn consumer-task ! 0 1 ['] producer 420 128 512 spawn producer-a-task ! 1 1 ['] producer 420 128 512 spawn producer-b-task ! 2 1 ['] producer 420 128 512 spawn producer-c-task ! consumer-task @ run producer-a-task @ run producer-b-task @ run producer-c-task @ run pause ; 
 : consumer-task variable ; 
 : producer-task variable ; 
 : consumer begin [: my-fchan recv-fchan ;] extract-allot-cell drop again ; 
 : producer 0 begin dup [: my-fchan send-fchan ;] provide-allot-cell 1+ again ; 
 : init-test my-fchan init-fchan 0 consumer-task ! 0 ['] consumer 420 128 512 1 spawn-on-core consumer-task ! 0 ['] producer 420 128 512 spawn producer-task ! c" producer-task @ task-name! consumer-task @ run producer-task @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms 0 [: my-fchan send-fchan ;] provide-allot-cell cr ." ; 
 : do-task-3 no-timeout timeout ! 50 ms 0 [: my-fchan send-fchan ;] provide-allot-cell cr ." ; 
 : do-task-4 no-timeout timeout ! 75 ms 0 [: my-fchan send-fchan ;] provide-allot-cell cr ." ; 
 : init-test my-fchan init-fchan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! 0 ['] do-task-4 420 128 512 spawn my-task-4 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run my-task-4 @ run ; 
 : high-task variable ; 
 : low-task variable ; 
 : high begin ." again ; 
 : low begin [: my-out-fchan recv-fchan ;] extract-allot-cell drop ." 0 [: my-in-fchan send-fchan ;] provide-allot-cell again ; 
 : init-test my-out-fchan init-fchan my-in-fchan init-fchan 0 ['] high 420 128 512 spawn high-task ! 0 ['] low 420 128 512 spawn low-task ! 1 high-task @ task-priority! 0 low-task @ task-priority! begin-critical high-task @ run low-task @ run end-critical ; 
 : consumer-task variable ; 
 : producer-task variable ; 
 : consumer begin [: my-fchan recv-fchan ;] extract-allot-cell cr ." . again ; 
 : producer 0 begin dup [: my-fchan send-fchan ;] provide-allot-cell 1+ again ; 
 : init-test my-fchan init-fchan 0 consumer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! 0 ['] producer 420 128 512 1 spawn-on-core producer-task ! c" producer-task @ task-name! consumer-task @ run producer-task @ run ; 
 : consumer-task variable ; 
 : producer-task variable ; 
 : consumer begin 999 begin : my-fchan recv-fchan ;] extract-allot-cell drop 1- dup 0= until drop [: my-fchan recv-fchan ;] extract-allot-cell cr ." . again ; 
 : producer 0 begin dup [: my-fchan send-fchan ;] provide-allot-cell 1+ again ; 
 : init-test my-fchan init-fchan 0 consumer-task ! 0 ['] consumer 512 128 512 1 spawn-on-core consumer-task ! 0 ['] producer 512 128 512 spawn producer-task ! c" producer-task @ task-name! consumer-task @ run producer-task @ run ; 
 : consumer-task variable ; 
 : producer-task variable ; 
 : consumer begin [: my-fchan recv-fchan ;] extract-allot-cell cr ." . again ; 
 : producer 0 begin dup [: my-fchan send-fchan ;] provide-allot-cell cr ." dup . 1+ again ; 
 : init-test my-fchan init-fchan 0 ['] consumer 420 128 512 spawn consumer-task ! 0 ['] producer 420 128 512 spawn producer-task ! c" producer-task @ task-name! consumer-task @ run producer-task @ run ; 
 : consumer begin [: my-fchan recv-fchan ;] extract-allot-cell drop again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer begin 0 [: my-fchan send-fchan ;] provide-allot-cell 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : consumer-task variable ; 
 : producer-task variable ; 
 : init-test 0 send-count ! systick-counter start-systick ! my-fchan init-fchan 0 ['] consumer 420 128 512 1 spawn-on-core consumer-task ! 0 ['] producer 420 128 512 spawn producer-task ! consumer-task @ run producer-task @ run pause ; 
 : consumer begin [: my-fchan recv-fchan ;] extract-allot-cell drop again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer begin 0 [: my-fchan send-fchan ;] provide-allot-cell 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! my-fchan init-fchan consumer-task run producer-task run pause ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 5000 timeout ! 25 ms 0 [: my-fchan send-fchan ;] provide-allot-cell cr ." ; 
 : do-task-3 no-timeout timeout ! 50 ms 0 [: my-fchan send-fchan ;] provide-allot-cell cr ." ; 
 : init-test my-fchan init-fchan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms 0 [: my-fchan send-fchan ;] provide-allot-cell cr ." ; 
 : do-task-3 5000 timeout ! 50 ms 0 [: my-fchan send-fchan ;] provide-allot-cell cr ." ; 
 : init-test my-fchan init-fchan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms [: my-fchan recv-fchan ;] extract-allot-cell cr ." . ; 
 : do-task-3 5000 timeout ! 50 ms [: my-fchan recv-fchan ;] extract-allot-cell cr ." . ; 
 : do-task-4 no-timeout timeout ! 75 ms [: my-fchan recv-fchan ;] extract-allot-cell cr ." . ; 
 : init-test my-fchan init-fchan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! 0 ['] do-task-4 420 128 512 spawn my-task-4 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run my-task-4 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 5000 timeout ! 25 ms [: my-fchan recv-fchan ;] extract-allot-cell cr ." . ; 
 : do-task-3 no-timeout timeout ! 50 ms [: my-fchan recv-fchan ;] extract-allot-cell cr ." . ; 
 : init-test my-fchan init-fchan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms [: my-fchan recv-fchan ;] extract-allot-cell cr ." . ; 
 : do-task-3 5000 timeout ! 50 ms [: my-fchan recv-fchan ;] extract-allot-cell cr ." . ; 
 : init-test my-fchan init-fchan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms 0 [: my-fchan send-fchan ;] provide-allot-cell cr ." ; 
 : do-task-3 5000 timeout ! 50 ms 0 [: my-fchan send-fchan ;] provide-allot-cell cr ." ; 
 : do-task-4 no-timeout timeout ! 75 ms 0 [: my-fchan send-fchan ;] provide-allot-cell cr ." ; 
 : init-test my-fchan init-fchan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! 0 ['] do-task-4 420 128 512 spawn my-task-4 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run my-task-4 @ run ; 
 : consumer 0 begin [: my-fchan recv-fchan ;] extract-allot-cell 2dup <> if r ." dup . else rop then 1+ pause again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer 0 begin dup [: my-fchan send-fchan ;] provide-allot-cell 1+ 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! my-fchan init-fchan consumer-task run producer-task run pause ; 
 : task-index cpu-index 2 * + ; 
 : producer >r r@ current-task task-priority! r@ 500 * ms begin dup begin ?dup while @ task-index [: my-fchan send-fchan ;] provide-allot-cell 1- repeat r@ task-index (.) ." over ms again ; 
 : consumer >r r@ current-task task-priority! r@ 1+ 500 * ms begin dup begin ?dup while : my-fchan recv-fchan ;] extract-allot-cell drop 1- repeat ." r@ task-index . over ms again ; 
 : init-test my-fchan init-fchan 3 current-task task-priority! 333 1000 0 3 ['] producer 420 128 512 0 spawn-on-core run 500 1000 0 3 ['] consumer 420 128 512 0 spawn-on-core run 333 1000 0 3 ['] producer 420 128 512 1 spawn-on-core run 500 1000 0 3 ['] consumer 420 128 512 1 spawn-on-core run 333 1000 1 3 ['] producer 420 128 512 0 spawn-on-core run 500 1000 1 3 ['] consumer 420 128 512 0 spawn-on-core run 333 1000 1 3 ['] producer 420 128 512 1 spawn-on-core run 500 1000 1 3 ['] consumer 420 128 512 1 spawn-on-core run 0 current-task task-priority! ; 
 : task-counts-current variable ; 
 : task-index cpu-index 2 * + ; 
 : producer-count+ 1 swap task-index cells task-counts-current @ + +! ; 
 : consumer-count+ 1 swap task-index 4 + cells task-counts-current @ + +! ; 
 : swap-counts task-counts-current @ task-counts = if task-counts 8 cells + else task-counts then dup 8 cells 0 fill task-counts-current ! ; 
 : print-counts task-counts-current @ swap-counts cr ." 7 cells + @ . ; 
 : output 3 current-task task-priority! begin 1000 ms print-counts again ; 
 : producer >r r@ current-task task-priority! r@ 500 * ms begin dup begin ?dup while @ task-index [: my-fchan send-fchan ;] provide-allot-cell 1- @ producer-count+ repeat over ms again ; 
 : consumer >r r@ current-task task-priority! r@ 1+ 500 * ms begin dup begin ?dup while : my-fchan recv-fchan ;] extract-allot-cell drop 1- @ consumer-count+ repeat over ms again ; 
 : init-test task-counts 16 cells 0 fill task-counts task-counts-current ! my-fchan init-fchan 4 current-task task-priority! 0 ['] output 420 128 512 0 spawn-on-core run 333 1000 0 3 ['] producer 420 128 512 0 spawn-on-core run 500 1000 0 3 ['] consumer 420 128 512 0 spawn-on-core run 333 1000 0 3 ['] producer 420 128 512 1 spawn-on-core run 500 1000 0 3 ['] consumer 420 128 512 1 spawn-on-core run 333 1000 1 3 ['] producer 420 128 512 0 spawn-on-core run 500 1000 1 3 ['] consumer 420 128 512 0 spawn-on-core run 333 1000 1 3 ['] producer 420 128 512 1 spawn-on-core run 500 1000 1 3 ['] consumer 420 128 512 1 spawn-on-core run 0 current-task task-priority! ; 
 : task-index cpu-index 4 * + ; 
 : producer >r r@ current-task task-priority! r@ 500 * ms begin dup begin ?dup while @ task-index [: my-fchan send-fchan ;] provide-allot-cell 1- repeat over ms again ; 
 : consumer >r r@ current-task task-priority! r@ 1+ 500 * ms begin dup begin ?dup while : my-fchan recv-fchan ;] extract-allot-cell @ task-index (.) ." . 1- repeat over ms again ; 
 : init-test my-fchan init-fchan 3 current-task task-priority! 1000 3000 0 3 ['] producer 420 128 512 0 spawn-on-core run 1500 2000 0 3 ['] consumer 420 128 512 0 spawn-on-core run 1000 3000 0 3 ['] producer 420 128 512 1 spawn-on-core run 1500 2000 0 3 ['] consumer 420 128 512 1 spawn-on-core run 1000 3000 1 3 ['] producer 420 128 512 0 spawn-on-core run 1500 3000 1 3 ['] consumer 420 128 512 0 spawn-on-core run 1000 3000 1 3 ['] producer 420 128 512 1 spawn-on-core run 1500 3000 1 3 ['] consumer 420 128 512 1 spawn-on-core run 0 current-task task-priority! ; 
 : producer >r r@ current-task task-priority! begin dup begin ?dup while @ [: my-fchan send-fchan ;] provide-allot-cell 1- repeat over ms again ; 
 : consumer >r r@ current-task task-priority! begin dup begin ?dup while : my-fchan recv-fchan ;] extract-allot-cell r@ (.) ." . 1- repeat over ms again ; 
 : init-test my-fchan init-fchan 1000 3000 1 3 ['] producer 420 128 512 spawn run 1000 3000 0 3 ['] producer 420 128 512 spawn run 1500 3000 1 3 ['] consumer 420 128 512 spawn run 1500 2000 0 3 ['] consumer 420 128 512 spawn run ; 
 : my-task-count constant ; 
 : consumer begin [: my-fchan recv-fchan ;] extract-allot-cell cr ." . again ; 
 : closer 2000 ms my-fchan close-fchan ; 
 : consumer-task variable ; 
 : closer-task variable ; 
 : init-test 420 128 512 my-task-count my-task-pool init-task-pool my-fchan init-fchan 0 ['] consumer my-task-pool spawn-from-task-pool consumer-task ! 0 ['] closer my-task-pool spawn-from-task-pool closer-task ! consumer-task @ run closer-task @ run pause ; 
 : my-task-count constant ; 
 : producer 0 begin dup cr ." . dup [: my-fchan send-fchan ;] provide-allot-cell 1+ 500 ms again ; 
 : closer 2000 ms my-fchan close-fchan ; 
 : producer-task variable ; 
 : closer-task variable ; 
 : init-test 420 128 512 my-task-count my-task-pool init-task-pool my-fchan init-fchan 0 ['] producer my-task-pool spawn-from-task-pool producer-task ! 0 ['] closer my-task-pool spawn-from-task-pool closer-task ! producer-task @ run closer-task @ run pause ; 
 : task-index cpu-index 2 * + ; 
 : producer dup current-task task-priority! dup 1+ 500 * ms task-index 1 begin 2dup [: my-fchan send-fchan ;] provide-allot-2cell 1+ again ; 
 : consumer dup current-task task-priority! 1+ 500 * ms 4 cells [: dup 4 cells 0 fill begin 000 0 ?do [: my-fchan recv-fchan ;] extract-allot-2cell 2 pick 2 pick cells + 2dup @ <= if ." again ;] with-aligned-allot ; 
 : init-test my-fchan init-fchan 3 current-task task-priority! 0 1 ['] producer 420 128 512 0 spawn-on-core run 0 1 ['] consumer 420 128 512 0 spawn-on-core run 0 1 ['] producer 420 128 512 1 spawn-on-core run 0 1 ['] consumer 420 128 512 1 spawn-on-core run 1 1 ['] producer 420 128 512 0 spawn-on-core run 1 1 ['] consumer 420 128 512 0 spawn-on-core run 1 1 ['] producer 420 128 512 1 spawn-on-core run 1 1 ['] consumer 420 128 512 1 spawn-on-core run 0 current-task task-priority! ; 
 : fibonacci 0 0 rot 1 0 rot 1 ?do 2dup 2>r d+ 2r> 2swap loop 2swap 2drop ; 
 : fibonacci-time systick-counter over 0 ?do 2 pick fibonacci 2drop loop 0 swap systick-counter 0 swap 2swap d- rot 0 swap f/ rot drop 10000,0 f/ ; 
 : max-file-object-size constant ; 
 : x-entity-not-found ." cr ; 
 : x-entity-already-exists ." cr ; 
 : x-root-directory ." cr ; 
 : x-read-only ." cr ; 
 : x-file-closed ." cr ; 
 : seek-set constant ; 
 : seek-cur constant ; 
 : seek-end constant ; 
 : path-element-count 1 begin over while 2 pick c@ [char] / = if 1+ then rot 1+ rot 1- rot repeat nip nip ; 
 : with-2array swap 2 * cells swap with-aligned-allot ; 
 : find-end-path-part 0 begin over 0> if 1+ swap 1- swap rot 1+ -rot 2 pick 1- c@ [char] / = else true then until nip nip ; 
 : strip-end-slash over >r dup 0> if dup 1- rot + c@ [char] / = if 1- then else 2drop 0 then r> swap ; 
 : process-path-part over 0= if dup 0= if 1 else 0 then nip nip nip else -rot 2dup s" equal-strings? if dup 0<> averts x-entity-not-found 1- else 1+ then then then ; 
 : populate-path-part ; 
 : with-compressed-path drop swap 2>r 2drop drop nip nip 2r> rot execute ;] with-2array ; 
 : 2array-last 1- 2 * cells + 2@ ; 
 : with-lookup-path execute else ['] x-entity-not-found ?raise then ;] with-compressed-path ;] file-lock with-lock ; 
 : with-concat-path rot execute ;] with-allot ; 
 : init-files file-object-pool-size file-object-pool init-temp file-lock init-lock ; 
 : init-test 0 [: 0 [: begin 500 ms ." again ;] 420 128 512 1 spawn-on-core run ; 
 : sqrt-close-enough 4dup d- 2rot dabs 2rot dabs dmax f/ dabs 2 0 d< ; 
 : sqrt-better-guess 2dup 2rot 2rot f/ d+ 2 0 d/ ; 
 : char-count >r 0 begin over 0<> while rot dup c@ r@ = if + -rot 1+ else + -rot then swap 1- swap repeat nip nip rdrop ; 
 : handle-double >r over c@ [char] . <> if 0 0 begin 2 pick 0<> while pick c@ r@ parse-digit if rot rot r@ 0 ud* rot 0 d+ lse drop 3 pick c@ [char] . <> if 2drop 2drop rdrop false exit then hen swap 1- swap 1+ swap 2swap repeat 2swap 2drop rdrop true else rdrop 2drop false then ; 
 : get-max-fraction-chars >r 1 0 0 begin -rot r@ 0 ud* 2dup 0 1 d> if drop rdrop true else ot 1+ false then until ; 
 : build-max-fraction-chars 37 2 ?do i get-max-fraction-chars , loop ; 
 : handle-fraction >r rot max-fraction-chars r@ 2 - cells + @ min -rot 2swap 0 0 0 begin 3 pick 0<> while 4 pick c@ r@ parse-digit if swap r@ 0 ud* rot 0 d+ rot 1+ >r >r >r 1- swap 1+ swap r> r> r> else rop 2drop 2drop 2drop rdrop false exit then repeat nip 0 -rot 0 r> rot 0 swap f** f/ 2swap 2drop d+ true ; 
 : handle-fixed >r over c@ dup [char] . <> swap [char] , <> and if 2dup + 1- c@ dup [char] . <> swap [char] , <> and if begin over 0<> while 2 pick c@ r@ parse-digit if swap r@ * + rot 1+ rot 1- rot else drop 2 pick c@ dup [char] . = swap [char] , = or if rot 1+ rot 1- rot 0 swap r> handle-fraction exit else drop 2drop rdrop false exit then then epeat ip nip 0 swap rdrop true else drop 2drop false then else rdrop 2drop false then ; 
 : handle-unsigned-double >r 2dup [char] . char-count 1 = if r> handle-double else 2dup [char] , char-count 1 = if > handle-fixed else drop 2drop false then then ; 
 : do-handle-number 2dup do-handle-number if state @ not if rot rot then 2drop true else parse-base >r dup 0<> if over c@ [char] - = if 1- swap 1+ swap dup 0<> if r> handle-unsigned-double else rdrop 2drop false then dup if state @ if rot rot dnegate swap lit, lit, else rot rot dnegate rot then then else r> handle-unsigned-double dup if state @ if rot lit, swap lit, then then then else rdrop 2drop false then then ; 
 : x-out-of-range-char ." cr ; 
 : font-buf-size { char-cols char-rows min-char max-char -- bytes } char-cols max-char min-char - 1+ * char-rows bitmap-buf-size ; 
 : find-char-col { c self -- col } c self min-char-index @ - self char-cols @ * ; 
 : IO_BANK0_BASE constant ; 
 : PADS_BANK0_BASE constant ; 
 : SIO_BASE constant ; 
 : GPIO_STATUS 3 lshift IO_BANK0_BASE + ; 
 : GPIO_CTRL 3 lshift [ IO_BANK0_BASE 4 + ] literal + ; 
 : PAD 2 lshift [ PADS_BANK0_BASE 4 + ] literal + ; 
 : LEVEL_LOW constant ; 
 : LEVEL_HIGH constant ; 
 : EDGE_LOW constant ; 
 : EDGE_HIGH constant ; 
 : CTRL_NORMAL constant ; 
 : CTRL_INVERT constant ; 
 : CTRL_FORCE_LOW constant ; 
 : CTRL_FORCE_HIGH constant ; 
 : VOLTAGE_3.3V constant ; 
 : VOLTAGE_1.8V constant ; 
 : DRIVE_2MA constant ; 
 : DRIVE_4MA constant ; 
 : DRIVE_8MA constant ; 
 : DRIVE_12MA constant ; 
 : PAD_SWCLK constant ; 
 : PAD_SWD constant ; 
 : GPIO_STATUS_IRQTOPROC@ 26 bit swap GPIO_STATUS bit@ ; 
 : GPIO_STATUS_IRQFROMPAD@ 24 bit swap GPIO_STATUS bit@ ; 
 : GPIO_STATUS_INTOPERI@ 19 bit swap GPIO_STATUS bit@ ; 
 : GPIO_STATUS_INFROMPAD@ 17 bit swap GPIO_STATUS bit@ ; 
 : GPIO_STATUS_OETOPAD@ 13 bit swap GPIO_STATUS bit@ ; 
 : GPIO_STATUS_OEFROMPERI@ 12 bit swap GPIO_STATUS bit@ ; 
 : GPIO_STATUS_OUTTOPAD@ 9 bit swap GPIO_STATUS bit@ ; 
 : GPIO_STATUS_OUTFROMPERI@ 8 bit swap GPIO_STATUS bit@ ; 
 : GPIO_CTRL_IRQOVER! GPIO_CTRL dup @ [ 3 28 lshift ] literal bic rot 3 and 28 lshift or swap ! ; 
 : GPIO_CTRL_INOVER! GPIO_CTRL dup @ [ 3 16 lshift ] literal bic rot 3 and 16 lshift or swap ! ; 
 : GPIO_CTRL_OEOVER! GPIO_CTRL dup @ [ 3 12 lshift ] literal bic rot 3 and 12 lshift or swap ! ; 
 : GPIO_CTRL_OUTOVER! GPIO_CTRL dup @ [ 3 8 lshift ] literal bic rot 3 and 8 lshift or swap ! ; 
 : GPIO_CTRL_FUNCSEL! GPIO_CTRL dup @ $1F bic rot $1F and or swap ! ; 
 : GPIO_CTRL_IRQOVER@ GPIO_CTRL @ 28 rshift 3 and ; 
 : GPIO_CTRL_INOVER@ GPIO_CTRL @ 16 rshift 3 and ; 
 : GPIO_CTRL_OEOVER@ GPIO_CTRL @ 12 rshift 3 and ; 
 : GPIO_CTRL_OUTOVER@ GPIO_CTRL @ 8 rshift 3 and ; 
 : GPIO_CTRL_FUNCSEL@ GPIO_CTRL @ $1F and ; 
 : INTR_GPIO_EDGE_LOW! dup 7 and 2 lshift 2 + bit swap 1 rshift $c and INTR0 + ! ; 
 : INTR_GPIO_EDGE_HIGH! dup 7 and 2 lshift 3 + bit swap 1 rshift $c and INTR0 + ! ; 
 : INTR_GPIO_LEVEL_LOW@ dup 7 and 2 lshift bit swap 1 rshift $c and INTR0 + bit@ ; 
 : INTR_GPIO_LEVEL_HIGH@ dup 7 and 2 lshift 1 + bit swap 1 rshift $c and INTR0 + bit@ ; 
 : INTR_GPIO_EDGE_LOW@ dup 7 and 2 lshift 2 + bit swap 1 rshift $c and INTR0 + bit@ ; 
 : INTR_GPIO_EDGE_HIGH@ dup 7 and 2 lshift 3 + bit swap 1 rshift $c and INTR0 + bit@ ; 
 : PROC0_INTE_GPIO_LEVEL_LOW! dup 7 and 2 lshift bit swap 1 rshift $c and PROC0_INTE0 + rot if bis! else bic! then ; 
 : PROC0_INTE_GPIO_LEVEL_HIGH! dup 7 and 2 lshift 1 + bit swap 1 rshift $c and PROC0_INTE0 + rot if bis! else bic! then ; 
 : PROC0_INTE_GPIO_EDGE_LOW! dup 7 and 2 lshift 2 + bit swap 1 rshift $c and PROC0_INTE0 + rot if bis! else bic! then ; 
 : PROC0_INTE_GPIO_EDGE_HIGH! dup 7 and 2 lshift 3 + bit swap 1 rshift $c and PROC0_INTE0 + rot if bis! else bic! then ; 
 : PROC0_INTE_GPIO_LEVEL_LOW@ dup 7 and 2 lshift bit swap 1 rshift $c and PROC0_INTE0 + bit@ ; 
 : PROC0_INTE_GPIO_LEVEL_HIGH@ dup 7 and 2 lshift 1 + bit swap 1 rshift $c and PROC0_INTE0 + bit@ ; 
 : PROC0_INTE_GPIO_EDGE_LOW@ dup 7 and 2 lshift 2 + bit swap 1 rshift $c and PROC0_INTE0 + bit@ ; 
 : PROC0_INTE_GPIO_EDGE_HIGH@ dup 7 and 2 lshift 3 + bit swap 1 rshift $c and PROC0_INTE0 + bit@ ; 
 : PROC0_INTF_GPIO_LEVEL_LOW! dup 7 and 2 lshift bit swap 1 rshift $c and PROC0_INTF0 + rot if bis! else bic! then ; 
 : PROC0_INTF_GPIO_LEVEL_HIGH! dup 7 and 2 lshift 1 + bit swap 1 rshift $c and PROC0_INTF0 + rot if bis! else bic! then ; 
 : PROC0_INTF_GPIO_EDGE_LOW! dup 7 and 2 lshift 2 + bit swap 1 rshift $c and PROC0_INTF0 + rot if bis! else bic! then ; 
 : PROC0_INTF_GPIO_EDGE_HIGH! dup 7 and 2 lshift 3 + bit swap 1 rshift $c and PROC0_INTF0 + rot if bis! else bic! then ; 
 : PROC0_INTF_GPIO_LEVEL_LOW@ dup 7 and 2 lshift bit swap 1 rshift $c and PROC0_INTF0 + bit@ ; 
 : PROC0_INTS_GPIO_LEVEL_HIGH@ dup 7 and 2 lshift 1 + bit swap 1 rshift $c and PROC0_INTF0 + bit@ ; 
 : PROC0_INTF_GPIO_EDGE_LOW@ dup 7 and 2 lshift 2 + bit swap 1 rshift $c and PROC0_INTF0 + bit@ ; 
 : PROC0_INTF_GPIO_EDGE_HIGH@ dup 7 and 2 lshift 3 + bit swap 1 rshift $c and PROC0_INTF0 + bit@ ; 
 : PROC0_INTS_GPIO_LEVEL_LOW@ dup 7 and 2 lshift bit swap 1 rshift $c and PROC0_INTS0 + bit@ ; 
 : PROC0_INTS_GPIO_LEVEL_HIGH@ dup 7 and 2 lshift 1 + bit swap 1 rshift $c and PROC0_INTS0 + bit@ ; 
 : PROC0_INTS_GPIO_EDGE_LOW@ dup 7 and 2 lshift 2 + bit swap 1 rshift $c and PROC0_INTS0 + bit@ ; 
 : PROC0_INTS_GPIO_EDGE_HIGH@ dup 7 and 2 lshift 3 + bit swap 1 rshift $c and PROC0_INTS0 + bit@ ; 
 : PROC1_INTE_GPIO_LEVEL_LOW! dup 7 and 2 lshift bit swap 1 rshift $c and PROC1_INTE0 + rot if bis! else bic! then ; 
 : PROC1_INTE_GPIO_LEVEL_HIGH! dup 7 and 2 lshift 1 + bit swap 1 rshift $c and PROC1_INTE0 + rot if bis! else bic! then ; 
 : PROC1_INTE_GPIO_EDGE_LOW! dup 7 and 2 lshift 2 + bit swap 1 rshift $c and PROC1_INTE0 + rot if bis! else bic! then ; 
 : PROC1_INTE_GPIO_EDGE_HIGH! dup 7 and 2 lshift 3 + bit swap 1 rshift $c and PROC1_INTE0 + rot if bis! else bic! then ; 
 : PROC1_INTE_GPIO_LEVEL_LOW@ dup 7 and 2 lshift bit swap 1 rshift $c and PROC1_INTE0 + bit@ ; 
 : PROC1_INTE_GPIO_LEVEL_HIGH@ dup 7 and 2 lshift 1 + bit swap 1 rshift $c and PROC1_INTE0 + bit@ ; 
 : PROC1_INTE_GPIO_EDGE_LOW@ dup 7 and 2 lshift 2 + bit swap 1 rshift $c and PROC1_INTE0 + bit@ ; 
 : PROC1_INTE_GPIO_EDGE_HIGH@ dup 7 and 2 lshift 3 + bit swap 1 rshift $c and PROC1_INTE0 + bit@ ; 
 : PROC1_INTF_GPIO_LEVEL_LOW! dup 7 and 2 lshift bit swap 1 rshift $c and PROC1_INTF0 + rot if bis! else bic! then ; 
 : PROC1_INTF_GPIO_LEVEL_HIGH! dup 7 and 2 lshift 1 + bit swap 1 rshift $c and PROC1_INTF0 + rot if bis! else bic! then ; 
 : PROC1_INTF_GPIO_EDGE_LOW! dup 7 and 2 lshift 2 + bit swap 1 rshift $c and PROC1_INTF0 + rot if bis! else bic! then ; 
 : PROC1_INTF_GPIO_EDGE_HIGH! dup 7 and 2 lshift 3 + bit swap 1 rshift $c and PROC1_INTF0 + rot if bis! else bic! then ; 
 : PROC1_INTF_GPIO_LEVEL_LOW@ dup 7 and 2 lshift bit swap 1 rshift $c and PROC1_INTF0 + bit@ ; 
 : PROC1_INTS_GPIO_LEVEL_HIGH@ dup 7 and 2 lshift 1 + bit swap 1 rshift $c and PROC1_INTF0 + bit@ ; 
 : PROC1_INTF_GPIO_EDGE_LOW@ dup 7 and 2 lshift 2 + bit swap 1 rshift $c and PROC1_INTF0 + bit@ ; 
 : PROC1_INTF_GPIO_EDGE_HIGH@ dup 7 and 2 lshift 3 + bit swap 1 rshift $c and PROC1_INTF0 + bit@ ; 
 : PROC1_INTS_GPIO_LEVEL_LOW@ dup 7 and 2 lshift bit swap 1 rshift $c and PROC1_INTS0 + bit@ ; 
 : PROC1_INTS_GPIO_LEVEL_HIGH@ dup 7 and 2 lshift 1 + bit swap 1 rshift $c and PROC1_INTS0 + bit@ ; 
 : PROC1_INTS_GPIO_EDGE_LOW@ dup 7 and 2 lshift 2 + bit swap 1 rshift $c and PROC1_INTS0 + bit@ ; 
 : PROC1_INTS_GPIO_EDGE_HIGH@ dup 7 and 2 lshift 3 + bit swap 1 rshift $c and PROC1_INTS0 + bit@ ; 
 : PADS_BANK0_VOLTAGE_SELECT! 1 and PADS_BANK0_VOLTAGE_SELECT ! ; 
 : PADS_BANK0_VOLTAGE_SELECT@ PADS_BANK0_VOLTAGE_SELECT @ 1 and ; 
 : PADS_BANK0_OD! 7 bit swap PAD rot if bis! else bic! then ; 
 : PADS_BANK0_IE! 6 bit swap PAD rot if bis! else bic! then ; 
 : PADS_BANK0_DRIVE! PAD dup @ [ 3 4 lshift ] literal bic rot 3 and 4 lshift or swap ! ; 
 : PADS_BANK0_PUE! 3 bit swap PAD rot if bis! else bic! then ; 
 : PADS_BANK0_PDE! 2 bit swap PAD rot if bis! else bic! then ; 
 : PADS_BANK0_SCHMITT! 1 bit swap PAD rot if bis! else bic! then ; 
 : PADS_BANK0_SLEWFAST! 0 bit swap PAD rot if bis! else bic! then ; 
 : init-test true 3 PADS_BANK0_PUE! false 3 PADS_BANK0_PDE! true 3 PADS_BANK0_IE! true 3 PADS_BANK0_OD! 25 bit GPIO_OE_SET ! 2 bit GPIO_OE_SET ! 3 bit GPIO_OE_CLR ! 2 bit GPIO_OUT_SET ! 3 bit GPIO_IN bit@ if 25 bit GPIO_OUT_XOR ! then ; 
 : space-div-factor constant ; 
 : bench-block swap bench-block-size * swap + bench-head-size + ; 
 : allocate-block >r r@ bench-heap-current-count @ r@ bench-block tuck block-size ! block-addr ! 1 r> bench-heap-current-count +! ; 
 : free-block >r dup 1+ r@ bench-block dup bench-block-size - rot 1+ r@ bench-heap-current-count @ swap - bench-block-size * move -1 r> bench-heap-current-count +! ; 
 : bench-do-allocate >r r@ bench-heap-count-limit @ r@ bench-heap-current-count @ > if @ bench-heap-size-limit @ r@ bench-heap-current-size @ - up 3 cells >= if space-div-factor / 3 cells max r@ bench-prng tinymt32-generate-uint32 swap umod 3 cells max 16 align cell - dup r@ bench-heap-current-size +! dup r@ bench-heap @ r@ bench-allocate @ execute swap r> allocate-block true lse drop rdrop false hen else drop false then ; 
 : bench-do-free >r r@ bench-heap-current-count @ 0> if @ bench-prng tinymt32-generate-uint32 @ bench-heap-current-count @ umod up r@ bench-block up block-size @ negate r@ bench-heap-current-size +! lock-addr @ @ bench-heap @ r@ bench-free @ execute > free-block rue else drop false then ; 
 : bench-do-resize >r r@ bench-heap-current-count @ 0> if @ bench-heap-size-limit @ r@ bench-heap-current-size @ - up 3 cells >= if space-div-factor / 3 cells max r@ bench-prng tinymt32-generate-uint32 swap umod 3 cells max 16 align r@ bench-prng tinymt32-generate-uint32 r@ bench-heap-current-count @ umod r@ bench-block 2dup block-size @ + r@ bench-heap-size-limit @ <= if over r@ bench-heap-current-size +! tuck block-size +! dup block-size @ over block-addr @ r@ bench-heap @ r> bench-resize @ execute swap block-addr ! true else 2drop rdrop false then lse drop rdrop false hen else drop false then ; 
 : bench-cycle endof ndcase until rdrop ; 
 : bench-size bench-block-size * bench-head-size + ; 
 : init-bench >r 0 r@ bench-heap-current-count ! 0 r@ bench-heap-current-size ! r@ bench-heap-count-limit ! r@ bench-heap-size-limit ! r@ bench-heap ! r@ bench-init-heap ! r@ bench-diagnose ! r@ bench-resize ! r@ bench-free ! r@ bench-allocate ! r@ bench-seed ! r> bench-prng tinymt32-prepare-example ; 
 : run-bench dup >r [: >r r@ bench-heap @ r@ bench-init-heap @ execute r@ bench-seed @ r@ bench-prng tinymt32-init systick-counter over begin ?dup while r@ bench-cycle 1- repeat systick-counter swap - 0 swap rot 0 swap 2swap f/ 10000,0 f/ rdrop ;] try if r> dup bench-heap @ swap bench-diagnose @ execute else rdrop then ; 
 : block-size constant ; 
 : block-count constant ; 
 : block-count-limit constant ; 
 : run-bench-new swap block-size block-count heap-size [: dup block-size block-count heap-size 0 fill block-count-limit bench-size [: r >r '] allocate ['] free ['] resize ['] diagnose-heap : block-size block-count rot init-heap ;] > block-size-limit block-count-limit r@ init-bench > run-bench ;] with-aligned-allot ;] with-aligned-allot ; 
 : block-size constant ; 
 : block-count constant ; 
 : run-heap-exhaust heap-exhaust-size [: >r block-size block-count r@ heap-exhaust-heap init-heap r@ heap-exhaust-prng tinymt32-prepare-example r@ heap-exhaust-prng tinymt32-init begin @ heap-exhaust-prng tinymt32-generate-uint32 cells umod 3 cells max 16 align cell - @ heap-exhaust-heap allocate drop again ;] with-aligned-allot ; 
 : debug-heap? constant ; 
 : verify-allocated? constant ; 
 : x-allocate-failed ." cr ; 
 : x-internal-error ." cr ; 
 : x-memory-not-allocated ." cr ; 
 : heap-bitmap [inlined] heap-size + ; 
 : heap-bitmap-cell [inlined] heap-bitmap swap 5 rshift cells + ; 
 : heap-blocks [inlined] dup heap-block-count @ swap heap-bitmap-cell ; 
 : heap-block [inlined] dup heap-block-size @ rot * swap heap-blocks + ; 
 : block-addr>index [inlined] tuck heap-blocks - swap heap-block-size @ u/ ; 
 : in-heap? -rot + swap heap-block-count @ <= ; 
 : size>blocks 2dup heap-block-size @ umod 0> if eap-block-size @ u/ 1+ else eap-block-size @ u/ then ; 
 : bitmap-index@ heap-bitmap swap 5 rshift 2 lshift + @ ; 
 : block-allocated? swap tuck swap bitmap-index@ swap $1F and bit and 0<> ; 
 : group-size@ heap-block group-size @ ; 
 : group-size! [ debug-heap? ] [if] r pick 900 > if ." 2 pick . [then] 2 pick 2 pick + over heap-block-count @ > triggers x-internal-error heap-block group-size ! ; 
 : heap-next-free! [ debug-heap? ] [if] r ." over . [then] heap-next-free ! ; 
 : group-prev-free@ heap-block group-prev-free @ ; 
 : group-prev-free! [ debug-heap? ] [if] r ." over . [then] heap-block group-prev-free ! ; 
 : group-next-free@ heap-block group-next-free @ ; 
 : group-next-free! [ debug-heap? ] [if] r ." over . [then] heap-block group-next-free ! ; 
 : group-end@ swap tuck swap group-size@ + ; 
 : test-high-zero over if ver -1 <> if tuck 32 swap - lshift swap begin ?dup while over 31 rshift 0= if nip 1- exit then 1- swap 1 lshift swap repeat drop -1 lse 2drop -1 hen else ip 1- then ; 
 : test-high-nonzero over -1 <> if ver if tuck 32 swap - lshift swap begin ?dup while over 31 rshift if nip 1- exit then 1- swap 1 lshift swap repeat drop -1 lse 2drop -1 hen else ip 1- then ; 
 : test-low-zero over if ver -1 <> if tuck rshift swap begin dup 32 < while over 1 and 0= if nip exit then 1+ swap 1 rshift swap repeat 2drop -1 lse 2drop -1 hen else ip then ; 
 : find-prev-free-group-end over 0> if ver $1F and if over >r swap $1F bic swap 2dup bitmap-index@ r> $1F and lse swap 32 - swap 2dup bitmap-index@ 32 hen egin test-high-zero dup -1 <> if nip swap $1F bic + exit then drop over 0> if swap 32 - swap 2dup bitmap-index@ 32 false else true then ntil drop -1 else drop -1 then ; 
 : find-free-group-start [ debug-heap? ] [if] r ." dup . [then] ; 
 : find-next-free-group-start 2dup heap-block-count @ < if ver $1F bic over bitmap-index@ egin 2 pick $1F and test-low-zero dup -1 <> if nip swap $1F bic + exit then drop swap $1F bic 32 + swap 2dup heap-block-count @ < if 2dup bitmap-index@ false else true then ntil drop -1 else drop -1 then ; 
 : link-group-next ; 
 : link-group-prev then ; 
 : link-group-next-adjacent ; 
 : link-group-prev-adjacent then ; 
 : mark-allocated swap tuck swap heap-bitmap-cell >r begin over while 32 over $1F and - 2 pick min $FFFFFFFF over 32 swap - rshift 2 pick $1F and lshift debug-heap? ] [if] cr ." dup h.8 then] @ bis! r> cell+ >r tuck + -rot - swap repeat rdrop 2drop ; 
 : mark-free swap tuck swap heap-bitmap-cell >r begin over while 32 over $1F and - 2 pick min $FFFFFFFF over 32 swap - rshift 2 pick $1F and lshift r@ bic! r> cell+ >r tuck + -rot - swap repeat rdrop 2drop ; 
 : link-group then ; 
 : expandable-group? then ; 
 : init-heap-bitmap dup heap-bitmap swap heap-block-count @ 3 rshift 0 fill ; 
 : find-last-block r r@ heap-next-free @ begin dup r@ group-size@ 2dup + r@ heap-block-count @ >= if 2dup + r@ heap-block-count @ = if over r@ group-next-free@ -1 = if rop true else r ." . ['] x-internal-error ?raise then then ntil drop ; 
 : find-free [ debug-heap? ] [if] r ." [then] ; 
 : allocate-from-group ; 
 : expand-group hen then ; 
 : is-allocated? >r swap tuck + begin 2dup < while - dup r@ block-allocated? not if rdrop 2drop false exit then repeat rdrop 2drop true ; 
 : verify-first-block [ debug-heap? ] [if] r r@ heap-next-free @ r@ group-prev-free@ -1 <> if cr ." r@ find-free-group-start . ['] x-internal-error ?raise lse drop hen drop [else] rop [then] ; 
 : verify-last-block [ debug-heap? ] [if] r r@ heap-block-count @ r@ find-last-block up -1 <> if cr ." dup . ['] x-internal-error ?raise else 1+ then repeat 2drop lse drop hen drop [else] rop [then] ; 
 : diagnose-heap cr ." then loop drop ; 
 : init-heap tuck swap 32 align swap heap-block-count ! tuck swap cell align 3 cells max swap heap-block-size ! 0 over heap-next-free! dup heap-block-count @ 0 2 pick group-size! -1 0 2 pick group-prev-free! -1 0 2 pick group-next-free! init-heap-bitmap ; 
 : allocate r@ verify-first-block r> verify-last-block ; 
 : free r@ verify-first-block r> verify-last-block ; 
 : resize then ; 
 : heap-size swap cell align 3 cells max over * swap 32 align 5 rshift cells + heap-size + ; 
 : my-block-count constant ; 
 : my-block-size constant ; 
 : block-0 variable ; 
 : block-1 variable ; 
 : block-2 variable ; 
 : block-3 variable ; 
 : init-test my-block-size my-block-count my-heap init-heap 16 my-heap allocate block-0 ! cr ." block-0 @ h.8 ; 
 : heartbeat begin on red led! 250 ms off red led! 250 ms again ; 
 : heartbeat-task variable ; 
 : init-heartbeat 0 ['] heartbeat 420 128 512 spawn heartbeat-task ! heartbeat-task @ run ; 
 : accept-send constant ; 
 : accept-recv constant ; 
 : x-out-of-range-clock ." cr ; 
 : x-i2c-target-noack ." cr ; 
 : x-arb-lost ." cr ; 
 : x-i2c-tx-error ." cr ; 
 : x-i2c-rx-over ." cr ; 
 : x-invalid-i2c ." cr ; 
 : x-out-of-range-addr ." cr ; 
 : x-invalid-op-for-master-mode ." cr ; 
 : x-invalid-op-for-slave ." cr ; 
 : x-invalid-op-for-master ." cr ; 
 : x-master-not-ready ." cr ; 
 : i2c-addr [inlined] ; 
 : mode-not-active constant ; 
 : mode-send constant ; 
 : mode-recv constant ; 
 : mode-done-send constant ; 
 : master-not-active constant ; 
 : master-send constant ; 
 : master-recv constant ; 
 : not-pending constant ; 
 : send-pending constant ; 
 : recv-pending constant ; 
 : i2c-count constant ; 
 : validate-i2c i2c-count u< averts x-invalid-i2c ; 
 : I2C_Base $4000 * $40044000 + ; 
 : i2c-select i2c-size * i2c-buffers + ; 
 : IC_CON $00 + ; 
 : IC_TAR $04 + ; 
 : IC_SAR $08 + ; 
 : IC_DATA_CMD $10 + ; 
 : IC_SS_SCL_HCNT $14 + ; 
 : IC_SS_SCL_LCNT $18 + ; 
 : IC_FS_SCL_HCNT $1C + ; 
 : IC_FS_SCL_LCNT $20 + ; 
 : IC_INTR_STAT $2C + ; 
 : IC_INTR_MASK $30 + ; 
 : IC_RAW_INTR_STAT $34 + ; 
 : IC_RX_TL $38 + ; 
 : IC_TX_TL $3C + ; 
 : IC_CLR_INTR $40 + ; 
 : IC_CLR_RX_UNDER $44 + ; 
 : IC_CLR_RX_OVER $48 + ; 
 : IC_CLR_TX_OVER $4C + ; 
 : IC_CLR_RD_REQ $50 + ; 
 : IC_CLR_TX_ABRT $54 + ; 
 : IC_CLR_RX_DONE $58 + ; 
 : IC_CLR_ACTIVITY $5C + ; 
 : IC_CLR_STOP_DET $60 + ; 
 : IC_CLR_START_DET $64 + ; 
 : IC_CLR_GEN_CALL $68 + ; 
 : IC_ENABLE $6C + ; 
 : IC_STATUS $70 + ; 
 : IC_TXFLR $74 + ; 
 : IC_RXFLR $78 + ; 
 : IC_SDA_HOLD $7C + ; 
 : IC_TX_ABRT_SOURCE $80 + ; 
 : IC_SLV_DATA_NACK_ONLY $84 + ; 
 : IC_DMA_CR $88 + ; 
 : IC_DMA_TDLR $8C + ; 
 : IC_DMA_RDLR $90 + ; 
 : IC_SDA_SETUP $94 + ; 
 : IC_ACK_GENERAL_CALL $98 + ; 
 : IC_ENABLE_STATUS $9C + ; 
 : IC_FS_SPKLEN $A0 + ; 
 : IC_CLR_RESTART_DET $A8 + ; 
 : IC_COMP_PARAM_1 $F4 + ; 
 : IC_COMP_VERSION $F8 + ; 
 : IC_COMP_TYPE $FC + ; 
 : SPEED constant ; 
 : SPEED_FAST constant ; 
 : IC_TAR_ADDR constant ; 
 : DAT constant ; 
 : TX_FLUSH_CNT_SHIFT constant ; 
 : TX_FLUSH_CNT_MASK constant ; 
 : i2c-irq 23 + ; 
 : i2c-vector i2c-irq 16 + ; 
 : validate-i2c-addr i2c-select i2c-10-bit-addr c@ if dup $400 u< averts x-out-of-range-addr else dup $80 u< averts x-out-of-range-addr then dup %111 bic %0000000 <> averts x-out-of-range-addr dup %111 bic %1111000 <> averts x-out-of-range-addr dup %100 bic %0001000 <> averts x-out-of-range-addr %1100001 <> averts x-out-of-range-addr ; 
 : validate-send i2c-select dup i2c-slave c@ if dup i2c-master-mode c@ master-recv <> if i2c-lock release-lock ['] x-invalid-op-for-master-mode ?raise then then drop ; 
 : validate-recv i2c-select dup i2c-slave c@ if dup i2c-master-mode c@ master-send <> if i2c-lock release-lock ['] x-invalid-op-for-master-mode ?raise then then drop ; 
 : validate-master i2c-select dup i2c-slave c@ if i2c-lock release-lock ['] x-invalid-op-for-slave ?raise then drop ; 
 : validate-slave i2c-select dup i2c-slave c@ 0= if i2c-lock release-lock ['] x-invalid-op-for-master ?raise then drop ; 
 : claim-i2c i2c-select i2c-lock claim-lock ; 
 : release-i2c i2c-select i2c-lock release-lock ; 
 : restore-int-mask disable-int STOP_DET over i2c-addr @ IC_INTR_MASK @ ACTIVITY and or swap i2c-addr @ IC_INTR_MASK ! enable-int ; 
 : signal-done $FF swap i2c-done c! wake ; 
 : set-nack dup i2c-disabled @ 0<= if IC_ENABLE_ENABLE over i2c-addr @ IC_ENABLE bic! begin dup i2c-addr @ IC_ENABLE_STATUS @ IC_EN and 0= until then disable-int begin dup i2c-addr @ IC_STATUS @ SLV_ACTIVITY and 0= until $FF over i2c-nack-set c! ACTIVITY over i2c-addr @ IC_INTR_MASK bis! 1 over i2c-addr @ IC_SLV_DATA_NACK_ONLY bis! enable-int dup i2c-disabled @ 0<= if IC_ENABLE_ENABLE over i2c-addr @ IC_ENABLE bis! begin dup i2c-addr @ IC_ENABLE_STATUS @ IC_EN and until then drop ; 
 : clear-nack dup i2c-nack-set c@ if dup i2c-disabled @ 0<= if IC_ENABLE_ENABLE over i2c-addr @ IC_ENABLE bic! begin dup i2c-addr @ IC_ENABLE_STATUS @ IC_EN and 0= until then disable-int begin dup i2c-addr @ IC_STATUS @ SLV_ACTIVITY and 0= until $00 over i2c-nack-set c! ACTIVITY over i2c-addr @ IC_INTR_MASK bic! 1 over i2c-addr @ IC_SLV_DATA_NACK_ONLY bic! enable-int dup i2c-disabled @ 0<= if IC_ENABLE_ENABLE over i2c-addr @ IC_ENABLE bis! begin dup i2c-addr @ IC_ENABLE_STATUS @ IC_EN and until then then drop ; 
 : handle-tx-abrt dup i2c-mode c@ dup mode-send = swap mode-done-send = or if dup i2c-addr @ IC_TX_ABRT_SOURCE @ TX_FLUSH_CNT_MASK and TX_FLUSH_CNT_SHIFT rshift negate over i2c-data-offset @ + 0 max over i2c-data-offset ! then dup i2c-addr @ IC_TX_ABRT_SOURCE @ [ ABRT_SLVRD_INTX ABRT_SLV_ARBLOST or ABRT_MASTER_DIS or ABRT_10B_RD_NORSTRT or ABRT_SBYTE_NORSTRT or ABRT_HS_NORSTRT or ABRT_SBYTE_ACKDET or ABRT_HS_ACKDET or ABRT_GCALL_READ or ] literal and if $FF over i2c-tx-error c! else dup i2c-addr @ IC_TX_ABRT_SOURCE @ ARB_LOST and if $FF over i2c-arb-lost c! else dup i2c-addr @ IC_TX_ABRT_SOURCE @ ABRT_USER_ABRT and if 1 over i2c-user-abort-count +! else dup i2c-addr @ IC_TX_ABRT_SOURCE @ [ ABRT_10ADDR2_NOACK ABRT_10ADDR1_NOACK or ABRT_7B_ADDR_NOACK or ] literal and if $FF over i2c-tx-target-noack c! then then then then mode-not-active over i2c-mode c! dup restore-int-mask dup signal-done i2c-addr @ IC_CLR_TX_ABRT @ drop ; 
 : handle-tx-empty dup i2c-mode c@ mode-send = if begin dup i2c-data-offset @ over i2c-data-size @ < if dup i2c-addr @ IC_INTR_STAT @ TX_ABRT and if dup handle-tx-abrt true else dup i2c-addr @ IC_STATUS @ TFE and if dup i2c-data-offset @ over i2c-data-addr @ + c@ over i2c-slave c@ 0= if over i2c-data-offset @ 0= if over i2c-restart c@ if RESTART or then then over i2c-data-offset @ 2 pick i2c-data-size @ 1- = 2 pick i2c-stop c@ 0<> and if $FF 2 pick i2c-prev-stop c! STOP_BIT or then then over i2c-addr @ IC_DATA_CMD ! 1 over i2c-data-offset +! false else true then then else mode-done-send over i2c-mode c! true then until then drop ; 
 : handle-rx-full dup i2c-mode c@ mode-recv = if begin dup i2c-data-offset @ over i2c-data-size @ < if dup i2c-addr @ IC_DATA_CMD @ $FF and over i2c-data-offset @ 2 pick i2c-data-addr @ + c! 1 over i2c-data-offset +! dup i2c-data-offset @ over i2c-data-size @ = if $00 over i2c-stop-det c! mode-not-active over i2c-mode c! dup restore-int-mask dup signal-done true else dup i2c-slave c@ 0= over i2c-stop-det c@ 0= and if dup i2c-data-offset @ over i2c-data-size @ 1- = if dup i2c-stop c@ if $FF over i2c-prev-stop c! [ CMD STOP_BIT or ] literal else CMD then else CMD then over i2c-addr @ IC_DATA_CMD ! then dup i2c-addr @ IC_STATUS @ RFNE and 0= over i2c-stop-det c@ 0<> over and if $00 2 pick i2c-stop-det c! over restore-int-mask mode-not-active 2 pick i2c-mode c! over i2c-slave c@ <> if master-not-active 2 pick i2c-master-mode c! then over signal-done then then else mode-not-active over i2c-mode c! dup i2c-slave c@ if master-send over i2c-master-mode c! send-pending over i2c-pending c! then dup restore-int-mask dup signal-done true then until else dup i2c-mode c@ mode-not-active = over i2c-slave c@ 0<> and if master-send over i2c-master-mode c! send-pending over i2c-pending c! dup restore-int-mask wake then then drop ; 
 : handle-rd-req dup i2c-mode c@ mode-not-active = over i2c-slave c@ 0<> and if master-recv over i2c-master-mode c! recv-pending over i2c-pending c! wake then i2c-addr @ IC_CLR_RD_REQ @ drop ; 
 : handle-rx-done dup i2c-mode c@ mode-recv = over i2c-slave c@ 0<> and if dup restore-int-mask 0 over i2c-addr @ IC_RX_TL ! 0 over i2c-addr @ IC_TX_TL ! mode-not-active over i2c-mode c! master-not-active over i2c-master-mode c! dup signal-done then i2c-addr @ IC_CLR_RX_DONE @ drop ; 
 : handle-stop-det dup i2c-prev-stop c@ 0= if $FF over i2c-stop-det c! else $00 over i2c-prev-stop c! then dup i2c-addr @ IC_CLR_STOP_DET @ drop dup i2c-mode c@ mode-recv = over i2c-addr @ IC_STATUS @ RFNE and 0= and if dup i2c-stop-det c@ if $00 over i2c-stop-det c! dup restore-int-mask mode-not-active over i2c-mode c! dup i2c-slave c@ if master-not-active over i2c-master-mode c! then dup signal-done then then drop ; 
 : handle-activity dup clear-nack i2c-addr @ IC_CLR_ACTIVITY @ drop ; 
 : handle-rx-over dup i2c-mode c@ mode-send = if dup restore-int-mask 0 over i2c-addr @ IC_RX_TL ! 0 over i2c-addr @ IC_TX_TL ! $FF over i2c-rx-over c! mode-not-active over i2c-mode c! dup signal-done then i2c-addr @ IC_CLR_RX_OVER @ drop ; 
 : handle-i2c-interrupt dup i2c-irq NVIC_ICPR_CLRPEND! i2c-select dup i2c-addr @ IC_INTR_STAT @ STOP_DET and if dup handle-stop-det then dup i2c-addr @ IC_INTR_STAT @ ACTIVITY and if dup handle-activity then dup i2c-addr @ IC_INTR_STAT @ TX_ABRT and if dup handle-tx-abrt then dup i2c-addr @ IC_INTR_STAT @ TX_EMPTY and if dup handle-tx-empty then dup i2c-addr @ IC_INTR_STAT @ RX_FULL and if dup handle-rx-full then dup i2c-addr @ IC_INTR_STAT @ RX_OVER and if dup handle-rx-over then dup i2c-addr @ IC_INTR_STAT @ RX_DONE and if dup handle-rx-done then dup i2c-addr @ IC_INTR_STAT @ RD_REQ and if dup handle-rd-req then dup i2c-mode c@ mode-done-send = if begin dup i2c-addr @ IC_STATUS @ SLV_ACTIVITY and 0= until begin dup i2c-addr @ IC_STATUS @ MST_ACTIVITY and 0= until dup i2c-addr @ IC_INTR_STAT @ TX_ABRT and if dup handle-tx-abrt then dup restore-int-mask dup signal-done mode-not-active over i2c-mode c! then drop ; 
 : init-i2c disable-int dup I2C_Base over i2c-select i2c-addr ! dup i2c-select dup i2c-lock init-lock dup i2c-inner-lock init-lock 0 over int-count ! $00 over i2c-10-bit-addr c! $00 over i2c-slave c! mode-not-active over i2c-mode c! $00 over i2c-restart c! $00 over i2c-stop c! $00 over i2c-stop-det c! $00 over i2c-nack-set c! master-not-active over i2c-master-mode c! not-pending over i2c-pending c! $00 over i2c-done c! $00 over i2c-tx-abort c! $00 over i2c-tx-error c! $00 over i2c-tx-target-noack c! $00 over i2c-arb-lost c! $00 over i2c-rx-over c! 1 over i2c-disabled ! 0 over i2c-data-addr ! 0 over i2c-data-size ! 0 over i2c-data-offset ! 0 over i2c-user-abort-count ! IC_ENABLE_ENABLE over i2c-addr @ IC_ENABLE bic! [ TX_EMPTY_CTRL RX_FIFO_FULL_HLD_CTRL or IC_RESTART_EN or IC_SLAVE_DISABLE or SPEED_FAST or MASTER_MODE or STOP_DET_IF_ADDRESSED or ] literal over i2c-addr @ IC_CON ! 0 over i2c-addr @ IC_TX_TL ! 0 over i2c-addr @ IC_RX_TL ! 0 swap i2c-addr @ IC_INTR_MASK ! 0 over i2c-irq NVIC_IPR_IP! dup 0= if [: 0 handle-i2c-interrupt ;] else [: 1 handle-i2c-interrupt ;] then over i2c-vector vector! 400000 over i2c-clock! i2c-irq NVIC_ISER_SETENA! enable-int ; 
 : core-init-hook-saved variable ; 
 : init-i2c-core-1 task::core-init-hook @ core-init-hook-saved ! [: core-init-hook-saved @ execute disable-int 0 0 i2c-irq NVIC_IPR_IP! 0 1 i2c-irq NVIC_IPR_IP! 0 i2c-irq NVIC_ISER_SETENA! 1 i2c-irq NVIC_ISER_SETENA! enable-int ;] task::core-init-hook ! ; 
 : wait-i2c-complete-or-timeout timeout @ no-timeout = if [: dup i2c-done c@ 0<> ;] wait else systick-counter begin over i2c-done c@ 0<> if drop true else disable-int systick-counter over - timeout @ >= if drop dup i2c-slave c@ 0= if IC_ENABLE_ABORT over i2c-addr @ IC_ENABLE bis! begin dup i2c-addr @ IC_ENABLE @ IC_ENABLE_ABORT and 0= until then dup i2c-addr @ IC_CLR_STOP_DET @ drop dup i2c-addr @ IC_CLR_RX_DONE @ drop dup i2c-addr @ IC_CLR_TX_ABRT @ drop mode-not-active over i2c-mode c! 0 over i2c-data-offset ! 0 over i2c-data-size ! $00 over i2c-stop c! $00 over i2c-restart c! $00 over i2c-stop-det c! $00 over i2c-prev-stop c! $00 over i2c-tx-abort c! $00 over i2c-tx-error c! $00 over i2c-tx-target-noack c! $00 over i2c-arb-lost c! $00 over i2c-rx-over c! $00 over i2c-stop-det c! dup restore-int-mask dup i2c-lock release-lock ['] x-timed-out ?raise then enable-int wake-counter @ current-task block-wait false then until then drop ; 
 : do-i2c-send i2c-select over if disable-int dup i2c-slave c@ 0<> over i2c-master-mode c@ master-recv <> and if enable-int ['] x-master-not-ready ?raise then tuck i2c-data-size ! tuck i2c-data-addr ! 0 over i2c-data-offset ! mode-send over i2c-mode c! $00 over i2c-tx-abort c! $00 over i2c-tx-error c! $00 over i2c-tx-target-noack c! $00 over i2c-arb-lost c! $00 over i2c-rx-over c! $00 over i2c-stop-det c! not-pending over i2c-pending c! $00 over i2c-done c! 0 over i2c-addr @ IC_RX_TL ! dup i2c-slave c@ if 7 else 0 then over i2c-addr @ IC_TX_TL ! [ TX_EMPTY TX_OVER or TX_ABRT or ] literal over i2c-slave c@ if [ RD_REQ RX_DONE or ] literal or then over i2c-addr @ IC_INTR_MASK ! enable-int dup wait-i2c-complete-or-timeout $00 over i2c-stop-det c! mode-not-active over i2c-mode c! dup i2c-data-offset @ over i2c-tx-target-noack c@ 2 pick i2c-arb-lost c@ 3 pick i2c-tx-error c@ 4 roll i2c-lock release-lock triggers x-i2c-tx-error triggers x-arb-lost triggers x-i2c-target-noack else i2c-lock release-lock nip then ; 
 : do-i2c-recv i2c-select over if disable-int dup i2c-slave c@ 0<> over i2c-master-mode c@ master-send <> and if enable-int ['] x-master-not-ready ?raise then tuck i2c-data-size ! tuck i2c-data-addr ! 0 over i2c-data-offset ! mode-recv over i2c-mode c! $00 over i2c-tx-abort c! $00 over i2c-tx-error c! $00 over i2c-tx-target-noack c! $00 over i2c-arb-lost c! $00 over i2c-rx-over c! not-pending over i2c-pending c! $00 over i2c-done c! 0 over i2c-addr @ IC_RX_TL ! 0 over i2c-addr @ IC_TX_TL ! [ RX_FULL RX_OVER or STOP_DET or TX_ABRT or ] literal over i2c-slave c@ if RD_REQ or then over i2c-addr @ IC_INTR_MASK ! dup i2c-slave c@ 0= if CMD over i2c-restart c@ if RESTART or then over i2c-data-size @ 1 = 2 pick i2c-stop c@ 0<> and if $FF 2 pick i2c-prev-stop c! STOP_BIT or then over i2c-addr @ IC_DATA_CMD ! then enable-int dup wait-i2c-complete-or-timeout $00 over i2c-stop-det c! mode-not-active over i2c-mode c! dup i2c-data-offset @ over i2c-tx-target-noack c@ 2 pick i2c-arb-lost c@ 3 pick i2c-rx-over c@ 4 roll i2c-lock release-lock triggers x-i2c-rx-over triggers x-arb-lost triggers x-i2c-target-noack else i2c-lock release-lock nip then ; 
 : disable-i2c dup validate-i2c i2c-select [: 1 over i2c-disabled +! dup i2c-disabled @ 1 = if $000 over i2c-addr @ IC_INTR_MASK ! IC_ENABLE_ENABLE over i2c-addr @ IC_ENABLE bic! begin dup i2c-addr @ IC_ENABLE_STATUS @ IC_EN and 0= until then drop ;] over i2c-inner-lock with-lock ; 
 : enable-i2c dup validate-i2c i2c-select [: -1 over i2c-disabled +! dup i2c-disabled @ 0= if dup restore-int-mask IC_ENABLE_ENABLE over i2c-addr @ IC_ENABLE bis! begin dup i2c-addr @ IC_ENABLE_STATUS @ IC_EN and until then drop ;] over i2c-inner-lock with-lock ; 
 : with-i2c-disabled dup validate-i2c dup claim-i2c dup disable-i2c dup >r swap try r> dup enable-i2c release-i2c ?raise ; 
 : i2c-alternate validate-i2c 3 ; 
 : i2c-pin over validate-i2c false over PADS_BANK0_SLEWFAST! true over PADS_BANK0_SCHMITT! swap i2c-alternate swap alternate-pin ; 
 : master-i2c dup validate-i2c [: [ IC_SLAVE_DISABLE MASTER_MODE or ] literal over I2C_Base IC_CON bis! $00 swap i2c-select i2c-slave c! ;] swap with-i2c-disabled ; 
 : slave-i2c dup validate-i2c [: [ IC_SLAVE_DISABLE MASTER_MODE or ] literal over I2C_Base IC_CON bic! $FF swap i2c-select i2c-slave c! ;] swap with-i2c-disabled ; 
 : 7-bit-i2c-addr dup validate-i2c [: [ IC_10BITADDR_MASTER IC_10BITADDR_SLAVE or ] literal over I2C_Base IC_CON bic! $00 swap i2c-select i2c-10-bit-addr c! ;] swap with-i2c-disabled ; 
 : 10-bit-i2c-addr dup validate-i2c [: [ IC_10BITADDR_MASTER IC_10BITADDR_SLAVE or ] literal over I2C_Base IC_CON bis! $FF swap i2c-select i2c-10-bit-addr c! ;] swap with-i2c-disabled ; 
 : i2c-target-addr! dup validate-i2c 2dup validate-i2c-addr [: dup I2C_Base IC_TAR @ IC_TAR_ADDR bic rot IC_TAR_ADDR and or swap I2C_Base IC_TAR ! ;] swap with-i2c-disabled ; 
 : i2c-slave-addr! dup validate-i2c 2dup validate-i2c-addr [: I2C_Base IC_SAR ! ;] swap with-i2c-disabled ; 
 : wait-i2c-master-timeout dup validate-i2c systick-counter swap dup i2c-select disable-int mode-not-active over i2c-mode c! [ RX_FULL RD_REQ or ] literal over i2c-addr @ IC_INTR_MASK ! enable-int begin systick-counter 3 pick - 4 pick < averts x-timed-out over claim-i2c over validate-slave dup i2c-pending c@ send-pending = if not-pending over i2c-pending c! accept-send true else dup i2c-pending c@ recv-pending = if not-pending over i2c-pending c! accept-recv true else 0 false then then 3 pick release-i2c dup not if nip pause wake-counter @ current-task block-wait then until nip nip nip nip ; 
 : wait-i2c-master-send-timeout dup validate-i2c systick-counter swap dup i2c-select disable-int mode-not-active over i2c-mode c! RX_FULL over i2c-addr @ IC_INTR_MASK ! enable-int begin systick-counter 3 pick - 4 pick < averts x-timed-out over claim-i2c over validate-slave dup i2c-pending c@ send-pending = if not-pending over i2c-pending c! true else false then 2 pick release-i2c dup not if pause wake-counter @ current-task block-wait then until 2drop 2drop ; 
 : wait-i2c-master-recv-timeout dup validate-i2c systick-counter swap dup i2c-select disable-int mode-not-active over i2c-mode c! RD_REQ over i2c-addr @ IC_INTR_MASK ! enable-int begin systick-counter 3 pick - 4 pick < averts x-timed-out over claim-i2c over validate-slave dup i2c-pending c@ recv-pending = if not-pending over i2c-pending c! true else false then 2 pick release-i2c dup not if pause wake-counter @ current-task block-wait then until 2drop 2drop ; 
 : wait-i2c-master-indefinite dup validate-i2c dup i2c-select disable-int mode-not-active over i2c-mode c! [ RX_FULL RD_REQ or ] literal over i2c-addr @ IC_INTR_MASK ! enable-int begin over claim-i2c over validate-slave dup i2c-pending c@ send-pending = if not-pending over i2c-pending c! accept-send true else dup i2c-pending c@ recv-pending = if not-pending over i2c-pending c! accept-recv true else 0 false then then 3 pick release-i2c dup not if nip pause wake-counter @ current-task block-wait then until nip nip ; 
 : wait-i2c-master-send-indefinite dup validate-i2c dup i2c-select disable-int mode-not-active over i2c-mode c! RX_FULL over i2c-addr @ IC_INTR_MASK ! enable-int begin over claim-i2c over validate-slave dup i2c-pending c@ send-pending = if not-pending over i2c-pending c! true else false then 2 pick release-i2c dup not if pause wake-counter @ current-task block-wait then until 2drop ; 
 : wait-i2c-master-recv-indefinite dup validate-i2c dup i2c-select disable-int mode-not-active over i2c-mode c! RD_REQ over i2c-addr @ IC_INTR_MASK ! enable-int begin over claim-i2c over validate-slave dup i2c-pending c@ recv-pending = if not-pending over i2c-pending c! true else false then 2 pick release-i2c dup not if pause wake-counter @ current-task block-wait then until 2drop ; 
 : wait-i2c-master dup validate-i2c timeout @ no-timeout = if wait-i2c-master-indefinite else timeout @ swap wait-i2c-master-timeout then ; 
 : wait-i2c-master-send dup validate-i2c timeout @ no-timeout = if wait-i2c-master-send-indefinite else timeout @ swap wait-i2c-master-send-timeout then ; 
 : wait-i2c-master-recv dup validate-i2c timeout @ no-timeout = if wait-i2c-master-recv-indefinite else timeout @ swap wait-i2c-master-recv-timeout then ; 
 : i2c-nack dup validate-i2c dup claim-i2c dup validate-slave dup i2c-select set-nack release-i2c ; 
 : >i2c dup validate-i2c dup claim-i2c dup validate-send $00 over i2c-select i2c-stop c! $00 over i2c-select i2c-restart c! do-i2c-send ; 
 : >i2c-stop dup validate-i2c dup claim-i2c dup validate-master dup validate-send $FF over i2c-select i2c-stop c! $00 over i2c-select i2c-restart c! do-i2c-send ; 
 : >i2c-restart dup validate-i2c dup claim-i2c dup validate-master dup validate-send $00 over i2c-select i2c-stop c! $FF over i2c-select i2c-restart c! do-i2c-send ; 
 : >i2c-restart-stop dup validate-i2c dup claim-i2c dup validate-master dup validate-send $FF over i2c-select i2c-stop c! $FF over i2c-select i2c-restart c! do-i2c-send ; 
 : i2c> dup validate-i2c dup claim-i2c dup validate-recv $00 over i2c-select i2c-stop c! $00 over i2c-select i2c-restart c! do-i2c-recv ; 
 : i2c-stop> dup validate-i2c dup claim-i2c dup validate-master dup validate-recv $FF over i2c-select i2c-stop c! $00 over i2c-select i2c-restart c! do-i2c-recv ; 
 : i2c-restart> dup validate-i2c dup claim-i2c dup validate-master dup validate-recv $00 over i2c-select i2c-stop c! $FF over i2c-select i2c-restart c! do-i2c-recv ; 
 : i2c-restart-stop> dup validate-i2c dup claim-i2c dup validate-master dup validate-recv $FF over i2c-select i2c-stop c! $FF over i2c-select i2c-restart c! do-i2c-recv ; 
 : clear-i2c dup validate-i2c dup claim-i2c dup i2c-select disable-int TX_ABRT over i2c-addr @ IC_INTR_MASK ! dup i2c-disabled @ 0> if IC_ENABLE_ENABLE over i2c-addr @ IC_ENABLE bis! enable-int begin dup i2c-addr @ IC_ENABLE_STATUS @ IC_EN and until else enable-int then dup i2c-slave c@ 0= if IC_ENABLE_ABORT over i2c-addr @ IC_ENABLE bis! begin dup i2c-addr @ IC_ENABLE @ IC_ENABLE_ABORT and 0= until then IC_ENABLE_ENABLE over i2c-addr @ IC_ENABLE bic! begin dup i2c-addr @ IC_ENABLE_STATUS @ IC_EN and 0= until begin dup i2c-addr @ IC_STATUS @ SLV_ACTIVITY and 0= until begin dup i2c-addr @ IC_STATUS @ MST_ACTIVITY and 0= until disable-int dup i2c-addr @ IC_CLR_STOP_DET @ drop dup i2c-addr @ IC_CLR_RX_DONE @ drop dup i2c-addr @ IC_CLR_TX_ABRT @ drop 0 over i2c-data-offset ! 0 over i2c-data-size ! $00 over i2c-stop-det c! $00 over i2c-prev-stop c! $00 over i2c-tx-abort c! $00 over i2c-tx-error c! $00 over i2c-tx-target-noack c! $00 over i2c-arb-lost c! $00 over i2c-rx-over c! mode-not-active over i2c-mode c! master-not-active over i2c-master-mode c! not-pending over i2c-pending c! dup clear-nack dup restore-int-mask enable-int dup i2c-disabled @ 0<= if IC_ENABLE_ENABLE over i2c-addr @ IC_ENABLE bis! begin dup i2c-addr @ IC_ENABLE_STATUS @ IC_EN and until then drop release-i2c ; 
 : test-i2c-addr { addr pin0 pin1 i2c-periph -- } i2c-periph i2c::clear-i2c i2c-periph pin0 i2c::i2c-pin i2c-periph pin1 i2c::i2c-pin i2c-periph i2c::master-i2c addr $80 u< if i2c-periph 7-bit-i2c-addr else i2c-periph 10-bit-i2c-addr then addr i2c-periph ['] i2c::i2c-target-addr! try 0= if i2c-periph i2c::enable-i2c 0. { D^ buf } buf 1 i2c-periph ['] i2c::>i2c-stop try i2c-periph i2c::disable-i2c addr h.4 ." cr then else 2drop then ; 
 : scan-i2c { pin0 pin1 i2c-periph -- } cr $400 $000 ?do i pin0 pin1 i2c-periph test-i2c-addr loop ; 
 : task-count constant ; 
 : recv-buffer-size constant ; 
 : init-test 0 master-i2c 1 slave-i2c 0 10-bit-i2c-addr 1 10-bit-i2c-addr $3C 0 i2c-target-addr! $3C 1 i2c-slave-addr! 0 enable-i2c 1 enable-i2c 1 14 i2c-pin 1 15 i2c-pin 0 16 i2c-pin 0 17 i2c-pin 320 128 512 task-count my-task-pool init-task-pool ; 
 : do-test-0 0 [: 20000 timeout ! 1 wait-i2c-master-send recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type 1 clear-i2c ;] my-task-pool spawn-from-task-pool run pause 1000 ms 0 [: s" 0 >i2c-stop . ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-1 0 [: 20000 timeout ! 1 wait-i2c-master-recv s" 1 >i2c . 1 clear-i2c ;] my-task-pool spawn-from-task-pool run pause 1000 ms 0 [: recv-buffer 9 0 i2c-stop> recv-buffer swap type ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-2 0 [: 10000 timeout ! 1 wait-i2c-master-recv ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-3 0 [: 10000 timeout ! 1 wait-i2c-master-send ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-4 0 [: 10000 timeout ! 1 wait-i2c-master ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-5 0 [: 750 ms 20000 timeout ! 1 wait-i2c-master-send recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type ;] my-task-pool spawn-from-task-pool run 0 [: [: 5000 timeout ! s" 0 >i2c-stop . ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-6 0 [: 750 ms 20000 timeout ! 1 wait-i2c-master-recv s" cr display-normal then no-timeout timeout ! recv-buffer 9 0 i2c-stop> recv-buffer swap type ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-7 0 [: [: 5000 timeout ! 1 wait-i2c-master-send recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type ;] try ['] x-timed-out = if display-red ." 0 >i2c-stop . ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-8 0 [: [: 5000 timeout ! 1 wait-i2c-master-recv s" 1 >i2c . ;] my-task-pool spawn-from-task-pool run 0 [: 1000 ms recv-buffer 9 0 i2c-stop> recv-buffer swap type ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-9 0 [: 1 wait-i2c-master-send recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type ;] my-task-pool spawn-from-task-pool run 0 [: s" 0 >i2c-stop . ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-10 0 [: 1 wait-i2c-master-send recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type ;] my-task-pool spawn-from-task-pool run 0 [: s" 0 >i2c-stop . ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-11 0 [: 1 wait-i2c-master-recv s" 1 >i2c . ;] my-task-pool spawn-from-task-pool run 0 [: recv-buffer recv-buffer-size 0 i2c> recv-buffer swap type recv-buffer recv-buffer-size 0 i2c> recv-buffer swap type recv-buffer recv-buffer-size 0 i2c> recv-buffer swap type recv-buffer recv-buffer-size 0 i2c-stop> recv-buffer swap type ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-12 0 [: 1 wait-i2c-master-recv s" 1 >i2c . ;] my-task-pool spawn-from-task-pool run 0 [: recv-buffer recv-buffer-size 0 i2c> recv-buffer swap type recv-buffer recv-buffer-size 0 i2c> recv-buffer swap type recv-buffer recv-buffer-size 0 i2c> recv-buffer swap type recv-buffer 4 0 i2c-stop> recv-buffer swap type ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-13 0 [: 10000 timeout ! 2 0 ?do 1 wait-i2c-master case accept-send of recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type endof accept-recv of s" 0 >i2c-stop . ;] my-task-pool spawn-from-task-pool run ; 
 : do-test-14 0 [: 1 wait-i2c-master-send recv-buffer recv-buffer-size 1 i2c> recv-buffer swap type 1 i2c-nack ;] my-task-pool spawn-from-task-pool run 0 [: s" 0 >i2c . ;] my-task-pool spawn-from-task-pool run ; 
 : erased? 0 over 16 + rot do i c@ $FF <> or loop ; 
 : ea04generate ." dup h.4 $06 over 8 rshift $FF and + swap $FF and + not $FF and 1+ h.2 cr ; 
 : insert.04ea? dup $10000 >= IF dup 16 rshift swap $FFFF and 0= IF ea04generate ELSE drop THEN ELSE drop THEN ; 
 : clone cr flash-end flash-base do i erased? if i insert.04ea? ." cr ; 
 : erased? 0 over 16 + rot do i c@ $FF <> or loop ; 
 : ea04generate ." dup h.4 $06 + not $FF and 1+ h.2 cr ; 
 : insert.04ea? dup $10000 >= IF dup 16 rshift swap $FFFF and 0= IF ea04generate ELSE drop THEN ELSE drop THEN ; 
 : clone cr 0 do i erased? if i insert.04ea? ." cr ; 
 : erased? 0 over 16 + rot do i c@ $FF <> or loop ; 
 : ea04generate ." dup h.4 $06 over 8 rshift $FF and + swap $FF and + not $FF and 1+ h.2 cr ; 
 : insert.04ea? dup $10000 >= IF dup 16 rshift swap $FFFF and 0= IF ea04generate ELSE drop THEN ELSE drop THEN ; 
 : clone cr flash-end internal::flash-mini-dict-size + flash-end do i erased? if i insert.04ea? ." cr ; 
 : test1 cr s" type ; 
 : test2 cr c" count type ; 
 : test3 cr s\" foo\nbar" type ; 
 : test4 cr c\" foo\nbar" count type ; 
 : start-line-time variable ; 
 : last-line-time variable ; 
 : line-count variable ; 
 : maximum-last-line-diff constant ; 
 : line-interval constant ; 
 : handle-line systick-counter dup last-line-time @ - maximum-last-line-diff <= if last-line-time ! 1 line-count +! line-count @ line-interval = if pace ." line-interval 0 last-line-time @ start-line-time @ - 10000,0 f/ f/ f. ast-line-time @ start-line-time ! 0 line-count ! then else dup last-line-time ! start-line-time ! 0 line-count ! then do-prompt ; 
 : enable-input-speed systick-counter dup start-line-time ! last-line-time ! 0 line-count ! ['] handle-line prompt-hook ! ; 
 : disable-input-speed ['] do-prompt prompt-hook ! ; 
 : x-invalid-vector ." cr ; 
 : ICSR constant ; 
 : SHPR1 constant ; 
 : SHPR2 constant ; 
 : SHPR3 constant ; 
 : NVIC_Base constant ; 
 : NVIC_ISER_Base constant ; 
 : vector! dup 0 > over vector-count < or averts x-invalid-vector swap 1+ swap cells vector-table + ! ; 
 : vector@ dup 0 > over vector-count < or averts x-invalid-vector cells vector-table + @ 1- ; 
 : ICSR_VECTACTIVE@ ICSR @ $1FF and ; 
 : SHPR1_PRI_4! $F0 and 0 lshift SHPR1 @ $FF bic or SHPR1 ! ; 
 : SHPR1_PRI_5! $F0 and 8 lshift SHPR1 @ $FF00 bic or SHPR1 ! ; 
 : SHPR1_PRI_6! $F0 and 16 lshift SHPR1 @ $FF0000 bic or SHPR1 ! ; 
 : SHPR2_PRI_11! $F0 and 24 lshift SHPR2 @ $FF000000 bic or SHPR2 ! ; 
 : SHPR3_PRI_14! $F0 and 16 lshift SHPR3 @ $FF0000 bic or SHPR3 ! ; 
 : SHPR3_PRI_15! $F0 and 24 lshift SHPR3 @ $FF000000 bic or SHPR3 ! ; 
 : SHPR1_PRI_4@ SHPR1 @ 0 rshift $FF and ; 
 : SHPR1_PRI_5@ SHPR1 @ 8 rshift $FF and ; 
 : SHPR1_PRI_6@ SHPR1 @ 16 rshift $FF and ; 
 : SHPR2_PRI_11@ SHPR2 @ 24 rshift $FF and ; 
 : SHPR3_PRI_14@ SHPR3 @ 16 rshift $FF and ; 
 : SHPR3_PRI_15@ SHPR3 @ 24 rshift $FF and ; 
 : ICSR_PENDSVSET! [ 1 28 lshift ] literal ICSR bis! ; 
 : ICSR_PENDSVCLR! [ 1 27 lshift ] literal ICSR bis! ; 
 : ICSR_PENDSVSET@ [ 1 28 lshift ] literal ICSR bit@ ; 
 : svc [ $DF00 h, ] [inlined] ; 
 : NVIC_ISER_SETENA! dup 32 / cells NVIC_ISER_Base + swap 32 mod 1 swap lshift swap ! ; 
 : NVIC_ISER_SETENA@ dup 32 / cells NVIC_ISER_Base + swap 32 mod 1 swap lshift swap bit@ ; 
 : NVIC_ICER_CLRENA! dup 32 / cells NVIC_ICER_Base + swap 32 mod 1 swap lshift swap ! ; 
 : NVIC_ICER_CLRENA@ dup 32 / cells NVIC_ICER_Base + swap 32 mod 1 swap lshift swap bit@ ; 
 : NVIC_ISPR_SETPEND! dup 32 / cells NVIC_ISPR_Base + swap 32 mod 1 swap lshift swap ! ; 
 : NVIC_ISPR_SETPEND@ dup 32 / cells NVIC_ISPR_Base + swap 32 mod 1 swap lshift swap bit@ ; 
 : NVIC_ICPR_CLRPEND! dup 32 / cells NVIC_ICPR_Base + swap 32 mod 1 swap lshift swap ! ; 
 : NVIC_ICPR_CLRPEND@ dup 32 / cells NVIC_ICPR_Base + swap 32 mod 1 swap lshift swap bit@ ; 
 : NVIC_ICPR_CLRPEND_All! 16 cells 0 do -1 NVIC_ICPR_Base i + ! cell +loop ; 
 : NVIC_IABR_ACTIVE@ dup 32 / cells NVIC_IABR_Base + swap 32 mod 1 swap lshift swap bit@ ; 
 : NVIC_IPR_IP_addr 3 bic NVIC_IPR_Base + ; 
 : NVIC_IPR_IP_shift 3 and 3 lshift ; 
 : NVIC_IPR_IP_mask NVIC_IPR_IP_shift $FF swap lshift ; 
 : NVIC_IPR_IP! dup NVIC_IPR_IP_addr dup >r @ over NVIC_IPR_IP_mask bic swap NVIC_IPR_IP_shift rot $FF and swap lshift or r> ! ; 
 : NVIC_IPR_IP@ dup NVIC_IPR_IP_addr @ over NVIC_IPR_IP_mask and swap NVIC_IPR_IP_shift rshift ; 
 : rx-read-index variable ; 
 : rx-write-index variable ; 
 : rx-buffer-size constant ; 
 : tx-read-index variable ; 
 : tx-write-index variable ; 
 : tx-buffer-size constant ; 
 : UART0_Base constant ; 
 : uart0-irq constant ; 
 : ctrl-c constant ; 
 : ctrl-t constant ; 
 : UART0_UARTDR_DATA! $FF and UART0_UARTDR c! ; 
 : UART0_UARTDR_DATA@ UART0_UARTDR c@ ; 
 : UART0_UARTFR_TXFE@ 7 bit UART0_UARTFR bit@ ; 
 : UART0_UARTFR_TXFF@ 5 bit UART0_UARTFR bit@ ; 
 : UART0_UARTFR_RXFE@ 4 bit UART0_UARTFR bit@ ; 
 : UART0_UARTIMSC_RTIM! 6 bit UART0_UARTIMSC bis! ; 
 : UART0_UARTIMSC_TXIM! 5 bit UART0_UARTIMSC bis! ; 
 : UART0_UARTIMSC_RXIM! 4 bit UART0_UARTIMSC bis! ; 
 : UART0_UARTIMSC_RTIM_Clear 6 bit UART0_UARTIMSC bic! ; 
 : UART0_UARTIMSC_TXIM_Clear 5 bit UART0_UARTIMSC bic! ; 
 : UART0_UARTIMSC_RXIM_Clear 4 bit UART0_UARTIMSC bic! ; 
 : UART0_UARTIFLS_RXIFLSEL! UART0_UARTIFLS @ $38 bic swap $7 and 3 lshift or UART0_UARTIFLS ! ; 
 : UART0_UARTIFLS_TXIFLSEL! UART0_UARTIFLS @ $07 bic swap $7 and or UART0_UARTIFLS ! ; 
 : rx-full? rx-write-index @ rx-read-index @ rx-buffer-size 1- + $FF and = ; 
 : rx-empty? rx-read-index @ rx-write-index @ = ; 
 : write-rx [: x-full? not if rx-write-index @ rx-buffer + c! rx-write-index @ 1+ $FF and rx-write-index ! lse drop hen ;] serial-spinlock critical-with-spinlock ; 
 : read-rx [: x-empty? not if rx-read-index @ rx-buffer + c@ rx-read-index @ 1+ $FF and rx-read-index ! lse 0 hen ;] serial-spinlock critical-with-spinlock ; 
 : tx-full? tx-write-index @ tx-read-index @ tx-buffer-size 1- + $FF and = ; 
 : tx-empty? tx-read-index @ tx-write-index @ = ; 
 : write-tx [: x-full? not if tx-write-index @ tx-buffer + c! tx-write-index @ 1+ $FF and tx-write-index ! lse drop hen ;] serial-spinlock critical-with-spinlock ; 
 : read-tx [: x-empty? not if tx-read-index @ tx-buffer + c@ tx-read-index @ 1+ $FF and tx-read-index ! lse 0 hen ;] serial-spinlock critical-with-spinlock ; 
 : handle-io begin x-full? not if UART0_UARTFR_RXFE@ not if UART0_UARTDR_DATA@ uart-special-enabled @ if dup ctrl-c = if drop reboot false else attention? @ if attention-hook @ execute false else dup ctrl-t = if drop attention-start-hook @ execute false else write-rx false then then then else write-rx false then else true then lse true hen until rx-full? if ART0_UARTIMSC_RTIM_Clear ART0_UARTIMSC_RXIM_Clear then begin x-empty? not if UART0_UARTFR_TXFF@ not if read-tx UART0_UARTDR_DATA! false else true then lse true hen until tx-empty? if ART0_UARTIMSC_TXIM_Clear then uart0-irq NVIC_ICPR_CLRPEND! wake dmb dsb isb ; 
 : do-emit UART0_UARTIMSC_TXIM! tx-empty? UART0_UARTFR_TXFF@ not and if ART0_UARTDR_DATA! else : tx-full? not ;] wait rite-tx then ; 
 : do-key UART0_UARTIMSC_RTIM! UART0_UARTIMSC_RXIM! [: rx-empty? not ;] wait read-rx ; 
 : do-emit? tx-full? not ; 
 : do-key? rx-empty? not ; 
 : do-flush-console [: tx-empty? UART0_UARTFR_TXFE@ and ;] wait ; 
 : task-io ; 
 : serial-console ['] do-key key-hook ! ['] do-emit emit-hook ! ['] do-emit error-emit-hook ! ['] do-key? key?-hook ! ['] do-emit? emit?-hook ! ['] do-emit? error-emit?-hook ! ['] do-flush-console flush-console-hook ! ['] do-flush-console error-flush-console-hook ! ; 
 : enable-int-io disable-int 0 UART0_UARTIFLS_RXIFLSEL! 0 UART0_UARTIFLS_TXIFLSEL! 0 uart0-irq NVIC_IPR_IP! ['] handle-io uart0-vector vector! serial-console uart0-irq NVIC_ISER_SETENA! UART0_UARTIMSC_RTIM! UART0_UARTIMSC_RXIM! enable-int ; 
 : disable-int-io disable-int ['] serial-key key-hook ! ['] serial-emit emit-hook ! ['] serial-key? key?-hook ! ['] serial-emit? emit?-hook ! 0 flush-console-hook ! ['] handle-null uart0-vector vector! UART0_UARTIMSC_RTIM_Clear UART0_UARTIMSC_RXIM_Clear UART0_UARTIMSC_TXIM_Clear uart0-irq NVIC_ICER_CLRENA! enable-int ; 
 : init-int-io 0 rx-read-index ! 0 rx-write-index ! 0 tx-read-index ! 0 tx-write-index ! enable-int-io ; 
 : int-map-hash @ ; 
 : int-map-equals @ swap @ = ; 
 : int-map-size cell swap map-size ; 
 : init-int-map 2>r 2>r ['] int-map-hash ['] int-map-equals 2r> cell 2r> init-map ; 
 : find-int-map cell [: rot over ! swap find-map ;] with-aligned-allot ; 
 : insert-int-map cell [: rot over ! swap insert-map ;] with-aligned-allot ; 
 : remove-int-map cell [: rot over ! swap remove-map ;] with-aligned-allot ; 
 : at-int-map at-map @ ; 
 : entry-count constant ; 
 : find-int-map find-int-map ?dup if @ else -1 then ; 
 : insert-int-map rot cell [: tuck ! -rot insert-int-map ;] with-aligned-allot ; 
 : at-int-map at-int-map swap @ swap ; 
 : handle-remove cr ." @ . @ . ; 
 : init-test ['] handle-remove entry-count cell my-map init-int-map ['] handle-remove entry-count cell my-copy-map init-int-map 10 0 my-map insert-int-map 20 1 my-map insert-int-map 30 2 my-map insert-int-map 0 my-map find-int-map cr ." . 0 over my-map insert-int-map again ;] try drop ; 
 : jep106-id@ $E00FFFE4 @ 4 rshift $F and $E00FFFE8 @ $7 and 4 lshift or ; 
 : jep106-cont@ $E00FFFD0 @ $F and ; 
 : qif [inlined] swap if inline-execute else drop then ; 
 : qifelse [inlined] 2 pick if drop nip inline-execute else nip nip inline-execute then ; 
 : quntil { xt } begin xt execute until ; 
 : qagain { xt } begin xt execute again ; 
 : qwhile { while-xt body-xt } begin while-xt execute while body-xt execute repeat ; 
 : qcount { xt } ?do i xt execute loop ; 
 : qcount+ { xt } ?do i xt execute +loop ; 
 : citer { xt } over + { addr end-addr } begin addr end-addr u< while addr c@ xt execute 1 +to addr repeat ; 
 : hiter { xt } 2* over + { addr end-addr } begin addr end-addr u< while addr h@ xt execute 2 +to addr repeat ; 
 : iter { xt } cells over + { addr end-addr } begin addr end-addr u< while addr @ xt execute cell +to addr repeat ; 
 : 2iter { xt } 2* cells over + { addr end-addr } begin addr end-addr u< while addr 2@ xt execute 8 +to addr repeat ; 
 : iter-get rot { iter-xt get-xt } 0 ?do i get-xt execute iter-xt execute loop ; 
 : 2iter-get rot { iter-xt get-xt } 0 ?do i get-xt execute iter-xt execute loop ; 
 : citeri rot { xt addr } 0 ?do addr i + c@ i xt execute loop ; 
 : hiteri rot { xt addr } 0 ?do addr i 2* + h@ i xt execute loop ; 
 : iteri rot { xt addr } 0 ?do addr i cells + @ i xt execute loop ; 
 : 2iteri rot { xt addr } 0 ?do addr i 2* cells + 2@ i xt execute loop ; 
 : iteri-get rot { iter-xt get-xt } 0 ?do i get-xt execute i iter-xt execute loop ; 
 : 2iteri-get rot { iter-xt get-xt } 0 ?do i get-xt execute i iter-xt execute loop ; 
 : cqmap { src-addr dst-addr count xt } count 0 ?do src-addr i + c@ xt execute dst-addr i + c! loop ; 
 : hqmap { src-addr dst-addr count xt } count 0 ?do src-addr i 2* + h@ xt execute dst-addr i 2* + h! loop ; 
 : qmap { src-addr dst-addr count xt } count 0 ?do src-addr i cells + @ xt execute dst-addr i cells + ! loop ; 
 : 2qmap { src-addr dst-addr count xt } count 0 ?do src-addr i 2* cells + 2@ xt execute dst-addr i 2* cells + 2! loop ; 
 : qmap-get-set { get-xt count map-xt set-xt } count 0 ?do i get-xt execute map-xt execute i set-xt execute loop ; 
 : 2qmap-get-set { get-xt count map-xt set-xt } count 0 ?do i get-xt execute map-xt execute i set-xt execute loop ; 
 : cqmapi { src-addr dst-addr count xt } count 0 ?do src-addr i + c@ i xt execute dst-addr i + c! loop ; 
 : hqmapi { src-addr dst-addr count xt } count 0 ?do src-addr i 2* + h@ i xt execute dst-addr i 2* + h! loop ; 
 : qmapi { src-addr dst-addr count xt } count 0 ?do src-addr i cells + @ i xt execute dst-addr i cells + ! loop ; 
 : 2qmapi { src-addr dst-addr count xt } count 0 ?do src-addr i 2* cells + 2@ i xt execute dst-addr i 2* cells + 2! loop ; 
 : qmapi-get-set { get-xt count map-xt set-xt } count 0 ?do i get-xt execute i map-xt execute i set-xt execute loop ; 
 : 2qmapi-get-set { get-xt count map-xt set-xt } count 0 ?do i get-xt execute i map-xt execute i set-xt execute loop ; 
 : cfilter 0 { src-addr dst-addr count xt total } count 0 ?do src-addr i + c@ dup { val } xt execute if val dst-addr total + c! 1 +to total then loop total ; 
 : hfilter 0 { src-addr dst-addr count xt total } count 0 ?do src-addr i 2* + h@ dup { val } xt execute if val dst-addr total 2* + h! 1 +to total then loop total ; 
 : filter 0 { src-addr dst-addr count xt total } count 0 ?do src-addr i cells + @ dup { val } xt execute if val dst-addr total cells + ! 1 +to total then loop total ; 
 : 2filter 0 { src-addr dst-addr count xt total } count 0 ?do src-addr i 2* cells + 2@ 2dup { D: val } xt execute if val dst-addr total 2* cells + 2! 1 +to total then loop total ; 
 : filter-get-set 0 { get-xt count filter-xt set-xt total } count 0 ?do i get-xt execute dup { val } filter-xt execute if val total set-xt execute 1 +to total then loop total ; 
 : 2filter-get-set 0 { get-xt count filter-xt set-xt total } count 0 ?do i get-xt execute 2dup { D: val } filter-xt execute if val total set-xt execute 1 +to total then loop total ; 
 : cfilteri 0 { src-addr dst-addr count xt total } count 0 ?do src-addr i + c@ dup { val } i xt execute if val dst-addr total + c! 1 +to total then loop total ; 
 : hfilteri 0 { src-addr dst-addr count xt total } count 0 ?do src-addr i 2* + h@ dup { val } i xt execute if val dst-addr total 2* + h! 1 +to total then loop total ; 
 : filteri 0 { src-addr dst-addr count xt total } count 0 ?do src-addr i cells + @ dup { val } i xt execute if val dst-addr total cells + ! 1 +to total then loop total ; 
 : 2filteri 0 { src-addr dst-addr count xt total } count 0 ?do src-addr i 2* cells + 2@ 2dup { D: val } i xt execute if val dst-addr total 2* cells + 2! 1 +to total then loop total ; 
 : filteri-get-set 0 { get-xt count filter-xt set-xt total } count 0 ?do i get-xt execute dup { val } i filter-xt execute if val total set-xt execute 1 +to total then loop total ; 
 : 2filteri-get-set 0 { get-xt count filter-xt set-xt total } count 0 ?do i get-xt execute 2dup { D: val } i filter-xt execute if val total set-xt execute 1 +to total then loop total ; 
 : cfind-index rot { xt addr } 0 ?do addr i + c@ xt execute if i unloop exit then loop -1 ; 
 : hfind-index rot { xt addr } 0 ?do addr i 2* + h@ xt execute if i unloop exit then loop -1 ; 
 : find-index rot { xt addr } 0 ?do addr i cells + @ xt execute if i unloop exit then loop -1 ; 
 : 2find-index rot { xt addr } 0 ?do addr i 2* cells + 2@ xt execute if i unloop exit then loop -1 ; 
 : find-get-index rot { pred-xt get-xt } 0 ?do i get-xt execute pred-xt execute if i unloop exit then loop -1 ; 
 : 2find-get-index rot { pred-xt get-xt } 0 ?do i get-xt execute pred-xt execute if i unloop exit then loop -1 ; 
 : cfind-value rot { xt addr } 0 ?do addr i + c@ dup { val } xt execute if val true unloop exit then loop 0 false ; 
 : hfind-value rot { xt addr } 0 ?do addr i 2* + h@ dup { val } xt execute if val true unloop exit then loop 0 false ; 
 : find-value rot { xt addr } 0 ?do addr i cells + @ dup { val } xt execute if val true unloop exit then loop 0 false ; 
 : 2find-value rot { xt addr } 0 ?do addr i 2* cells + 2@ 2dup { D: val } xt execute if val true unloop exit then loop 0 0 false ; 
 : find-get-value rot { pred-xt get-xt } 0 ?do i get-xt execute dup { val } pred-xt execute if val true unloop exit then loop 0 false ; 
 : 2find-get-value rot { pred-xt get-xt } 0 ?do i get-xt execute 2dup { D: val } pred-xt execute if val true unloop exit then loop 0 0 false ; 
 : verify cr type ." then ; 
 : test-qif-true 0 true [: 1+ ;] qif 1 = s" verify ; 
 : test-qif-false 0 false [: 1+ ;] qif 0 = s" verify ; 
 : test-qifelse-true 0 true [: 1+ ;] [: 1- ;] qifelse 1 = s" verify ; 
 : test-qifelse-false 0 false [: 1+ ;] [: 1- ;] qifelse -1 = s" verify ; 
 : test-quntil 0 10 [: swap 1- swap 1- dup 0= ;] quntil drop -10 = s" verify ; 
 : test-qagain [: 0 [: 1+ dup 10 = [: [: ;] ?raise ;] qif ;] qagain ;] try drop true s" verify ; 
 : test-qwhile 0 10 [: ?dup ;] [: swap 1- swap 1- ;] qwhile -10 = s" verify ; 
 : test-qcount 0 10 0 [: + ;] qcount 45 = s" verify ; 
 : test-qcount+ 0 20 0 [: + 2 ;] qcount+ 90 = s" verify ; 
 : test-citer 0 carray 10 [: + ;] citer 45 = s" verify ; 
 : test-citeri 0 carray 10 [: + + ;] citeri 90 = s" verify ; 
 : test-hiter 0 harray 10 [: + ;] hiter 45 = s" verify ; 
 : test-hiteri 0 harray 10 [: + + ;] hiteri 90 = s" verify ; 
 : test-iter 0 array 10 [: + ;] iter 45 = s" verify ; 
 : test-iteri 0 array 10 [: + + ;] iteri 90 = s" verify ; 
 : test-2iter 0. 2array 10 [: d+ ;] 2iter 45. d= s" verify ; 
 : test-2iteri 0. 2array 10 [: s>d d+ d+ ;] 2iteri 90. d= s" verify ; 
 : test-iter-get 0 [: ;] 10 [: + ;] iter-get 45 = s" verify ; 
 : test-iteri-get 0 [: ;] 10 [: + + ;] iteri-get 90 = s" verify ; 
 : test-2iter-get 0. [: s>d ;] 10 [: d+ ;] 2iter-get 45. d= s" verify ; 
 : test-2iteri-get 0. [: s>d ;] 10 [: s>d d+ d+ ;] 2iteri-get 90. d= s" verify ; 
 : test-cqmap 10 [: { dst-array } carray dst-array 10 [: 2* ;] cqmap 0 dst-array 10 [: + ;] citer 90 = s" verify ;] with-aligned-allot ; 
 : test-hqmap 10 2* [: { dst-array } harray dst-array 10 [: 2* ;] hqmap 0 dst-array 10 [: + ;] hiter 90 = s" verify ;] with-aligned-allot ; 
 : test-qmap 10 cells [: { dst-array } array dst-array 10 [: 2* ;] qmap 0 dst-array 10 [: + ;] iter 90 = s" verify ;] with-aligned-allot ; 
 : test-2qmap 10 2* cells [: { dst-array } 2array dst-array 10 [: 2. d* ;] 2qmap 0. dst-array 10 [: d+ ;] 2iter 90. d= s" verify ;] with-aligned-allot ; 
 : test-qmap-get-set 0 [: ;] 10 [: 2* ;] [: + + ;] qmap-get-set 135 = s" verify ; 
 : test-2qmap-get-set 0. [: s>d ;] 10 [: 2. d* ;] [: s>d d+ d+ ;] 2qmap-get-set 135. d= s" verify ; 
 : test-cqmapi 10 [: { dst-array } carray dst-array 10 [: + ;] cqmapi 0 dst-array 10 [: + ;] citer 90 = s" verify ;] with-aligned-allot ; 
 : test-hqmapi 10 2* [: { dst-array } harray dst-array 10 [: + ;] hqmapi 0 dst-array 10 [: + ;] hiter 90 = s" verify ;] with-aligned-allot ; 
 : test-qmapi 10 cells [: { dst-array } array dst-array 10 [: + ;] qmapi 0 dst-array 10 [: + ;] iter 90 = s" verify ;] with-aligned-allot ; 
 : test-2qmapi 10 2* cells [: { dst-array } 2array dst-array 10 [: s>d d+ ;] 2qmapi 0. dst-array 10 [: d+ ;] 2iter 90. d= s" verify ;] with-aligned-allot ; 
 : test-qmapi-get-set 0 [: ;] 10 [: + ;] [: + + ;] qmapi-get-set 135 = s" verify ; 
 : test-2qmapi-get-set 0. [: s>d ;] 10 [: s>d d+ ;] [: s>d d+ d+ ;] 2qmapi-get-set 135. d= s" verify ; 
 : test-cfilter 10 [: { dst-array } carray dst-array 10 [: 2 umod 0= ;] cfilter { count' } 0 dst-array count' [: + ;] citer 20 = count' 5 = and s" verify ;] with-aligned-allot ; 
 : test-hfilter 10 2* [: { dst-array } harray dst-array 10 [: 2 umod 0= ;] hfilter { count' } 0 dst-array count' [: + ;] hiter 20 = count' 5 = and s" verify ;] with-aligned-allot ; 
 : test-filter 10 cells [: { dst-array } array dst-array 10 [: 2 umod 0= ;] filter { count' } 0 dst-array count' [: + ;] iter 20 = count' 5 = and s" verify ;] with-aligned-allot ; 
 : test-2filter 10 2* cells [: { dst-array } 2array dst-array 10 [: 2. ud/mod 2drop d0= ;] 2filter { count' } 0. dst-array count' [: d+ ;] 2iter 20. d= count' 5 = and s" verify ;] with-aligned-allot ; 
 : test-filter-get-set 0 [: ;] 10 [: 2 umod 0= ;] [: + + ;] filter-get-set { count' } 30 = count' 5 = and s" verify ; 
 : test-2filter-get-set 0. [: s>d ;] 10 [: 2. ud/mod 2drop d0= ;] [: s>d d+ d+ ;] 2filter-get-set { count' } 30. d= count' 5 = and s" verify ; 
 : test-cfilteri 10 [: { dst-array } carray dst-array 10 [: + 3 umod 0= ;] cfilteri { count' } 0 dst-array count' [: + ;] citer 18 = count' 4 = and s" verify ;] with-aligned-allot ; 
 : test-hfilteri 10 2* [: { dst-array } harray dst-array 10 [: + 3 umod 0= ;] hfilteri { count' } 0 dst-array count' [: + ;] hiter 18 = count' 4 = and s" verify ;] with-aligned-allot ; 
 : test-filteri 10 cells [: { dst-array } array dst-array 10 [: + 3 umod 0= ;] filteri { count' } 0 dst-array count' [: + ;] iter 18 = count' 4 = and s" verify ;] with-aligned-allot ; 
 : test-2filteri 10 2* cells [: { dst-array } 2array dst-array 10 [: s>d d+ 3. ud/mod 2drop d0= ;] 2filteri { count' } 0. dst-array count' [: d+ ;] 2iter 18. d= count' 4 = and s" verify ;] with-aligned-allot ; 
 : test-filteri-get-set 0 [: ;] 10 [: + 2 umod 0= ;] [: + + ;] filteri-get-set { count' } 90 = count' 10 = and s" verify ; 
 : test-2filteri-get-set 0. [: s>d ;] 10 [: s>d d+ 2. ud/mod 2drop d0= ;] [: s>d d+ d+ ;] 2filteri-get-set { count' } 90. d= count' 10 = and s" verify ; 
 : test-cfind-index cfind-array 6 [: 5 = ;] cfind-index 3 = s" verify ; 
 : test-cfind-index-fail cfind-array 6 [: 8 = ;] cfind-index -1 = s" verify ; 
 : test-hfind-index hfind-array 6 [: 5 = ;] hfind-index 3 = s" verify ; 
 : test-hfind-index-fail hfind-array 6 [: 8 = ;] hfind-index -1 = s" verify ; 
 : test-find-index find-array 6 [: 5 = ;] find-index 3 = s" verify ; 
 : test-find-index-fail find-array 6 [: 8 = ;] find-index -1 = s" verify ; 
 : test-2find-index 2find-array 6 [: 5. d= ;] 2find-index 3 = s" verify ; 
 : test-2find-index-fail 2find-array 6 [: 8. d= ;] 2find-index -1 = s" verify ; 
 : test-find-get-index [: cells find-array + @ ;] 6 [: 5 = ;] find-get-index 3 = s" verify ; 
 : test-find-get-index-fail [: cells find-array + @ ;] 6 [: 8 = ;] find-get-index -1 = s" verify ; 
 : test-2find-get-index [: 2* cells 2find-array + 2@ ;] 6 [: 5. d= ;] 2find-get-index 3 = s" verify ; 
 : test-2find-get-index-fail [: 2* cells 2find-array + 2@ ;] 6 [: 8. d= ;] 2find-get-index -1 = s" verify ; 
 : test-cfind-value cfind-array 6 [: 3 > ;] cfind-value swap 5 = and s" verify ; 
 : test-cfind-value-fail cfind-array 6 [: 7 > ;] cfind-value not swap 0 = and s" verify ; 
 : test-hfind-value hfind-array 6 [: 3 > ;] hfind-value swap 5 = and s" verify ; 
 : test-hfind-value-fail hfind-array 6 [: 7 > ;] hfind-value not swap 0 = and s" verify ; 
 : test-find-value find-array 6 [: 3 > ;] find-value swap 5 = and s" verify ; 
 : test-find-value-fail find-array 6 [: 7 > ;] find-value not swap 0 = and s" verify ; 
 : test-2find-value 2find-array 6 [: 3. d> ;] 2find-value -rot 5. d= and s" verify ; 
 : test-2find-value-fail 2find-array 6 [: 7. d> ;] 2find-value not -rot 0. d= and s" verify ; 
 : test-find-get-value [: cells find-array + @ ;] 6 [: 3 > ;] find-get-value swap 5 = and s" verify ; 
 : test-find-get-value-fail [: cells find-array + @ ;] 6 [: 7 > ;] find-get-value not swap 0 = and s" verify ; 
 : test-2find-get-value [: 2* cells 2find-array + 2@ ;] 6 [: 3. d> ;] 2find-get-value -rot 5. d= and s" verify ; 
 : test-2find-get-value-fail [: 2* cells 2find-array + 2@ ;] 6 [: 7. d> ;] 2find-get-value not -rot 0. d= and s" verify ; 
 : run-tests test-qif-true test-qif-false test-qifelse-true test-qifelse-false test-quntil test-qagain test-qwhile test-qcount test-qcount+ test-citer test-citeri test-hiter test-hiteri test-iter test-iteri test-2iter test-2iteri test-iter-get test-iteri-get test-2iter-get test-2iteri-get test-cqmap test-hqmap test-qmap test-2qmap test-qmap-get-set test-2qmap-get-set test-cqmapi test-hqmapi test-qmapi test-2qmapi test-qmapi-get-set test-2qmapi-get-set test-cfilter test-hfilter test-filter test-2filter test-filter-get-set test-2filter-get-set test-cfilteri test-hfilteri test-filteri test-2filteri test-filteri-get-set test-2filteri-get-set test-cfind-index test-cfind-index-fail test-hfind-index test-hfind-index-fail test-find-index test-find-index-fail test-2find-index test-2find-index-fail test-find-get-index test-find-get-index-fail test-2find-get-index test-2find-get-index-fail test-cfind-value test-cfind-value-fail test-hfind-value test-hfind-value-fail test-find-value test-find-value-fail test-2find-value test-2find-value-fail test-find-get-value test-find-get-value-fail test-2find-get-value test-2find-get-value-fail ; 
 : off constant ; 
 : on constant ; 
 : green constant ; 
 : red constant ; 
 : blue constant ; 
 : x-led-out-of-range ." cr ; 
 : xiao? variable ; 
 : wio? variable ; 
 : detect-xiao s" find dup if >xt execute else drop false then ; 
 : detect-wio s" find dup if >xt execute else drop false then ; 
 : led-count xiao? @ if 3 else 1 then ; 
 : validate-led wio? @ not if led-count u< averts x-led-out-of-range else dup 0= swap 2 = or averts x-led-out-of-range then ; 
 : pin-of-led xiao? @ if case 0 of 16 endof 1 of 17 endof 2 of 25 endof endcase else drop wio? @ if 13 else 25 then then ; 
 : led-init detect-xiao xiao? ! detect-wio wio? ! xiao? @ if red pin-of-led output-pin green pin-of-led output-pin blue pin-of-led output-pin high red pin-of-led pin! high green pin-of-led pin! high blue pin-of-led pin! else wio? @ if blue pin-of-led output-pin low blue pin-of-led pin! else green pin-of-led output-pin low green pin-of-led pin! then then ; 
 : led! dup validate-led swap xiao? @ xor swap pin-of-led pin! ; 
 : led@ dup validate-led pin-of-led pin-out@ xiao? @ xor ; 
 : toggle-led dup validate-led pin-of-led toggle-pin ; 
 : life-width variable ; 
 : life-height variable ; 
 : life-display-x variable ; 
 : life-display-y variable ; 
 : life-display-width variable ; 
 : life-display-height variable ; 
 : life-display-x-end variable ; 
 : life-display-y-end variable ; 
 : life-buffer-0 variable ; 
 : life-buffer-1 variable ; 
 : life-line-buffer variable ; 
 : current-buffer variable ; 
 : new-buffer variable ; 
 : alive? life-width @ 3 rshift * over 3 rshift + current-buffer @ + c@ swap 7 and rshift 1 and 0<> ; 
 : set-dead life-width @ 3 rshift * over 3 rshift + current-buffer @ + dup >r c@ swap 7 and 1 swap lshift bic r> c! ; 
 : set-alive life-width @ 3 rshift * over 3 rshift + current-buffer @ + dup >r c@ swap 7 and 1 swap lshift or r> c! ; 
 : alive! rot if set-alive else set-dead then ; 
 : new-alive? life-width @ 3 rshift * over 3 rshift + new-buffer @ + c@ swap 7 and rshift 1 and 0<> ; 
 : set-new-dead life-width @ 3 rshift * over 3 rshift + new-buffer @ + dup >r c@ swap 7 and 1 swap lshift bic r> c! ; 
 : set-new-alive life-width @ 3 rshift * over 3 rshift + new-buffer @ + dup >r c@ swap 7 and 1 swap lshift or r> c! ; 
 : new-alive! rot if set-new-alive else set-new-dead then ; 
 : wrap-coord dup life-height @ >= if drop 0 then dup 0< if drop life-height @ 1- then swap dup life-width @ >= if drop 0 then dup 0< if drop life-width @ 1- then swap ; 
 : get-border-cell-alive-count 0 >r 2dup 1+ wrap-coord alive? if r> 1+ >r then 2dup 1- wrap-coord alive? if r> 1+ >r then 2dup swap 1+ swap wrap-coord alive? if r> 1+ >r then 2dup swap 1- swap wrap-coord alive? if r> 1+ >r then 2dup 1+ swap 1+ swap wrap-coord alive? if r> 1+ >r then 2dup 1- swap 1+ swap wrap-coord alive? if r> 1+ >r then 2dup 1+ swap 1- swap wrap-coord alive? if r> 1+ >r then 1- swap 1- swap wrap-coord alive? if r> 1+ >r then r> ; 
 : get-cell-alive-count 0 >r 2dup 1+ alive? if r> 1+ >r then 2dup 1- alive? if r> 1+ >r then 2dup swap 1+ swap alive? if r> 1+ >r then 2dup swap 1- swap alive? if r> 1+ >r then 2dup 1+ swap 1+ swap alive? if r> 1+ >r then 2dup 1- swap 1+ swap alive? if r> 1+ >r then 2dup 1+ swap 1- swap alive? if r> 1+ >r then 1- swap 1- swap alive? if r> 1+ >r then r> ; 
 : cycle-alive-border-cell 2dup get-border-cell-alive-count dup 2 = swap 3 = or -rot new-alive! ; 
 : cycle-dead-border-cell 2dup get-border-cell-alive-count 3 = -rot new-alive! ; 
 : cycle-alive-cell 2dup get-cell-alive-count dup 2 = swap 3 = or -rot new-alive! ; 
 : cycle-dead-cell 2dup get-cell-alive-count 3 = -rot new-alive! ; 
 : cycle-border-cell 2dup alive? if cycle-alive-border-cell else cycle-dead-border-cell then ; 
 : cycle-cell 2dup alive? if cycle-alive-cell else cycle-dead-cell then ; 
 : switch-buffers current-buffer @ new-buffer @ current-buffer ! new-buffer ! ; 
 : cycle-life 0 begin dup life-height @ < while 0 over cycle-border-cell life-width @ 1- over cycle-border-cell 1+ repeat drop 0 begin dup life-width @ < while dup 0 cycle-border-cell dup life-height @ 1- cycle-border-cell 1+ repeat drop 1 begin dup life-width @ 1- < while 1 begin dup life-height @ 1- < while dup cycle-cell 1+ repeat drop 1+ repeat drop switch-buffers ; 
 : display-life hide-cursor 0 0 go-to-coord life-display-y @ begin dup life-display-y-end @ < while life-display-x @ begin dup life-display-x-end @ < while dup swap alive? if ." else space then 1+ repeat drop 1+ cr repeat show-cursor ; 
 : init-sixel escape emit ." ; 
 : sixel-rle-count variable ; 
 : sixel-rle-value variable ; 
 : init-sixel-rle 0 sixel-rle-count ! 0 sixel-rle-value ! ; 
 : add-sixel-rle sixel-rle-count @ 0= if 1 sixel-rle-count ! sixel-rle-value ! else dup sixel-rle-value @ <> if ixel-rle-count @ 3 > if ." sixel-rle-count @ (dec.) lse sixel-rle-count @ 2 > if sixel-rle-value @ emit then sixel-rle-count @ 1 > if sixel-rle-value @ emit then hen ixel-rle-value @ emit sixel-rle-count ! then sixel-rle-value ! 1 sixel-rle-count +! then ; 
 : add-sixel-rle2 sixel-rle-count @ 0= if 2 sixel-rle-count ! sixel-rle-value ! else dup sixel-rle-value @ <> if ixel-rle-count @ 3 > if ." sixel-rle-count @ (dec.) lse sixel-rle-count @ 2 > if sixel-rle-value @ emit then sixel-rle-count @ 1 > if sixel-rle-value @ emit then hen ixel-rle-value @ emit sixel-rle-count ! then sixel-rle-value ! 2 sixel-rle-count +! then ; 
 : force-sixel-rle-out sixel-rle-count @ 0<> if sixel-rle-count @ 3 > if " !" sixel-rle-count @ (dec.) else ixel-rle-count @ 2 > if sixel-rle-value @ emit hen ixel-rle-count @ 1 > if sixel-rle-value @ emit hen then sixel-rle-value @ emit then ; 
 : display-life-sixel hide-cursor 0 0 go-to-coord init-sixel life-display-y @ 6 / 6 * begin dup life-display-y-end @ 6 / 6 * < while ." escape emit $5C emit show-cursor ; 
 : display-life-sixel2 hide-cursor 0 0 go-to-coord init-sixel life-display-y @ 3 / 3 * begin dup life-display-y-end @ 3 / 3 * < while ." escape emit $5C emit show-cursor ; 
 : run-life cr reset-ansi-term hide-cursor get-cursor-position drop 0 begin cycle-life over 0 go-to-coord 1+ ." dup . erase-end-of-line key? until key show-cursor 2drop ; 
 : run-life-term reset-ansi-term hide-cursor 0 0 go-to-coord erase-end-of-line erase-down begin cycle-life display-life key? until key show-cursor drop ; 
 : run-life-sixel reset-ansi-term hide-cursor 0 0 go-to-coord erase-end-of-line erase-down begin cycle-life display-life-sixel key? until key show-cursor drop ; 
 : run-life-sixel2 reset-ansi-term hide-cursor 0 0 go-to-coord erase-end-of-line erase-down begin cycle-life display-life-sixel2 key? until key show-cursor drop ; 
 : step-life reset-ansi-term 0 0 go-to-coord erase-end-of-line erase-down cycle-life display-life ; 
 : step-life-sixel reset-ansi-term 0 0 go-to-coord erase-end-of-line erase-down cycle-life display-life-sixel ; 
 : step-life-sixel2 reset-ansi-term 0 0 go-to-coord erase-end-of-line erase-down cycle-life display-life-sixel2 ; 
 : life-viewport! dup 3 pick + life-height @ <= if life-display-height ! else drop life-height @ 2 pick - life-display-height ! then dup 3 pick + life-width @ <= if life-display-width ! else drop life-width @ 2 pick - life-display-width ! then dup 0>= if dup life-height @ <= if ife-display-y ! else rop life-height @ life-display-y ! then else drop 0 life-display-y ! then dup 0>= if dup life-width @ <= if ife-display-x ! else rop life-width @ life-display-x ! then else drop 0 life-display-x ! then life-display-x @ life-display-width @ + life-display-x-end ! life-display-y @ life-display-height @ + life-display-y-end ! ; 
 : clear-life current-buffer @ life-width @ life-height @ * 3 rshift 0 fill ; 
 : init-life ram-here life-line-buffer ! over ram-allot 0 life-display-x ! 0 life-display-y ! 2dup life-height ! life-width ! 2dup life-display-height ! life-display-width ! ram-here dup life-buffer-0 ! current-buffer ! * 8 / dup ram-allot ram-here dup life-buffer-1 ! new-buffer ! ram-allot clear-life life-display-x @ life-display-width @ + life-display-x-end ! life-display-y @ life-display-height @ + life-display-y-end ! ; 
 : get-char begin dup 0 > if ver c@ dup $20 <> if rot 1 + rot 1 - rot true lse drop 1 - swap 1 + swap false hen else true then until ; 
 : set-multiple over >r 2swap begin get-char dup 0 <> while case char] _ of 2swap 2dup set-dead swap 1 + swap 2swap endof char] * of 2swap 2dup set-alive swap 1 + swap 2swap endof char] / of 2swap 1 + nip r@ swap 2swap endof endcase repeat drop 2drop 2drop r> drop ; 
 : flip-coord-part tuck - - ; 
 : coord-part-center 2 / + ; 
 : copy-next-to-current 3 pick begin dup 5 pick 4 pick + < while 3 pick begin dup 5 pick 4 pick + < while dup new-alive? 2 pick 2 pick alive! 1 + repeat drop 1 + repeat drop 2drop 2drop ; 
 : do-flip-horizontal 3 pick 2 pick coord-part-center 4 pick begin dup 6 pick 5 pick + < while 4 pick begin dup 6 pick 5 pick + < while dup alive? 2 pick 4 pick flip-coord-part 2 pick new-alive! 1 + repeat drop 1 + repeat 2drop 2drop 2drop ; 
 : do-flip-vertical 2 pick over coord-part-center 4 pick begin dup 6 pick 5 pick + < while 4 pick begin dup 6 pick 5 pick + < while dup alive? 2 pick 2 pick 5 pick flip-coord-part new-alive! 1 + repeat drop 1 + repeat 2drop 2drop 2drop ; 
 : flip-horizontal 3 pick 3 pick 3 pick 3 pick do-flip-horizontal copy-next-to-current ; 
 : flip-vertical 3 pick 3 pick 3 pick 3 pick do-flip-vertical copy-next-to-current ; 
 : ne constant ; 
 : se constant ; 
 : sw constant ; 
 : nw constant ; 
 : flip-2d case se of 2drop 2drop endof sw of flip-horizontal endof nw of 2over 2over flip-horizontal flip-vertical endof ne of flip-vertical endof endcase ; 
 : block s" 2swap set-multiple ; 
 : tub s" 2swap set-multiple ; 
 : boat s" 2over set-multiple rot 3 3 rot flip-2d ; 
 : blinker rot case 0 of s" endof endcase 2swap set-multiple ; 
 : glider rot case 0 of s" endof endcase 2over set-multiple rot 3 3 rot flip-2d ; 
 : r-pentomino s" 2over set-multiple rot 3 3 rot flip-2d ; 
 : line user ; 
 : history-block-count constant ; 
 : history-block-size constant ; 
 : backspace constant ; 
 : tab constant ; 
 : delete constant ; 
 : newline constant ; 
 : return constant ; 
 : ctrl-a constant ; 
 : ctrl-b constant ; 
 : ctrl-e constant ; 
 : ctrl-f constant ; 
 : history-next @ ; 
 : history-string cell+ ; 
 : history-first line @ line-history-first @ ; 
 : history-prev history-first 2dup <> if begin dup history-next 2 pick <> while history-next repeat nip else 2drop 0 then ; 
 : history-last history-first begin dup history-next while history-next repeat ; 
 : history-evict history-last dup history-first = if line @ line-history-heap free 0 line @ line-history-first ! else dup history-prev 0 swap ! line @ line-history-heap free then ; 
 : history-allocate 5 + begin [: dup line @ line-history-heap allocate ;] try dup ['] x-allocate-failed = if rop history-evict false else raise nip true then until ; 
 : history-front dup history-prev ?dup if over @ swap ! history-first over ! line @ line-history-first ! else drop then ; 
 : history-current line @ line-history-current @ ; 
 : history-changed? history-current ?dup if cell+ count line @ line-buffer-ptr @ line @ line-count-ptr @ @ equal-strings? not else true then ; 
 : history-add dup history-allocate history-first over ! dup line @ line-history-first ! 2dup cell+ c! 5 + swap move ; 
 : unicode-start? $C0 and $C0 = ; 
 : unicode? $80 and 0<> ; 
 : update-start-position get-cursor-position line @ line-start-column h! line @ line-start-row h! ; 
 : update-terminal-size get-terminal-size line @ line-terminal-columns h! line @ line-terminal-rows h! line @ line-start-column h@ line @ line-terminal-columns h@ >= if 0 line @ line-start-column h! 1 line @ line-start-row h+! line @ line-start-row h@ line @ line-terminal-rows h@ >= if ine @ line-terminal-rows h@ 1- line @ line-start-row h! then then ; 
 : start-position line @ line-start-row h@ line @ line-start-column h@ ; 
 : offset-position line @ line-start-column h@ + dup line @ line-terminal-columns h@ / line @ line-start-row h@ + swap line @ line-terminal-columns h@ mod ; 
 : cursor-position line @ line-offset h@ offset-position ; 
 : end-position line @ line-count h@ offset-position ; 
 : total-lines line @ line-count h@ line @ line-start-column h@ + line @ line-terminal-columns h@ / ; 
 : adjust-start-row line @ line-terminal-rows h@ 1- total-lines line @ line-start-row h@ + - dup 0< if dup line @ line-start-row h+! scroll-up else drop then ; 
 : type-line 0 line @ line-buffer-ptr @ line @ line-count-ptr @ @ + line @ line-buffer-ptr @ ?do i c@ dup tab <> if up emit up unicode-start? swap $80 u< or if 1+ hen else rop dup 7 bic 8 + dup rot - 0 ?do $20 emit loop then loop drop ; 
 : update-line [: adjust-start-row start-position go-to-coord type-line end-position go-to-coord erase-down erase-end-of-line cursor-position go-to-coord ;] execute-hide-cursor ; 
 : reset-line reset-ansi-term line-upload-mode line @ line-flags bic! 0 line @ line-index-ptr @ ! 0 line @ line-count-ptr @ ! 0 line @ line-offset h! 0 line @ line-count h! update-start-position update-terminal-size ; 
 : get-spaces-to-index line @ line-count-ptr @ @ min 0 swap 0 ?do line @ line-buffer-ptr @ i + c@ dup tab = if rop 7 bic 8 + else up unicode-start? if drop 1+ lse dup $20 >= swap $80 < and if 1+ then hen then loop ; 
 : delete-byte line @ line-index-ptr @ @ 0> if line @ line-buffer-ptr @ line @ line-index-ptr @ @ + dup 1- line @ line-count-ptr @ @ line @ line-index-ptr @ @ - move -1 line @ line-index-ptr @ +! -1 line @ line-count-ptr @ +! then ; 
 : delete-byte-forward line @ line-count-ptr @ @ line @ line-index-ptr @ @ > if line @ line-buffer-ptr @ line @ line-index-ptr @ @ + dup swap 1+ swap line @ line-count-ptr @ @ 1- line @ line-index-ptr @ @ - move -1 line @ line-count-ptr @ +! then ; 
 : insert-byte line @ line-count-ptr @ @ line @ line-buffer-size @ < if line @ line-buffer-ptr @ line @ line-index-ptr @ @ + dup 1+ line @ line-count-ptr @ @ line @ line-index-ptr @ @ - move line @ line-buffer-ptr @ line @ line-index-ptr @ @ + c! 1 line @ line-index-ptr @ +! 1 line @ line-count-ptr @ +! true else drop false then ; 
 : append-byte line @ line-count-ptr @ @ line @ line-buffer-size @ < if line @ line-buffer-ptr @ line @ line-index-ptr @ @ + c! 1 line @ line-index-ptr @ +! 1 line @ line-count-ptr @ +! true else drop false then ; 
 : left-bytes 0 line @ line-index-ptr @ @ begin dup 0> if wap 1+ swap 1- dup line @ line-buffer-ptr @ + c@ up unicode-start? if drop true lse unicode? not hen else rue then until drop ; 
 : right-bytes line @ line-index-ptr @ @ line @ line-count-ptr @ @ < if line @ line-buffer-ptr @ line @ line-index-ptr @ @ + c@ dup $80 u< if rop 1 else line @ line-index-ptr @ @ 1+ begin dup line @ line-count-ptr @ @ u< if dup line @ line-buffer-ptr @ + c@ dup unicode-start? if drop drop true else unicode? if + swap 1+ swap false else rop true then then else drop true then ntil then else 0 then ; 
 : handle-delete line @ line-offset h@ 0> if left-bytes line @ line-index-ptr @ @ over - get-spaces-to-index line @ line-index-ptr @ @ get-spaces-to-index - dup line @ line-offset h+! line @ line-count h+! 0 ?do delete-byte loop update-line then ; 
 : handle-delete-forward line @ line-offset h@ line @ line-count h@ < if right-bytes 0 ?do delete-byte-forward loop line @ line-count-ptr @ @ get-spaces-to-index line @ line-count h! update-line then ; 
 : handle-insert line @ line-index-ptr @ @ line @ line-count-ptr @ @ < if line @ line-index-ptr @ @ get-spaces-to-index swap insert-byte if ine @ line-index-ptr @ @ get-spaces-to-index swap - up line @ line-offset h+! line @ line-count h+! pdate-line else rop then else line @ line-index-ptr @ @ get-spaces-to-index swap dup tab <> if ppend-byte if line @ line-index-ptr @ @ get-spaces-to-index swap - dup line @ line-offset h+! line @ line-count h+! line @ line-buffer-ptr @ line @ line-index-ptr @ @ + 1- c@ emit hen else ppend-byte if line @ line-index-ptr @ @ get-spaces-to-index swap - 0 ?do 1 line @ line-offset h+! 1 line @ line-count h+! $20 emit loop hen then then ; 
 : handle-forward line @ line-index-ptr @ @ line @ line-count-ptr @ @ < if line @ line-index-ptr @ @ get-spaces-to-index right-bytes line @ line-index-ptr @ +! line @ line-index-ptr @ @ get-spaces-to-index swap - line @ line-offset h+! update-line then ; 
 : handle-backward line @ line-index-ptr @ @ 0> if line @ line-index-ptr @ @ get-spaces-to-index left-bytes negate line @ line-index-ptr @ +! line @ line-index-ptr @ @ get-spaces-to-index swap - line @ line-offset h+! update-line then ; 
 : handle-start 0 line @ line-index-ptr @ ! 0 line @ line-offset h! update-line ; 
 : handle-end line @ line-count-ptr @ @ line @ line-index-ptr @ ! line @ line-count h@ line @ line-offset h! update-line ; 
 : set-buffer-for-history cell+ dup c@ dup line @ line-index-ptr @ ! dup line @ line-count-ptr @ ! dup get-spaces-to-index dup line @ line-offset h! line @ line-count h! swap 1+ line @ line-buffer-ptr @ rot move update-line ; 
 : clear-buffer 0 line @ line-offset h! 0 line @ line-count h! 0 line @ line-index-ptr @ ! 0 line @ line-count-ptr @ ! update-line ; 
 : handle-history-next history-current if history-current history-next ?dup if up line @ line-history-current ! set-buffer-for-history then else history-first if istory-first dup line @ line-history-current ! set-buffer-for-history then then ; 
 : handle-history-prev history-current if history-current history-first <> if istory-current history-prev dup line @ line-history-current ! et-buffer-for-history else line @ line-history-current ! clear-buffer then then ; 
 : continue-upload? get-key dup escape = if drop get-key dup [char] O = if rop get-key dup [char] Q = if false else set-key true then else et-key true then else set-key true then ; 
 : handle-upload-byte line @ line-count-ptr @ @ line @ line-buffer-size @ < if dup emit line @ line-buffer-ptr @ line @ line-index-ptr @ @ + c! 1 line @ line-index-ptr @ +! 1 line @ line-count-ptr @ +! else drop then ; 
 : handle-upload-delete-byte line @ line-index-ptr @ @ 0> if -1 line @ line-index-ptr @ +! -1 line @ line-count-ptr @ +! backspace emit space backspace emit then ; 
 : reset-upload 0 line @ line-index-ptr @ ! 0 line @ line-count-ptr @ ! ; 
 : handle-upload reset-upload xon ack continue-upload? if begin et-key up $20 u< if case return of true endof newline of true endof tab of tab handle-upload-byte false endof swap false swap endcase lse dup delete = if drop handle-upload-delete-byte else handle-upload-byte then false hen until 0 line @ line-index-ptr @ ! xoff else cr ." line @ line-edit-deferred @ refill-hook ! line-upload-mode line @ line-flags bic! then ; 
 : handle-set-upload 0 line @ line-index-ptr @ ! 0 line @ line-count-ptr @ ! 0 line @ line-offset h! 0 line @ line-count h! update-line s" tuck type offset-position go-to-coord ['] handle-upload refill-hook ! line-upload-mode line @ line-flags bis! ; 
 : handle-escape get-key case [char] [ of et-key case [char] A of handle-history-next false endof [char] B of handle-history-prev false endof [char] C of handle-forward false endof [char] D of handle-backward false endof [char] 3 of get-key case [char] ~ of handle-delete-forward false endof dup set-key swap false swap endcase endof dup set-key swap false swap ndcase endof [char] O of et-key case [char] P of handle-set-upload true endof dup set-key swap false swap ndcase endof dup set-key swap false swap endcase ; 
 : line-edit xon ack reset-line begin get-key dup $20 u< if ase return of true endof newline of true endof tab of tab handle-insert false endof ctrl-a of handle-start false endof ctrl-e of handle-end false endof ctrl-f of handle-forward false endof ctrl-b of handle-backward false endof escape of handle-escape endof swap false swap ndcase else up delete = if drop handle-delete lse handle-insert hen alse then until line @ line-flags @ line-upload-mode and 0= if history-changed? if ine @ line-count-ptr @ @ if line @ line-buffer-ptr @ line @ line-count-ptr @ @ history-add hen else istory-current history-front then end-position go-to-coord then 0 line @ line-history-current ! 0 line @ line-index-ptr @ ! xoff ; 
 : init-line 4 align, here line-size allot swap 255 min swap tuck line-buffer-size ! tuck line-buffer-ptr ! tuck line-count-ptr ! tuck line-index-ptr ! 0 over line-start-row h! 0 over line-start-column h! 0 over line-terminal-rows h! 0 over line-terminal-columns h! 0 over line-offset h! 0 over line-count h! 0 over line-history-first ! 0 over line-history-current ! 0 over line-flags ! ['] line-edit over line-edit-deferred ! history-block-size history-block-count 2 pick line-history-heap init-heap line ! ; 
 : init-line-refill >in input# input input-size init-line ; 
 : sensor-count constant ; 
 : temp-count variable ; 
 : temp-task variable ; 
 : io-irq constant ; 
 : temp-pin constant ; 
 : handle-gpio temp-pin PROC0_INTS_GPIO_EDGE_LOW@ if 1 temp-count +! then temp-pin INTR_GPIO_EDGE_LOW! ; 
 : sensor sensor-size * sensors + ; 
 : temp-tracker begin sensor-count 0 ?do 0 temp-count ! i sensor sensor-pin @ output-pin io-irq NVIC_ISER_SETENA! high i sensor sensor-pin @ pin! 104 ms low i sensor sensor-pin @ pin! i sensor sensor-pin @ input-pin io-irq NVIC_ICER_CLRENA! emp-count @ dup i sensor temp ! 0<> if true i sensor temp-read? ! false i sensor temp-error? ! lse false i sensor temp-read? ! true i sensor temp-error? ! hen 04 ms loop again ; 
 : x-temp-error space ." cr ; 
 : x-sensor-out-of-range space ." cr ; 
 : read-temp dup sensor-count u>= triggers x-sensor-out-of-range sensor begin dup temp-read? @ over temp-error? @ or not while pause repeat dup temp-error? @ triggers x-temp-error temp @ ; 
 : read-temp-c read-temp 0 swap 16,0 f/ 50,0 d- ; 
 : read-temp-f read-temp-c 1,8 f* 32,0 d+ ; 
 : sensor! sensor sensor-pin ! ; 
 : init-sensors sensor-count 0 ?do 0 i sensor temp ! false i sensor temp-read? ! false i sensor temp-error? ! loop ; 
 : init-temp io-irq NVIC_ICER_CLRENA! temp-pin input-pin temp-pin pull-up-pin temp-pin fast-pin 17 0 sensor! init-sensors ['] handle-gpio io-vector vector! true temp-pin PROC0_INTE_GPIO_EDGE_LOW! 0 io-irq NVIC_IPR_IP! 0 ['] temp-tracker 420 128 512 spawn temp-task ! 1 temp-task @ task-priority! temp-task @ run ; 
 : display-temp dup sensor-count u>= triggers x-sensor-out-of-range >r r@ read-temp-f r@ read-temp-c r@ read-temp cr ." ; 
 : display-temps dup sensor-count u> triggers x-sensor-out-of-range begin dup 0 ?do i display-temp loop 1000 ms again ; 
 : display-temps-task variable ; 
 : start-display-temps dup sensor-count u> triggers x-sensor-out-of-range 1 ['] display-temps 420 128 512 spawn display-temps-task ! 0 display-temps-task @ task-priority! display-temps-task @ run ; 
 : rolling-avg-buf-count constant ; 
 : sensor-count constant ; 
 : temp-count variable ; 
 : temp-task variable ; 
 : io-irq constant ; 
 : temp-pin constant ; 
 : handle-gpio temp-pin PROC0_INTS_GPIO_EDGE_LOW@ if 1 temp-count +! then temp-pin INTR_GPIO_EDGE_LOW! ; 
 : sensor sensor-size * sensors + ; 
 : add-rolling-avg { latest-temp sensor-index -- } sensor-index sensor { sensor } latest-temp sensor rolling-avg-index @ cells sensor rolling-avg-buf + ! sensor rolling-avg-index @ 1+ rolling-avg-buf-count umod sensor rolling-avg-index ! sensor rolling-avg-count @ 1+ rolling-avg-buf-count min sensor rolling-avg-count ! 0 { sum } sensor rolling-avg-count @ 0 ?do i cells sensor rolling-avg-buf + @ +to sum loop sum sensor rolling-avg-count @ / sensor temp ! true sensor temp-read? ! ; 
 : temp-tracker begin sensor-count 0 ?do 0 temp-count ! i sensor sensor-pin @ output-pin io-irq NVIC_ISER_SETENA! high i sensor sensor-pin @ pin! 104 ms low i sensor sensor-pin @ pin! i sensor sensor-pin @ input-pin io-irq NVIC_ICER_CLRENA! temp-count @ 0<> if temp-count @ i add-rolling-avg then 04 ms loop again ; 
 : x-temp-error space ." cr ; 
 : x-sensor-out-of-range space ." cr ; 
 : read-temp dup sensor-count u>= triggers x-sensor-out-of-range sensor begin dup temp-read? @ not while pause repeat temp @ ; 
 : read-temp-c read-temp 0 swap 16,0 f/ 50,0 d- ; 
 : read-temp-f read-temp-c 1,8 f* 32,0 d+ ; 
 : sensor! sensor sensor-pin ! ; 
 : init-sensors sensor-count 0 ?do 0 i sensor temp ! false i sensor temp-read? ! 0 i sensor rolling-avg-index ! 0 i sensor rolling-avg-count ! loop ; 
 : init-temp io-irq NVIC_ICER_CLRENA! temp-pin input-pin temp-pin pull-up-pin temp-pin fast-pin 17 0 sensor! init-sensors ['] handle-gpio io-vector vector! true temp-pin PROC0_INTE_GPIO_EDGE_LOW! 0 io-irq NVIC_IPR_IP! 0 ['] temp-tracker 420 128 512 spawn temp-task ! 1 temp-task @ task-priority! temp-task @ run ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-char-width constant ; 
 : my-char-height constant ; 
 : readout-string-size constant ; 
 : readout-count constant ; 
 : readout-interval constant ; 
 : update-interval constant ; 
 : random-fixed { max-lo max-hi -- d } random 0 max-lo max-hi f* ; 
 : init-readout { init-chars readout -- } readout readout-string readout-string-size $20 fill init-chars readout readout-string-len ! my-width init-chars my-char-width * - s>f random-fixed readout readout-x 2! my-height my-char-height - s>f random-fixed readout readout-y 2! pi 2,0 f* random-fixed { D: angle } angle cos readout-speed f* readout readout-x-delta 2! angle sin readout-speed f* readout readout-y-delta 2! systick-counter readout readout-last-systick ! ; 
 : init-display display-inited? not if 14 15 my-buf my-width my-height SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object $80 1 i2c::i2c-internal::i2c-irq interrupt::NVIC_IPR_IP! init-simple-font 7 readout-c init-readout 7 readout-f init-readout true to display-inited? then ; 
 : draw-readout { readout -- } readout readout-string readout readout-string-len @ readout readout-x 2@ f>s readout readout-y 2@ f>s op-xor my-ssd1306 a-simple-font draw-string ; 
 : move-readout { readout -- } systick-counter { new-systick } new-systick readout readout-last-systick @ - s>f 10000,0 f/ { D: systick-diff } readout readout-x-delta 2@ systick-diff f* readout readout-x 2+! readout readout-y-delta 2@ systick-diff f* readout readout-y 2+! new-systick readout readout-last-systick ! ; 
 : bounce-readout { readout -- } readout readout-x 2@ d0<= if readout readout-x-delta 2@ dabs readout readout-x-delta 2! else readout readout-x 2@ readout readout-string-len @ my-char-width * s>f d+ my-width s>f d>= if readout readout-x-delta 2@ dabs dnegate readout readout-x-delta 2! then then readout readout-y 2@ d0<= if readout readout-y-delta 2@ dabs readout readout-y-delta 2! else readout readout-y 2@ my-char-height s>f d+ my-height s>f d>= if readout readout-y-delta 2@ dabs dnegate readout readout-y-delta 2! then then ; 
 : both-readouts { xt -- } readout-c xt execute readout-f xt execute ; 
 : cycle-readouts ['] draw-readout both-readouts my-ssd1306 update-display ['] draw-readout both-readouts ['] move-readout both-readouts ['] bounce-readout both-readouts ; 
 : set-readout-text { c-addr u readout -- } c-addr readout readout-string u move u readout readout-string-len ! ; 
 : append-readout-text { c-addr u readout -- } c-addr readout readout-string readout readout-string-len @ + u move u readout readout-string-len +! ; 
 : update-temp dup sensor-count u>= triggers x-sensor-out-of-range 32 [: { sensor buf } buf sensor read-temp-c 2 format-fixed-truncate readout-c set-readout-text s" readout-f append-readout-text ;] with-allot ; 
 : display-temps systick-counter { start-systick } start-systick { update-start-systick } begin display-temps? if systick-counter update-start-systick - update-interval > if 0 update-temp update-interval +to update-start-systick then cycle-readouts else my-ssd1306 clear-bitmap my-ssd1306 update-display then readout-interval start-systick current-task delay readout-interval +to start-systick again ; 
 : start-display-temps true to display-temps? display-temps-task 0= if init-display 0 ['] display-temps 512 128 512 spawn to display-temps-task 0 display-temps-task task-priority! display-temps-task run then ; 
 : stop-display-temps false to display-temps? ; 
 : sensor-count constant ; 
 : temp-count variable ; 
 : temp-task variable ; 
 : io-irq constant ; 
 : temp-pin constant ; 
 : handle-pio 0 PIO0 sm-rxf@ begin ?dup while dup 1 and if 1 temp-count +! then 1 rshift repeat PIO0_IRQ0 NVIC_ICPR_CLRPEND! ; 
 : sensor sensor-size * sensors + ; 
 : temp-tracker begin sensor-count 0 ?do 0 temp-count ! i sensor sensor-pin @ output-pin 0 INT_SM_RXNEMPTY IRQ0 PIO0 pio-interrupt-enable high i sensor sensor-pin @ pin! 104 ms low i sensor sensor-pin @ pin! i sensor sensor-pin @ input-pin pio-force 1 0 PIO0 sm-instr! begin 0 PIO0 sm-rx-fifo-level@ 0= until 0 INT_SM_RXNEMPTY IRQ0 PIO0 pio-interrupt-disable temp-count @ dup i sensor temp ! 0<> i sensor temp-read? ! 04 ms loop again ; 
 : x-temp-error space ." cr ; 
 : x-sensor-out-of-range space ." cr ; 
 : read-temp dup sensor-count u>= triggers x-sensor-out-of-range sensor begin dup temp-read? @ not while pause repeat temp @ ; 
 : read-temp-c read-temp 0 swap 16,0 f/ 50,0 d- ; 
 : read-temp-f read-temp-c 1,8 f* 32,0 d+ ; 
 : sensor! sensor sensor-pin ! ; 
 : init-sensors sensor-count 0 ?do 0 i sensor temp ! false i sensor temp-read? ! loop ; 
 : init-pio %0001 PIO0 sm-disable %0001 PIO0 sm-restart 0 1 0 PIO0 sm-clkdiv! temp-pin input-pin temp-pin pull-up-pin temp-pin fast-pin 32 0 PIO0 sm-push-threshold! 0 4 0 PIO0 sm-wrap! pio-code 5 PIO0 pio-instr-mem! 0 0 PIO0 sm-addr! ['] handle-pio PIO0_IRQ0 16 + vector! 0 PIO0_IRQ0 NVIC_IPR_IP! PIO0_IRQ0 NVIC_ISER_SETENA! %0001 PIO0 sm-enable ; 
 : init-temp PIO0_IRQ0 NVIC_ICER_CLRENA! 17 0 sensor! init-sensors init-pio 0 ['] temp-tracker 420 128 512 spawn temp-task ! 1 temp-task @ task-priority! temp-task @ run ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-char-width constant ; 
 : my-char-height constant ; 
 : readout-string-size constant ; 
 : readout-count constant ; 
 : readout-interval constant ; 
 : update-interval constant ; 
 : random-fixed { max-lo max-hi -- d } random 0 max-lo max-hi f* ; 
 : init-readout { init-chars readout -- } readout readout-string readout-string-size $20 fill init-chars readout readout-string-len ! my-width init-chars my-char-width * - s>f random-fixed readout readout-x 2! my-height my-char-height - s>f random-fixed readout readout-y 2! pi 2,0 f* random-fixed { D: angle } angle cos readout-speed f* readout readout-x-delta 2! angle sin readout-speed f* readout readout-y-delta 2! systick-counter readout readout-last-systick ! ; 
 : init-display display-inited? not if 14 15 my-buf my-width my-height SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object init-simple-font 7 readout-c init-readout 7 readout-f init-readout 7 readout-t init-readout true to display-inited? then ; 
 : draw-readout { readout -- } readout readout-string readout readout-string-len @ readout readout-x 2@ f>s readout readout-y 2@ f>s op-xor my-ssd1306 a-simple-font draw-string ; 
 : move-readout { readout -- } systick-counter { new-systick } new-systick readout readout-last-systick @ - s>f 10000,0 f/ { D: systick-diff } readout readout-x-delta 2@ systick-diff f* readout readout-x 2+! readout readout-y-delta 2@ systick-diff f* readout readout-y 2+! new-systick readout readout-last-systick ! ; 
 : bounce-readout { readout -- } readout readout-x 2@ d0<= if readout readout-x-delta 2@ dabs readout readout-x-delta 2! else readout readout-x 2@ readout readout-string-len @ my-char-width * s>f d+ my-width s>f d>= if readout readout-x-delta 2@ dabs dnegate readout readout-x-delta 2! then then readout readout-y 2@ d0<= if readout readout-y-delta 2@ dabs readout readout-y-delta 2! else readout readout-y 2@ my-char-height s>f d+ my-height s>f d>= if readout readout-y-delta 2@ dabs dnegate readout readout-y-delta 2! then then ; 
 : both-readouts { xt -- } readout-c xt execute readout-f xt execute readout-t xt execute ; 
 : cycle-readouts ['] draw-readout both-readouts my-ssd1306 update-display ['] draw-readout both-readouts ['] move-readout both-readouts ['] bounce-readout both-readouts ; 
 : set-readout-text { c-addr u readout -- } c-addr readout readout-string u move u readout readout-string-len ! ; 
 : append-readout-text { c-addr u readout -- } c-addr readout readout-string readout readout-string-len @ + u move u readout readout-string-len +! ; 
 : update-temp dup sensor-count u>= triggers x-sensor-out-of-range 32 [: { sensor buf } buf sensor read-temp-c 2 format-fixed-truncate readout-c set-readout-text s" readout-t append-readout-text ;] with-allot ; 
 : display-temps systick-counter { start-systick } start-systick { update-start-systick } begin display-temps? if systick-counter update-start-systick - update-interval > if 0 update-temp update-interval +to update-start-systick then cycle-readouts else my-ssd1306 clear-bitmap my-ssd1306 update-display then readout-interval start-systick current-task delay readout-interval +to start-systick again ; 
 : start-display-temps true to display-temps? display-temps-task 0= if init-display 0 ['] display-temps 512 128 512 spawn to display-temps-task 0 display-temps-task task-priority! display-temps-task run then ; 
 : stop-display-temps false to display-temps? ; 
 : sensor-count constant ; 
 : temp-count variable ; 
 : temp-task variable ; 
 : pwm-index constant ; 
 : pwm-wrap constant ; 
 : pwm-gpio-pin constant ; 
 : handle-pwm pwm-wrap temp-count +! pwm-index bit clear-pwm-int clear-pwm-pending ; 
 : sensor sensor-size * sensors + ; 
 : temp-tracker begin sensor-count 0 ?do 0 temp-count ! 0 pwm-index pwm-counter! i sensor sensor-pin @ output-pin pwm-index bit enable-pwm high i sensor sensor-pin @ pin! 104 ms low i sensor sensor-pin @ pin! i sensor sensor-pin @ input-pin pwm-index bit disable-pwm pwm-index pwm-counter@ temp-count @ + dup i sensor temp ! 0<> i sensor temp-read? ! 04 ms loop again ; 
 : x-temp-error space ." cr ; 
 : x-sensor-out-of-range space ." cr ; 
 : read-temp dup sensor-count u>= triggers x-sensor-out-of-range sensor begin dup temp-read? @ not while pause repeat temp @ ; 
 : read-temp-c read-temp 0 swap 16,0 f/ 50,0 d- ; 
 : read-temp-f read-temp-c 1,8 f* 32,0 d+ ; 
 : sensor! sensor sensor-pin ! ; 
 : init-sensors sensor-count 0 ?do 0 i sensor temp ! false i sensor temp-read? ! loop ; 
 : init-pwm pwm-gpio-pin pull-up-pin pwm-gpio-pin fast-pin pwm-gpio-pin pwm-pin 0 1 pwm-index pwm-clock-div! pwm-index falling-edge-pwm pwm-wrap pwm-index pwm-top! ['] handle-pwm pwm-vector! pwm-index bit enable-pwm-int ; 
 : init-temp 17 0 sensor! init-sensors init-pwm 0 ['] temp-tracker 420 128 512 spawn temp-task ! 1 temp-task @ task-priority! temp-task @ run ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-char-width constant ; 
 : my-char-height constant ; 
 : readout-string-size constant ; 
 : readout-count constant ; 
 : readout-interval constant ; 
 : update-interval constant ; 
 : random-fixed { max-lo max-hi -- d } random 0 max-lo max-hi f* ; 
 : init-readout { init-chars readout -- } readout readout-string readout-string-size $20 fill init-chars readout readout-string-len ! my-width init-chars my-char-width * - s>f random-fixed readout readout-x 2! my-height my-char-height - s>f random-fixed readout readout-y 2! pi 2,0 f* random-fixed { angle-lo angle-hi } angle-lo angle-hi cos readout-speed f* readout readout-x-delta 2! angle-lo angle-hi sin readout-speed f* readout readout-y-delta 2! systick-counter readout readout-last-systick ! ; 
 : init-display display-inited? not if 14 15 my-buf my-width my-height SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object init-simple-font 7 readout-c init-readout 7 readout-f init-readout 7 readout-t init-readout true to display-inited? then ; 
 : draw-readout { readout -- } readout readout-string readout readout-string-len @ readout readout-x 2@ f>s readout readout-y 2@ f>s op-xor my-ssd1306 a-simple-font draw-string ; 
 : move-readout { readout -- } systick-counter { new-systick } new-systick readout readout-last-systick @ - s>f 10000,0 f/ { systick-diff-lo systick-diff-hi } readout readout-x-delta 2@ systick-diff-lo systick-diff-hi f* readout readout-x 2+! readout readout-y-delta 2@ systick-diff-lo systick-diff-hi f* readout readout-y 2+! new-systick readout readout-last-systick ! ; 
 : bounce-readout { readout -- } readout readout-x 2@ d0<= if readout readout-x-delta 2@ dabs readout readout-x-delta 2! else readout readout-x 2@ readout readout-string-len @ my-char-width * s>f d+ my-width s>f d>= if readout readout-x-delta 2@ dabs dnegate readout readout-x-delta 2! then then readout readout-y 2@ d0<= if readout readout-y-delta 2@ dabs readout readout-y-delta 2! else readout readout-y 2@ my-char-height s>f d+ my-height s>f d>= if readout readout-y-delta 2@ dabs dnegate readout readout-y-delta 2! then then ; 
 : both-readouts { xt -- } readout-c xt execute readout-f xt execute readout-t xt execute ; 
 : cycle-readouts ['] draw-readout both-readouts my-ssd1306 update-display ['] draw-readout both-readouts ['] move-readout both-readouts ['] bounce-readout both-readouts ; 
 : set-readout-text { c-addr u readout -- } c-addr readout readout-string u move u readout readout-string-len ! ; 
 : append-readout-text { c-addr u readout -- } c-addr readout readout-string readout readout-string-len @ + u move u readout readout-string-len +! ; 
 : update-temp dup sensor-count u>= triggers x-sensor-out-of-range 32 [: { sensor buf } buf sensor read-temp-c 2 format-fixed-truncate readout-c set-readout-text s" readout-t append-readout-text ;] with-allot ; 
 : display-temps systick-counter { start-systick } start-systick { update-start-systick } begin display-temps? if systick-counter update-start-systick - update-interval > if 0 update-temp update-interval +to update-start-systick then cycle-readouts else my-ssd1306 clear-bitmap my-ssd1306 update-display then readout-interval start-systick current-task delay readout-interval +to start-systick again ; 
 : start-display-temps true to display-temps? display-temps-task 0= if init-display 0 ['] display-temps 512 128 512 spawn to display-temps-task 0 display-temps-task task-priority! display-temps-task run then ; 
 : stop-display-temps false to display-temps? ; 
 : pwm-index constant ; 
 : pwm-input-pin constant ; 
 : pwm-wrap constant ; 
 : sensor-output-pin constant ; 
 : temp-timeout constant ; 
 : x-temp-error space ." cr ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-char-width constant ; 
 : my-char-height constant ; 
 : readout-string-size constant ; 
 : random-fixed { max-lo max-hi -- d } random 0 max-lo max-hi f* ; 
 : readout-interval constant ; 
 : init-temp pwm-wrap pwm-input-pin pwm-index <pwm-slice> pwm-slice init-object pwm-slice sensor-output-pin <sensor> sensor init-object <tracker> tracker init-object sensor tracker add-tracker-sensor tracker run-tracker sensor <temp-display> temp-display init-object ; 
 : pwm-index constant ; 
 : pwm-input-pin constant ; 
 : pwm-wrap constant ; 
 : sensor-output-pin constant ; 
 : temp-timeout constant ; 
 : x-temp-error space ." cr ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-char-width constant ; 
 : my-char-height constant ; 
 : readout-string-size constant ; 
 : random-fixed { D: max-random -- d } random 0 max-random f* ; 
 : readout-interval constant ; 
 : temp-log-msg-size constant ; 
 : init-temp pwm-wrap pwm-input-pin pwm-index <pwm-slice> pwm-slice init-object pwm-slice sensor-output-pin <sensor> sensor init-object <tracker> tracker init-object sensor tracker add-tracker-sensor tracker run-tracker sensor <temp-display> temp-display init-object sensor <temp-log> temp-log init-object ; 
 : sensor-count constant ; 
 : temp-count variable ; 
 : temp-task variable ; 
 : io-irq constant ; 
 : temp-pin constant ; 
 : handle-gpio temp-pin PROC0_INTS_GPIO_EDGE_LOW@ if 1 temp-count +! then temp-pin INTR_GPIO_EDGE_LOW! ; 
 : sensor sensor-size * sensors + ; 
 : temp-tracker begin sensor-count 0 ?do 0 temp-count ! i sensor sensor-pin @ output-pin io-irq NVIC_ISER_SETENA! high i sensor sensor-pin @ pin! 104 ms low i sensor sensor-pin @ pin! i sensor sensor-pin @ input-pin io-irq NVIC_ICER_CLRENA! emp-count @ dup i sensor temp ! 0<> if true i sensor temp-read? ! false i sensor temp-error? ! lse false i sensor temp-read? ! true i sensor temp-error? ! hen 04 ms loop again ; 
 : x-temp-error space ." cr ; 
 : x-sensor-out-of-range space ." cr ; 
 : read-temp dup sensor-count u>= triggers x-sensor-out-of-range sensor begin dup temp-read? @ over temp-error? @ or not while pause repeat dup temp-error? @ triggers x-temp-error temp @ ; 
 : read-temp-c read-temp 0 swap 16,0 f/ 50,0 d- ; 
 : read-temp-f read-temp-c 1,8 f* 32,0 d+ ; 
 : sensor! sensor sensor-pin ! ; 
 : init-sensors sensor-count 0 ?do 0 i sensor temp ! false i sensor temp-read? ! false i sensor temp-error? ! loop ; 
 : init-temp io-irq NVIC_ICER_CLRENA! temp-pin input-pin temp-pin pull-up-pin temp-pin fast-pin 17 0 sensor! init-sensors ['] handle-gpio io-vector vector! true temp-pin PROC0_INTE_GPIO_EDGE_LOW! 0 io-irq NVIC_IPR_IP! 0 ['] temp-tracker 420 128 512 spawn temp-task ! 1 temp-task @ task-priority! temp-task @ run ; 
 : display-temp dup sensor-count u>= triggers x-sensor-out-of-range 32 [: { sensor buf } cr-ssd1306 buf sensor read-temp-c 2 format-fixed-truncate type-ssd1306 s" type-ssd1306 ;] with-allot ; 
 : display-temps begin display-temps? if 0 display-temp else erase-ssd1306 then 1000 ms again ; 
 : start-display-temps true to display-temps? display-temps-task 0= if 0 ['] display-temps 512 128 512 spawn to display-temps-task 0 display-temps-task task-priority! display-temps-task run then ; 
 : stop-display-temps false to display-temps? ; 
 : init-lock-wait ram-here 4 ram-align, ram-here lock-wait-size ram-allot tuck lock-wait-orig-here ! 0 over lock-wait-prev ! 0 over lock-wait-next ! current-task over lock-wait-task ! false over lock-wait-in-list ! ; 
 : max-lock-wait-priority -32768 swap lock-first-wait @ begin dup while up lock-wait-task @ task-priority@ rot max swap lock-wait-next @ repeat drop ; 
 : add-lock-wait { wait lock -- } 0 wait lock-wait-next ! lock lock-last-wait @ { last-wait } last-wait wait lock-wait-prev ! last-wait if wait last-wait lock-wait-next ! then wait lock lock-last-wait ! last-wait 0= if wait lock lock-first-wait ! then true wait lock-wait-in-list ! ; 
 : remove-lock-wait { wait lock -- removed? } wait lock-wait-in-list @ if wait lock-wait-prev @ wait lock-wait-next @ { prev-wait next-wait } next-wait if prev-wait next-wait lock-wait-prev ! else prev-wait lock lock-last-wait ! then prev-wait if next-wait prev-wait lock-wait-next ! else next-wait lock lock-first-wait ! then false wait lock-wait-in-list ! true else false then ; 
 : adjust-priority { priority task -- } task task-priority@ priority <= if task task-saved-priority@ task task-priority! else task task-priority@ task task-saved-priority! priority task task-priority! then ; 
 : save-priority { task -- } task ['] current-lock-held for-task@ 0= if task task-priority@ task task-saved-priority! then ; 
 : set-wait-priority { task lock -- } lock lock-holder-task @ ?dup if task save-priority task-priority@ task task-priority@ max task task-priority! then ; 
 : get-priority { task current-lock -- } task task-saved-priority@ { current-priority } begin current-lock while current-lock lock-first-wait @ { current-wait } begin current-wait while current-wait lock-wait-task @ task-priority@ current-priority max to current-priority current-wait lock-wait-next @ to current-wait repeat current-lock lock-prev-held @ to current-lock repeat current-priority ; 
 : register-holder { task lock -- } task ['] current-lock-held for-task@ { last-held } task lock get-priority task task-priority! last-held lock lock-prev-held ! lock task ['] current-lock-held for-task! task lock lock-holder-task ! ; 
 : restore-priority { task lock -- } task ['] current-lock-held for-task@ dup { first-lock current-lock } current-lock lock = if lock lock-prev-held @ task ['] current-lock-held for-task! task ['] current-lock-held for-task@ ?dup if task swap get-priority task task-priority! else task task-saved-priority@ task task-priority! then else begin current-lock lock = if 0 task ['] current-lock-held for-task! task task-saved-priority@ task task-priority! true else current-lock lock-prev-held @ { prev-held } prev-held lock = if prev-held lock-prev-held @ current-lock lock-prev-held ! task first-lock get-priority task task-priority! true else prev-held 0<> if prev-held to current-lock false else true then then then until then ; 
 : clear-lock-hold { lock -- } current-task lock restore-priority 0 lock lock-holder-task ! 0 lock lock-prev-held ! ; 
 : next-lock-hold { task lock -- } current-task lock restore-priority task lock lock-holder-task ! task lock register-holder ; 
 : init-lock dup lock-slock init-slock 0 over lock-holder-task ! 0 over lock-prev-held ! 0 over lock-first-wait ! 0 over lock-last-wait ! 0 swap lock-nest-level ! ; 
 : x-not-currently-owned ." cr ; 
 : release-lock [: { lock } s" trace ;] over lock-slock with-slock ; 
 : claim-lock [: { lock } s" trace ;] over lock-slock with-slock ; 
 : with-lock dup >r claim-lock try r> release-lock ?raise ; 
 : low-task variable ; 
 : middle-task variable ; 
 : high-task variable ; 
 : high begin 5000 ms lock-a claim-lock 5000 ms lock-a release-lock again ; 
 : middle begin 2500 ms lock-a claim-lock 2500 ms lock-b claim-lock 2500 ms lock-b release-lock 2500 ms lock-a release-lock again ; 
 : low begin lock-b claim-lock 10 0 ?do 000 ms urrent-task task-priority@ . loop lock-b release-lock again ; 
 : init-test lock-a init-lock lock-b init-lock 0 ['] low 420 128 512 spawn low-task ! 0 ['] middle 420 128 512 spawn middle-task ! 0 ['] high 420 128 512 spawn high-task ! 2 high-task @ task-priority! 1 middle-task @ task-priority! 0 low-task @ task-priority! begin-critical low-task @ run middle-task @ run high-task @ run end-critical ; 
 : low-task variable ; 
 : high-task variable ; 
 : high 2000 ms begin 1000 ms my-lock claim-lock 5 0 ?do ." 1000 ms loop my-lock release-lock again ; 
 : low begin my-lock claim-lock 5 0 ?do 000000 0 ?do loop urrent-task task-priority@ . space loop my-lock release-lock again ; 
 : init-test my-lock init-lock 0 ['] low 420 128 512 spawn low-task ! 0 ['] high 420 128 512 spawn high-task ! 1 high-task @ task-priority! low-task @ run high-task @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : do-task-1 no-timeout timeout ! [: cr ." ;] my-lock with-lock ; 
 : do-task-2 5000 timeout ! 25 ms [: cr ." ;] my-lock with-lock ; 
 : do-task-3 no-timeout timeout ! 50 ms [: cr ." ;] my-lock with-lock ; 
 : init-test my-lock init-lock 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : do-task-1 no-timeout timeout ! [: cr ." ;] my-lock with-lock ; 
 : do-task-2 no-timeout timeout ! 25 ms [: cr ." ;] my-lock with-lock ; 
 : do-task-3 5000 timeout ! 50 ms [: cr ." ;] my-lock with-lock ; 
 : init-test my-lock init-lock 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! [: cr ." ;] my-lock with-lock ; 
 : do-task-2 no-timeout timeout ! 25 ms [: cr ." ;] my-lock with-lock ; 
 : do-task-3 5000 timeout ! 50 ms [: cr ." ;] my-lock with-lock ; 
 : do-task-4 no-timeout timeout ! 75 ms [: cr ." ;] my-lock with-lock ; 
 : init-test my-lock init-lock 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! 0 ['] do-task-4 420 128 512 spawn my-task-4 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run my-task-4 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : do-task-1 no-timeout timeout ! [: cr ." ;] my-lock with-lock ; 
 : do-task-2 4500 timeout ! 25 ms [: cr ." ;] my-lock with-lock ; 
 : init-test my-lock init-lock 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! my-task-1 @ run my-task-2 @ run ; 
 : test-task variable ; 
 : init-test 0 [: begin again ;] 420 128 512 spawn test-task ! c" test-task @ task-name! test-mailboxes 1 test-task @ config-notify 255 0 test-task @ mailbox! 0 test-task @ mailbox@ . ; 
 : width constant ; 
 : height constant ; 
 : color c\" .`'-~+^\":;Il!i><tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$ " ; 
 : draw { D: xa D: xb D: ya D: yb -- } xb xa d- { D: x-mult } yb ya d- { D: y-mult } height 0 ?do cr width 0 ?do i s>f width s>f f/ x-mult f* xa d+ { D: x0 } j s>f height s>f f/ y-mult f* ya d+ { D: y0 } 0,0 0,0 { D: x D: y } 0 { iteration } begin x 2dup f* y 2dup f* d+ 4,0 d<= iteration max-iteration < and while x 2dup f* y 2dup f* d- x0 d+ { D: xtemp } x y f* 2,0 f* y0 d+ to y xtemp to x 1 +to iteration repeat color iteration + c@ emit loop loop ; 
 : test -2,00 0,47 -1,12 1,12 draw ; 
 : map-entry-size dup map-key-size @ swap map-value-size @ + cell align cell + ; 
 : map-entry dup map-entry-size rot * + map-header-size + ; 
 : key-hash map-hash-xt @ execute $FFFFFFFF umod 1+ ; 
 : map-init-index map-entry-count @ umod ; 
 : find-key rot >r r@ over map-init-index dup begin up 3 pick map-entry dup @ r@ = if cell+ 4 pick 4 pick map-equals-xt @ execute if nip nip nip rdrop exit else 1+ 2 pick map-entry-count @ umod then lse drop 1+ 2 pick map-entry-count @ umod hen 2dup = until 2drop 2drop rdrop 0 ; 
 : find-available tuck map-init-index begin dup swap map-entry @ 0= if nip exit lse 1+ over map-entry-count @ umod hen again ; 
 : x-map-index-out-of-range ." cr ; 
 : x-map-full ." cr ; 
 : x-dest-map-not-match ." cr ; 
 : x-map-index-no-entry ." cr ; 
 : map-size + cell align cell + * map-header-size + ; 
 : init-map tuck map-value-size ! tuck map-key-size ! tuck map-entry-count ! tuck map-remove-xt ! tuck map-equals-xt ! tuck map-hash-xt ! 0 over map-used-entry-count ! 0 begin 2dup swap map-entry-count @ < while 2dup swap map-entry 0 swap ! 1+ repeat 2drop ; 
 : find-map dup >r 2dup key-hash -rot find-key ?dup if r@ map-entry r> map-key-size @ cell+ + else rdrop 0 then ; 
 : insert-map 2dup key-hash >r 2dup r@ -rot find-key ?dup if rdrop swap >r r@ map-entry cell+ r@ map-remove-xt @ if up dup r@ map-key-size @ + swap r@ map-remove-xt @ execute then else dup map-used-entry-count @ over map-entry-count @ < averts x-map-full r> 2dup swap find-available rot >r r@ map-entry tuck ! cell+ 1 r@ map-used-entry-count +! then tuck r@ map-key-size @ move r@ map-key-size @ + r> map-value-size @ move ; 
 : remove-map dup >r 2dup key-hash -rot find-key ?dup if r@ map-entry 0 over ! -1 r@ map-used-entry-count +! r@ map-remove-xt @ if ell+ dup r@ map-key-size @ + swap r> map-remove-xt @ execute else drop then else rdrop then ; 
 : first-map >r 0 begin dup r@ map-entry @ 0<> if rdrop exit then 1+ dup r@ map-entry-count @ = until rdrop drop -1 ; 
 : next-map over 0 >= averts x-map-index-out-of-range 2dup map-entry-count @ < averts x-map-index-out-of-range >r 1+ begin dup r@ map-entry @ 0<> if rdrop exit then 1+ dup r@ map-entry-count @ = until rdrop drop -1 ; 
 : at-map over 0 >= averts x-map-index-out-of-range 2dup map-entry-count @ < averts x-map-index-out-of-range dup >r map-entry dup @ averts x-map-index-no-entry cell+ dup r> map-value-size @ + swap ; 
 : clear-map >r 0 r@ map-used-entry-count ! 0 begin dup r@ map-entry-count @ < while dup r@ map-entry dup @ if over ! @ map-remove-xt @ if cell+ dup r@ map-key-size @ + swap r@ map-remove-xt @ execute lse drop hen else rop then 1+ repeat drop rdrop ; 
 : copy-map 2dup map-value-size @ swap map-value-size @ = averts x-dest-map-not-match 2dup map-key-size @ swap map-key-size @ = averts x-dest-map-not-match 2dup map-equals-xt @ swap map-equals-xt @ = averts x-dest-map-not-match 2dup map-hash-xt @ swap map-hash-xt @ = averts x-dest-map-not-match >r r@ first-map begin dup -1 <> while dup r@ at-map 3 pick insert-map r@ next-map repeat 2drop rdrop ; 
 : map-entry-count map-entry-count @ ; 
 : map-used-entry-count map-used-entry-count @ ; 
 : map-key-size map-key-size @ ; 
 : map-value-size map-value-size @ ; 
 : map-hash-xt map-hash-xt @ ; 
 : map-equals-xt map-equals-xt @ ; 
 : map-remove-xt map-remove-xt @ ; 
 : led-loop begin green toggle-led dup ms again ; 
 : star-loop begin ." dup ms again ; 
 : core-1-main 1 ['] led-loop 420 128 512 spawn run 1 ['] star-loop 420 128 512 spawn run current-task kill ; 
 : init-test 1000 500 2 ['] core-1-main 420 128 512 1 spawn-on-core run 250 ms 750 1 ['] led-loop 420 128 512 spawn run ; 
 : flash-mini-dict-free variable ; 
 : x-flash-mini-dict-out-of-space ." cr ; 
 : hash-string code[ r0 1 dp ldm tos r0 r1 adds_,_,_ mark> tos r2 movs_,_ 7 tos tos lsls_,_,#_ 25 r2 r2 lsrs_,_,#_ r2 tos orrs_,_ 0 r0 r2 ldrb_,[_,#_] $61 r2 cmp_,#_ lo bc> $7A r2 cmp_,#_ hi bc> $20 r2 subs_,#_ >mark >mark r2 tos eors_,_ r1 r0 cmp_,_ eq bc< ]code ; 
 : hash-string-and-wid code[ tos 1 push tos 1 dp ldm ]code hash-string code[ r0 1 pop r0 tos eors_,_ 0 tos cmp_,#_ ne bc> 1 tos adds_,#_ >mark ]code ; 
 : hash-word code[ 8 tos r0 ldrb_,[_,#_] tos r1 movs_,_ 9 r1 adds_,#_ 2 tos tos ldrh_,[_,#_] 8 dp subs_,#_ 0 dp r0 str_,[_,#_] 4 dp r1 str_,[_,#_] ]code hash-string-and-wid ; 
 : clear-flash-mini-dict flash-mini-dict-size 2 cells / 1- flash-mini-dict-free ! flash-mini-dict-size flash-mini-dict code[ r0 1 dp ldm 0 r1 movs_,#_ mark> 4 r0 subs_,#_ r0 tos r1 str_,[_,_] 0 r0 cmp_,#_ ne bc< tos 1 dp ldm ]code ; 
 : register-flash-mini-dict-space flash-mini-dict-free @ averts x-flash-mini-dict-out-of-space -1 flash-mini-dict-free +! ; 
 : equal-words? code[ r0 1 dp ldm 2 tos r1 ldrh_,[_,#_] 2 r0 r2 ldrh_,[_,#_] r1 r2 cmp_,_ ne bc> 12 dp subs_,#_ tos r1 movs_,_ 9 r1 adds_,#_ 8 dp r1 str_,[_,#_] 8 tos r1 ldrb_,[_,#_] 4 dp r1 str_,[_,#_] r0 r1 movs_,_ 9 r1 adds_,#_ 0 dp r1 str_,[_,#_] 8 r0 tos ldrb_,[_,#_] ]code equal-case-strings? code[ pc 1 pop >mark 0 tos movs_,#_ pc 1 pop ]code ; 
 : add-flash-mini-dict-end code[ r5 r4 2 push r4 r3 r2 r1 4 dp ldm mark> 3 tos r0 lsls_,_,#_ r2 r0 r0 adds_,_,_ 4 r0 r5 ldr_,[_,#_] 0 r5 cmp_,#_ eq bc> tos r4 r3 r2 r1 r0 6 push 4 dp subs_,#_ 0 dp r4 str_,[_,#_] r5 tos movs_,_ ]code equal-words? code[ 0 tos cmp_,#_ eq bc> tos r4 r3 r2 r1 r0 6 pop 0 r0 r3 str_,[_,#_] 4 r0 r4 str_,[_,#_] tos 1 dp ldm pc r5 r4 3 pop >mark tos r4 r3 r2 r1 r0 6 pop 1 tos adds_,#_ r1 tos cmp_,_ 2over ne bc< 0 tos movs_,#_ 2swap b< >mark 0 r0 r3 str_,[_,#_] 4 r0 r4 str_,[_,#_] tos 1 dp ldm r5 r4 2 pop ]code register-flash-mini-dict-space ; 
 : add-flash-mini-dict-start code[ r5 r4 2 push r4 r3 r2 r1 4 dp ldm mark> 3 tos r0 lsls_,_,#_ r2 r0 r0 adds_,_,_ 4 r0 r5 ldr_,[_,#_] 0 r5 cmp_,#_ eq bc> tos r4 r3 r2 r1 r0 6 push 4 dp subs_,#_ 0 dp r4 str_,[_,#_] r5 tos movs_,_ ]code equal-words? code[ 0 tos cmp_,#_ eq bc> tos r4 r3 r2 r1 r0 6 pop tos 1 dp ldm pc r5 r4 3 pop >mark tos r4 r3 r2 r1 r0 6 pop 1 tos adds_,#_ r1 tos cmp_,_ 2over ne bc< 0 tos movs_,#_ 2swap b< >mark 0 r0 r3 str_,[_,#_] 4 r0 r4 str_,[_,#_] tos 1 dp ldm r5 r4 2 pop ]code register-flash-mini-dict-space ; 
 : compute-flash-mini-dict-free flash-mini-dict-size 2 cells / 1- flash-mini-dict-free ! flash-mini-dict-free flash-mini-dict flash-mini-dict-size + flash-mini-dict code[ r1 r0 2 dp ldm 0 r1 r2 ldr_,[_,#_] mark> r0 tos cmp_,_ ne bc> 0 r1 r2 str_,[_,#_] tos 1 dp ldm pc 1 pop >mark 0 tos r3 ldr_,[_,#_] 0 r3 cmp_,#_ ne bc> 1 r2 subs_,#_ >mark 8 tos adds_,#_ b< ]code ; 
 : init-flash-mini-dict flash-end flash-mini-dict flash-mini-dict-size move flash-mini-dict cell+ @ -1 = if clear-flash-mini-dict flash-latest begin ?dup while dup add-flash-mini-dict-start next-word @ repeat else compute-flash-mini-dict-free flash-latest begin ?dup while dup word-flags 1+ c@ if dup add-flash-mini-dict-start next-word @ else drop exit then repeat then ; 
 : find-flash-mini-dict code[ r5 r4 2 push r4 r3 r2 r1 4 dp ldm mark> 3 tos r0 lsls_,_,#_ r2 r0 r0 adds_,_,_ 0 r0 r5 ldr_,[_,#_] r5 r3 cmp_,_ ne bc> 4 r0 r5 ldr_,[_,#_] 2 r5 r5 ldrh_,[_,#_] r5 r4 cmp_,_ ne bc> tos r4 r3 r2 r1 r0 6 push 4 r0 r5 ldr_,[_,#_] 8 r5 r1 ldrb_,[_,#_] r5 r2 movs_,_ 9 r2 adds_,#_ r5 1 push 0 dp r3 ldr_,[_,#_] 4 dp r4 ldr_,[_,#_] 12 dp subs_,#_ 0 dp r2 str_,[_,#_] 4 dp r3 str_,[_,#_] 8 dp r4 str_,[_,#_] r1 tos movs_,_ ]code equal-case-strings? code[ 0 tos cmp_,#_ eq bc> tos 1 pop 8 dp adds_,#_ r5 r4 r3 r2 r1 r0 6 pop pc r5 r4 3 pop >mark r5 1 pop tos r4 r3 r2 r1 r0 6 pop >mark 1 tos adds_,#_ r1 tos cmp_,_ 2over ne bc< 0 tos movs_,#_ 2over b< >mark 0 r5 cmp_,#_ ne bc> 0 tos movs_,#_ 8 dp adds_,#_ pc r5 r4 3 pop >mark 1 tos adds_,#_ r1 tos cmp_,_ 2dup ne bc< 0 tos movs_,#_ b< ]code ; 
 : add-flash-mini-dict compiling-to-flash? if flash-latest add-flash-mini-dict-end then ; 
 : find-optimized-wid compiling-to-flash? if find-flash-mini-dict else 3dup ram-latest swap find-dict ?dup if ip nip nip else ind-flash-mini-dict then then ; 
 : find-optimized order-count @ 1 lshift order + order code[ tos r0 movs_,_ r3 r2 r1 3 dp ldm mark> 8 dp subs_,#_ 0 dp r2 str_,[_,#_] 4 dp r3 str_,[_,#_] 0 r0 tos ldrh_,[_,#_] r3 r2 r1 r0 4 push ]code find-optimized-wid code[ r3 r2 r1 r0 4 pop 0 tos cmp_,#_ eq bc> pc 1 pop >mark 2 r0 adds_,#_ r1 r0 cmp_,_ ne bc< ]code ; 
 : save-flash-mini-dict flash-latest word-flags 1+ c@ if flash-end erase-qspi-sector flash-mini-dict flash-mini-dict-size flash-end mass-qspi! flash-latest begin dup if dup word-flags 1+ c@ if dup flash-base >= over flash-end < and if 0 over word-flags 1+ cflash! then next-word @ false else true then else true then until drop then ; 
 : find-mini-by-xt drop [ flash-mini-dict flash-mini-dict-size + ] literal flash-mini-dict code[ r4 1 push 1 r4 movs_,#_ r1 r0 2 dp ldm mark> r0 tos cmp_,_ ne bc> 0 tos movs_,#_ pc r4 2 pop >mark 4 tos r2 ldr_,[_,#_] 0 r3 movs_,#_ r3 r2 cmp_,_ eq bc> r3 r3 mvns_,_ r3 r2 cmp_,_ eq bc> 8 r2 r3 ldrb_,[_,#_] r2 r3 r3 adds_,_,_ 8 r3 adds_,#_ r4 r3 orrs_,_ 1 r3 adds_,#_ r1 r3 cmp_,_ ne bc> r2 tos movs_,_ pc r4 2 pop >mark >mark >mark 8 tos adds_,#_ b< ]code ; 
 : max-order constant ; 
 : monitor-task variable ; 
 : saved-attention-hook variable ; 
 : monitor-mailbox constant ; 
 : display-tasks-msg constant ; 
 : do-attention dup [char] t = if drop false attention? ! display-tasks-msg monitor-mailbox monitor-task @ notify-set else saved-attention-hook @ execute then ; 
 : run-monitor begin monitor-mailbox wait-notify display-tasks-msg = if cr display-red ." display-normal dump-tasks then 0 monitor-mailbox current-task mailbox! again ; 
 : start-monitor [: inited? not if true to inited? true else false then ;] critical-with-all-core-spinlock if 0 ['] run-monitor 320 128 512 spawn monitor-task ! monitor-mailbox-buf 1 monitor-task @ config-notify c" monitor-task @ task-name! 32767 monitor-task @ task-priority! attention-hook @ saved-attention-hook ! monitor-task @ run ['] do-attention attention-hook ! then ; 
 : my-chan-count constant ; 
 : producer-task variable ; 
 : consumer-1-task variable ; 
 : consumer-2-task variable ; 
 : consumer-3-task variable ; 
 : consumer-4-task variable ; 
 : do-producer no-timeout timeout ! 0 begin [: cr ." dup . ;] my-lock with-lock dup [: my-chan send-chan ;] provide-allot-cell 1+ again ; 
 : do-consumer no-timeout timeout ! begin [: my-chan recv-chan ;] extract-allot-cell [: cr ." . ;] my-lock with-lock again ; 
 : init-test 1 cells my-chan-count my-chan init-chan my-lock init-lock 0 ['] do-producer 420 128 512 spawn producer-task ! 1 1 ['] do-consumer 420 128 512 spawn consumer-1-task ! 2 1 ['] do-consumer 420 128 512 spawn consumer-2-task ! 3 1 ['] do-consumer 420 128 512 spawn consumer-3-task ! 4 1 ['] do-consumer 420 128 512 spawn consumer-4-task ! producer-task @ run consumer-1-task @ run consumer-2-task @ run consumer-3-task @ run consumer-4-task @ run ; 
 : x-core-0-only ." cr ; 
 : x-spinlock-out-of-range ." cr ; 
 : x-core-out-of-range ." cr ; 
 : x-core-not-addressable ." cr ; 
 : SIO_BASE constant ; 
 : prepare-aux-rstack over @ over 2 cells - ! tuck swap cell + swap cell - ! ['] reboot 1 or over 3 cells - ! swap 1 or swap 4 cells - tuck ! ; 
 : trampoline [ $BCC3 h, $468E h, $4687 h, ] ; 
 : PSM_BASE constant ; 
 : validate-addressable-core dup cpu-count u< averts x-core-out-of-range cpu-index <> averts x-core-not-addressable ; 
 : sev [inlined] [ undefer-lit %1011111101000000 h, ] ; 
 : wfe [inlined] [ undefer-lit %1011111100100000 h, ] ; 
 : SIO_IRQ_PROC0 constant ; 
 : SIO_IRQ_PROC1 constant ; 
 : spinlock-count constant ; 
 : task-core-1-spinlock constant ; 
 : task-core-0-spinlock constant ; 
 : serial-spinlock constant ; 
 : test-set-spinlock constant ; 
 : rtc-spinlock constant ; 
 : spinlock-lock-count cpu-index spinlock-lock-counts code[ r1 r0 2 dp ldm 1 r1 r1 lsls_,_,#_ r1 r0 r0 adds_,_,_ 2 r0 r0 lsls_,_,#_ r0 tos tos adds_,_,_ ]code ; 
 : SPINLOCK [ SIO_BASE $100 + ] literal code[ r0 1 dp ldm 2 r0 r0 lsls_,_,#_ r0 tos tos adds_,_,_ ]code ; 
 : claim-spinlock-raw dup spinlock-lock-count code[ 0 tos r0 ldr_,[_,#_] 1 r0 adds_,#_ 0 tos r0 str_,[_,#_] 1 r0 cmp_,#_ eq bc> tos r0 2 dp ldm pc 1 pop >mark tos 1 dp ldm ]code SPINLOCK code[ mark> 0 tos r0 ldr_,[_,#_] 0 r0 cmp_,#_ eq bc< tos 1 dp ldm ]code ; 
 : release-spinlock-raw dup spinlock-lock-count code[ 0 tos r0 ldr_,[_,#_] 1 r0 subs_,#_ 0 tos r0 str_,[_,#_] 0 r0 cmp_,#_ eq bc> tos r0 2 dp ldm pc 1 pop >mark tos 1 dp ldm ]code SPINLOCK code[ 0 r0 movs_,#_ r0 r0 mvns_,_ 0 tos r0 str_,[_,#_] tos 1 dp ldm ]code ; 
 : claim-spinlock dup spinlock-lock-count code[ cpsid 0 tos r0 ldr_,[_,#_] 1 r0 adds_,#_ 0 tos r0 str_,[_,#_] 1 r0 cmp_,#_ eq bc> cpsie tos r0 2 dp ldm pc 1 pop >mark tos 1 dp ldm ]code SPINLOCK code[ mark> 0 tos r0 ldr_,[_,#_] 0 r0 cmp_,#_ eq bc< cpsie tos 1 dp ldm ]code ; 
 : release-spinlock dup spinlock-lock-count code[ cpsid 0 tos r0 ldr_,[_,#_] 1 r0 subs_,#_ 0 tos r0 str_,[_,#_] 0 r0 cmp_,#_ eq bc> tos r0 2 dp ldm cpsie pc 1 pop >mark tos 1 dp ldm ]code SPINLOCK code[ 0 r0 movs_,#_ r0 r0 mvns_,_ 0 tos r0 str_,[_,#_] tos 1 dp ldm cpsie ]code ; 
 : claim-spinlock-begin-critical disable-int claim-spinlock-raw 1 internal::in-critical +! enable-int ; 
 : release-spinlock-end-critical disable-int release-spinlock-raw internal::in-critical @ 1- 0 max dup internal::in-critical ! 0= if internal::deferred-context-switch @ false internal::deferred-context-switch ! if pause then then enable-int ; 
 : claim-same-core-spinlock cpu-index task-core-0-spinlock + claim-spinlock ; 
 : release-same-core-spinlock cpu-index task-core-0-spinlock + release-spinlock ; 
 : claim-all-core-spinlock-raw task-core-0-spinlock claim-spinlock-raw task-core-1-spinlock claim-spinlock-raw ; 
 : release-all-core-spinlock-raw task-core-0-spinlock release-spinlock-raw task-core-1-spinlock release-spinlock-raw ; 
 : claim-other-core-spinlock task-core-0-spinlock + claim-spinlock ; 
 : release-other-core-spinlock task-core-0-spinlock + release-spinlock ; 
 : claim-all-core-spinlock task-core-0-spinlock claim-spinlock task-core-1-spinlock claim-spinlock ; 
 : release-all-core-spinlock task-core-0-spinlock release-spinlock task-core-1-spinlock release-spinlock ; 
 : claim-all-core-spinlock-begin-critical disable-int task-core-0-spinlock claim-spinlock-raw task-core-1-spinlock claim-spinlock-raw 1 internal::in-critical +! enable-int ; 
 : release-all-core-spinlock-end-critical disable-int task-core-0-spinlock release-spinlock-raw task-core-1-spinlock release-spinlock-raw internal::in-critical @ 1- 0 max dup internal::in-critical ! 0= if internal::deferred-context-switch @ false internal::deferred-context-switch ! if pause then then enable-int ; 
 : with-spinlock >r r@ claim-spinlock try r> release-spinlock ?raise ; 
 : critical-with-spinlock >r r@ claim-spinlock-begin-critical try r> release-spinlock-end-critical ?raise ; 
 : critical-with-other-core-spinlock task-core-0-spinlock + >r r@ claim-spinlock-begin-critical try r> release-spinlock-end-critical ?raise ; 
 : begin-critical-with-other-core-spinlock task-core-0-spinlock + claim-spinlock-begin-critical ; 
 : end-critical-with-other-core-spinlock task-core-0-spinlock + release-spinlock-end-critical ; 
 : critical-with-all-core-spinlock claim-all-core-spinlock-begin-critical try release-all-core-spinlock-end-critical ?raise ; 
 : test-set [ test-set-spinlock SPINLOCK ] literal code[ cpsid r1 r0 2 dp ldm mark> 0 tos r2 ldr_,[_,#_] 0 r2 cmp_,#_ eq bc< 0 r0 r2 ldr_,[_,#_] 0 r2 cmp_,#_ ne bc> 0 r0 r1 str_,[_,#_] 0 r2 movs_,#_ r2 r2 mvns_,_ 0 tos r2 str_,[_,#_] r2 tos movs_,_ cpsie pc 1 pop >mark 0 r2 movs_,#_ r2 r2 mvns_,_ 0 tos r2 str_,[_,#_] 0 tos movs_,#_ cpsie ]code ; 
 : test-set-raw [ test-set-spinlock SPINLOCK ] literal code[ r1 r0 2 dp ldm mark> 0 tos r2 ldr_,[_,#_] 0 r2 cmp_,#_ eq bc< 0 r0 r2 ldr_,[_,#_] 0 r2 cmp_,#_ ne bc> 0 r0 r1 str_,[_,#_] 0 r2 movs_,#_ r2 r2 mvns_,_ 0 tos r2 str_,[_,#_] r2 tos movs_,_ pc 1 pop >mark 0 r2 movs_,#_ r2 r2 mvns_,_ 0 tos r2 str_,[_,#_] 0 tos movs_,#_ ]code ; 
 : fifo-drain validate-addressable-core begin FIFO_ST_VLD FIFO_ST bit@ while FIFO_RD @ drop repeat sev ; 
 : fifo-push-blocking validate-addressable-core begin FIFO_ST_RDY FIFO_ST bit@ until FIFO_WR ! sev ; 
 : fifo-pop-blocking validate-addressable-core begin FIFO_ST_VLD FIFO_ST bit@ until FIFO_RD @ sev ; 
 : fifo-push-confirm dup validate-addressable-core 2dup fifo-push-blocking fifo-pop-blocking = ; 
 : launch-aux-core 1 = averts x-core-out-of-range prepare-aux-rstack SIO_IRQ_PROC0 NVIC_ICER_CLRENA! 6 0 do i case of 1 fifo-drain 0 endof of 1 fifo-drain 0 endof of 1 endof of vector-table endof of dup endof of ['] trampoline 3 + endof endcase 1 fifo-push-confirm if else negate then +loop drop $00 SIO_IRQ_PROC0 NVIC_IPR_IP! SIO_IRQ_PROC0 NVIC_ISER_SETENA! ; 
 : prepare-reboot cpu-index 0= if hold-core spinlock-count 0 ?do -1 i SPINLOCK ! loop else disable-int $B007B007 0 fifo-push-blocking begin again then ; 
 : reset-aux-core 1 = averts x-core-out-of-range ; 
 : producer-task variable ; 
 : consumer-1-task variable ; 
 : consumer-2-task variable ; 
 : consumer-3-task variable ; 
 : consumer-4-task variable ; 
 : do-producer no-timeout timeout ! 0 begin [: cr ." dup . ;] my-lock with-lock dup [: my-fchan send-fchan ;] provide-allot-cell 1+ again ; 
 : do-consumer no-timeout timeout ! begin [: my-fchan recv-fchan ;] extract-allot-cell [: cr ." . ;] my-lock with-lock again ; 
 : init-test my-fchan init-fchan my-lock init-lock 0 ['] do-producer 420 128 512 spawn producer-task ! 1 1 ['] do-consumer 420 128 512 spawn consumer-1-task ! 2 1 ['] do-consumer 420 128 512 spawn consumer-2-task ! 3 1 ['] do-consumer 420 128 512 spawn consumer-3-task ! 4 1 ['] do-consumer 420 128 512 spawn consumer-4-task ! producer-task @ run consumer-1-task @ run consumer-2-task @ run consumer-3-task @ run consumer-4-task @ run ; 
 : locker <builds , , , does> dup @ swap cell + dup @ ms cell + @ current-task task-priority! dup claim-lock release-lock begin 1000 ms again current-task kill ; 
 : monitor-priority swap 0 ?do dup ms current-task task-priority@ . loop drop ; 
 : do-lock-all lock-a claim-lock lock-b claim-lock lock-c claim-lock 40 100 monitor-priority space ." current-task kill ; 
 : task-lock-all variable ; 
 : task-lock-a variable ; 
 : task-lock-b variable ; 
 : task-lock-c variable ; 
 : init-test lock-a init-lock lock-b init-lock lock-c init-lock 0 ['] do-lock-all 420 128 512 spawn task-lock-all ! 0 ['] do-lock-a 420 128 512 spawn task-lock-a ! 0 ['] do-lock-b 420 128 512 spawn task-lock-b ! 0 ['] do-lock-c 420 128 512 spawn task-lock-c ! begin-critical task-lock-all @ run task-lock-a @ run task-lock-b @ run task-lock-c @ run end-critical ; 
 : task-0 variable ; 
 : task-1 variable ; 
 : task-2 variable ; 
 : task-3 variable ; 
 : init-test 0 [: begin 500 ms ." again ;] 420 128 512 0 spawn-on-core task-3 ! task-1 @ run task-3 @ run task-0 @ run task-2 @ run ; 
 : x-out-of-range-neopixel ." cr ; 
 : x-out-of-range-color ." cr ; 
 : send-neopixel { grb addr -- } begin addr neopixel-sm @ addr neopixel-pio @ sm-tx-fifo-level@ 0= until grb addr neopixel-sm @ addr neopixel-pio @ sm-txf! ; 
 : neopixel-size cells neopixel-header-size + ; 
 : neopixel-count@ neopixel-count @ ; 
 : neopixel! { r g b index addr -- } index addr neopixel-count @ u< averts x-out-of-range-neopixel r 256 u< averts x-out-of-range-color g 256 u< averts x-out-of-range-color b 256 u< averts x-out-of-range-color r $FF and 8 lshift g $FF and 16 lshift or b $FF and or 8 lshift addr neopixel-header-size + index cells + ! ; 
 : neopixel@ { index addr -- r g b } index addr neopixel-count @ u< averts x-out-of-range-neopixel addr neopixel-header-size + index cells + @ 8 rshift { grb } grb 8 rshift $FF and grb 16 rshift $FF and grb $FF and ; 
 : update-neopixel { addr -- } addr neopixel-count @ 0 ?do addr neopixel-header-size + i cells + @ addr send-neopixel loop ; 
 : clear-neopixel { addr -- } addr neopixel-count @ 0 ?do 0 addr neopixel-header-size + i cells + ! loop ; 
 : init-neopixel { init-sm init-pio init-count init-pin addr -- } init-pin pio-internal::validate-pin init-pio pio-internal::validate-pio init-sm pio-internal::validate-sm init-pin addr neopixel-pin ! init-count addr neopixel-count ! init-pio addr neopixel-pio ! init-sm addr neopixel-sm ! addr clear-neopixel init-sm bit init-pio sm-disable init-sm bit init-pio sm-restart 160 15 init-sm init-pio sm-clkdiv! left init-sm init-pio sm-out-shift-dir on init-sm init-pio sm-autopull! 24 init-sm init-pio sm-pull-threshold! off init-pin init-sm init-pio sm-pin! out init-pin init-sm init-pio sm-pindir! init-pin 1 init-sm init-pio sm-sideset-pins! off init-sm init-pio sm-sideset-high-enable! off init-sm init-pio sm-sideset-pindir! 0 3 init-sm init-pio sm-wrap! neopixel-program 4 0 init-pio pio-instr-relocate-mem! 0 init-sm init-pio sm-addr! init-sm bit init-pio sm-enable ; 
 : neopixel-count constant ; 
 : neopixel-power constant ; 
 : neopixel-data constant ; 
 : neopixel-pio constant ; 
 : neopixel-sm constant ; 
 : run-neopixel-test 0,0 { D: angle } begin key? not while angle cos 255,0 f* nip 0 max 255 min abs { r } angle pi 2,0 3,0 f/ f* d+ cos 255,0 f* nip 0 max 255 min abs { g } angle pi 2,0 3,0 f/ f* d- cos 255,0 f* nip 0 max 255 min abs { b } r g b 0 my-neopixel neopixel! angle pi 0,0625 f* d+ 2dup pi 2,0 f* d>= if pi 2,0 f* d- then to angle my-neopixel update-neopixel 50 ms repeat key drop ; 
 : x-out-of-range-floor-count ." cr ; 
 : max-floor-count constant ; 
 : no-elevator-dir constant ; 
 : elevator-up-dir constant ; 
 : elevator-down-dir constant ; 
 : elevator-delay constant ; 
 : cycle-msg constant ; 
 : floor-up-msg constant ; 
 : floor-down-msg constant ; 
 : floor-stop-msg constant ; 
 : init-test { count -- } count <world> [: { world } world run-world ;] with-object ; 
 : consumer-task variable ; 
 : producer-task variable ; 
 : consumer 0 wait-notify-indefinite drop begin 0 wait-notify-indefinite . 1 wait-notify-indefinite . 0 producer-task @ notify again ; 
 : producer 0 wait-notify-indefinite drop 0 begin dup 0 consumer-task @ notify-set 1+ dup 1 consumer-task @ notify-set 1+ 0 wait-notify-indefinite drop again ; 
 : init-test c" producer-task @ task-name! consumer-mailboxes 2 consumer-task @ config-notify producer-mailboxes 1 producer-task @ config-notify consumer-task @ run producer-task @ run 0 consumer-task @ notify 0 producer-task @ notify pause ; 
 : target-task variable ; 
 : source-task variable ; 
 : target 0 wait-notify-indefinite drop begin 0 wait-notify-indefinite drop 0 source-task @ notify again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : source 0 wait-notify-indefinite drop begin 0 target-task @ notify 0 wait-notify-indefinite drop 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! c" source-task @ task-name! target-mailboxes 1 target-task @ config-notify source-mailboxes 1 source-task @ config-notify target-task @ run source-task @ run 0 target-task @ notify 0 source-task @ notify pause ; 
 : target-task variable ; 
 : source-task variable ; 
 : target 0 wait-notify-indefinite drop begin 0 wait-notify-indefinite drop 0 source-task @ notify again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : source 0 wait-notify-indefinite drop begin 0 target-task @ notify 0 wait-notify-indefinite drop 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! c" source-task @ task-name! target-mailboxes 1 target-task @ config-notify source-mailboxes 1 source-task @ config-notify target-task @ run source-task @ run 0 target-task @ notify 0 source-task @ notify pause ; 
 : consumer-task variable ; 
 : producer-task variable ; 
 : consumer 0 wait-notify-indefinite drop begin 10000 systick-counter 0 wait-notify-timeout . 0 producer-task @ notify again ; 
 : producer 0 wait-notify-indefinite drop 10 0 ?do ['] 1+ 0 consumer-task @ notify-update 0 wait-notify-indefinite drop loop ; 
 : init-test c" producer-task @ task-name! consumer-mailboxes 1 consumer-task @ config-notify producer-mailboxes 1 producer-task @ config-notify consumer-task @ run producer-task @ run 0 consumer-task @ notify 0 producer-task @ notify pause ; 
 : consumer-task variable ; 
 : producer-task variable ; 
 : consumer 0 wait-notify-indefinite drop 0 producer-task @ notify begin 0 wait-notify-indefinite . 0 producer-task @ notify again ; 
 : producer 0 wait-notify-indefinite drop begin 1 ['] + 0 consumer-task @ notify-update 0 wait-notify-indefinite drop again ; 
 : init-test c" producer-task @ task-name! consumer-mailboxes 1 consumer-task @ config-notify producer-mailboxes 1 producer-task @ config-notify consumer-task @ run producer-task @ run 0 consumer-task @ notify pause ; 
 : x-allocate-failed ." cr ; 
 : heap-bitmap [inlined] heap-size + ; 
 : heap-blocks [inlined] dup heap-size + swap heap-block-count @ 5 rshift cells + ; 
 : heap-block [inlined] dup heap-block-size @ rot * swap heap-blocks + ; 
 : block-addr>index [inlined] tuck heap-blocks - swap heap-block-size @ u/ ; 
 : in-heap? -rot + swap heap-block-count @ <= ; 
 : blocks-free? 2 pick 2 pick 2 pick in-heap? if eap-bitmap ver 5 rshift cells + dup >r rot >r over $1F and rshift 2 r@ 32 min - $FFFFFFFF swap rshift and if rdrop rdrop drop false exit hen > swap $1F and 32 swap - - 0 max r> cell+ egin over while over 32 min 32 swap - $FFFFFFFF swap rshift over @ and if 2drop false exit else cell+ swap 32 - 0 max swap then epeat drop true else drop drop false then ; 
 : skip-used-space dup >r heap-bitmap over 5 rshift cells + begin ver r@ heap-block-count @ < if dup @ 2 pick $1F and rshift $FFFFFFFF 3 pick $1F and rshift = if cell+ swap 32 over $1F and - rot + swap else dup @ 2 pick $1F and rshift >r 32 2 pick $1F and - begin dup 0> while r@ 1 and not if rdrop rdrop 2drop exit then 1- r> 1 rshift >r rot 1+ -rot repeat drop rdrop then lse rdrop 2drop -1 exit hen again ; 
 : find-space >r begin @ skip-used-space dup -1 = if rdrop ['] x-allocate-failed ?raise hen @ 2 pick 2 pick 2>r blocks-free? if 2r> nip rdrop true lse 2r> over + false hen until nip ; 
 : update-next-free-on-allocate 2dup heap-next-free @ = if rot + over skip-used-space dup -1 <> if swap heap-next-free ! lse drop dup heap-block-count @ swap heap-next-free ! hen else drop drop then ; 
 : update-next-free-on-free dup heap-next-free @ rot min swap heap-next-free ! ; 
 : mark-allocated 2 pick 2 pick 2 pick update-next-free-on-allocate heap-bitmap over 5 rshift cells + >r begin over while 2 over $1F and - 2 pick min FFFFFFFF over 32 swap - rshift 2 pick $1F and lshift @ bis! r> cell+ >r uck + -rot - swap repeat rdrop 2drop ; 
 : mark-free 2dup update-next-free-on-free heap-bitmap over 5 rshift cells + >r begin over while 2 over $1F and - 2 pick min FFFFFFFF over 32 swap - rshift 2 pick $1F and lshift @ bic! r> cell+ >r uck + -rot - swap repeat rdrop 2drop ; 
 : size>blocks 2dup heap-block-size @ umod 0> if eap-block-size @ u/ 1+ else eap-block-size @ u/ then ; 
 : init-heap-bitmap dup heap-bitmap swap heap-block-count @ 3 rshift 0 fill ; 
 : init-heap tuck swap 32 align swap heap-block-count ! tuck heap-block-size ! 0 over heap-next-free ! init-heap-bitmap ; 
 : allocate tuck swap cell+ swap size>blocks >r dup dup heap-next-free @ swap tuck r@ -rot find-space r@ over 3 pick mark-allocated swap heap-block dup r> swap ! cell+ ; 
 : free over 4 - @ over >r -rot block-addr>index r> mark-free ; 
 : resize 2dup free 2dup swap 4 - swap block-addr>index 3 pick cell+ 2 pick size>blocks >r 2dup swap r@ -rot blocks-free? if r@ 3 pick 4 - ! r> -rot swap mark-allocated nip else drop [: 2 pick over allocate ;] try dup ['] x-allocate-failed = if drop drop over 4 - @ rot 2 pick block-addr>index rot mark-allocated '] x-allocate-failed ?raise else raise then rot 4 - rot over @ swap heap-block-size @ * rot dup >r 4 - swap move r> r> over 4 - ! nip then ; 
 : heap-size tuck * swap 32 align 5 rshift cells + heap-size + ; 
 : class-method class-methods @ swap 1+ cells + ; 
 : method-by-name class-method-list @ begin ?dup while up method-word @ word-name 2over rot count qual-case-strings? if nip nip method-index @ exit hen rev-method @ repeat 2drop -1 ; 
 : method-list-len 0 swap begin ?dup while swap 1+ swap prev-method @ repeat ; 
 : new drop ; 
 : destroy drop ; 
 : x-method-not-in-class ." cr ; 
 : x-method-not-implemented ." cr ; 
 : x-method-not-implemented-yet ." cr ; 
 : abstract-method ['] x-method-not-implemented ?raise ; 
 : new dup @ 4 + @ 1 bic execute ; 
 : destroy dup @ 8 + @ 1 bic execute ; 
 : begin-class { super-class } create here cell allot super-class , 3 cells allot super-class members-size @ super-class class-method-list @ super-class method-count @ compiling-to-flash? if flash-block-align, then ; 
 : end-class { class-header member-offset method-list #methods } member-offset class-header members-size current! #methods class-header method-count current! cell align, compiling-to-flash? if flash-block-align, then here #methods 1+ cells allot { methods } compiling-to-flash? if flash-block-align, then methods class-header class-methods current! class-header methods current! method-list class-header class-method-list current! ; 
 : begin-implement compiling-to-flash? not if dup class-methods @ cell+ over class-method-list @ method-index @ 1+ cells 0 fill then ; 
 : end-implement { class-header -- } class-header class-method-list @ { current-method } begin current-method while current-method method-index @ { index } index class-header class-method flash-buffer@ dup 0= compiling-to-flash? not and swap -1 = or if index class-header class-superclass @ method-count @ < if index class-header class-superclass @ class-method @ index class-header class-method current! else ['] abstract-method 1 or index class-header class-method current! then then current-method prev-method @ to current-method repeat ; 
 : member { member-offset method-list #methods size } : inlined member-offset cell+ lit, postpone + postpone ; 
 : method { method-list #methods } #methods 31 < if : inlined [ armv6m-instr import ] 0 r6 r0 ldr_,[_,#_] #methods 1+ cells r0 r0 ldr_,[_,#_] r0 blx_ [ armv6m-instr unimport ] postpone ; 
 : [ armv6m-instr import ] 0 r6 r0 ldr_,[_,#_] #methods 1+ cells r1 literal, r1 r0 r0 ldr_,[_,_] r0 blx_ [ armv6m-instr unimport ] postpone ; 
 : define 1 or token dup 0= triggers x-token-expected 3 pick method-by-name dup -1 <> averts x-method-not-in-class 2 pick class-method current! ; 
 : class-size members-size @ cell+ ; 
 : object-class @ @ ; 
 : init-object tuck swap @ swap ! new ; 
 : with-object over class-size [: swap >r dup >r init-object r> r> over >r execute r> destroy ;] with-aligned-allot ; 
 : old-find-hook variable ; 
 : find-arrow swap 1+ swap 1- 1 begin over 2 > while 2 pick c@ [char] - = if 2 pick 1+ c@ [char] > = if nip nip exit then then rot 1+ rot 1- rot 1+ repeat 2drop drop -1 ; 
 : do-find-with-arrow 2dup find-arrow dup -1 <> if 2 pick over old-find-hook @ execute ?dup if >r 2 + tuck - -rot + swap r> >xt execute >r r@ method-by-name dup -1 <> if r> class-method flash-buffer@ dup 0<> over -1 <> and if 1 bic dup 2 - c@ 0= if 10 - else find-by-xt then else drop ['] x-method-not-implemented-yet ?raise then else rdrop drop 0 then else 2drop drop 0 then else drop old-find-hook @ execute then ; 
 : block-count constant ; 
 : last-object variable ; 
 : allocate-object dup class-size my-heap allocate dup >r init-object r> ; 
 : free-all-objects [: last-object @ ;] [: last-object @ destroy ;] qwhile ; 
 : fill-heap-with-objects [: [: <heap-object> allocate-object drop ;] qagain ;] try dup ['] x-allocate-failed = [: drop 0 ;] qif ?raise ; 
 : init-test block-size block-count my-heap init-heap 0 last-object ! fill-heap-with-objects free-all-objects fill-heap-with-objects free-all-objects ; 
 : init init <my-class> my-object-0 init-object <my-subclass-0> my-object-1 init-object <my-subclass-1> my-object-2 init-object ; 
 : start-pause-count variable ; 
 : start-systick variable ; 
 : interval-pause-count-limit constant ; 
 : counter begin pause pause-count start-pause-count @ - interval-pause-count-limit > if ause-count start-pause-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 interval-pause-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test pause-count start-pause-count ! systick-counter start-systick ! counter-task run pause ; 
 : my-task-0 variable ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : add-pending-ops ['] my-pending-routine-0 my-pending-op-0 set-pending-op ['] my-pending-routine-1 my-pending-op-1 set-pending-op ['] my-pending-routine-2 my-pending-op-2 set-pending-op force-pending-ops ; 
 : my-task-0 variable ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : add-pending-ops [: 0 my-task-0 @ notify ;] my-pending-op-0 set-pending-op [: 0 my-task-1 @ notify ;] my-pending-op-1 set-pending-op [: 0 my-task-2 @ notify ;] my-pending-op-2 set-pending-op force-pending-ops ; 
 : x-pin-out-of-range ." cr ; 
 : x-alternate-out-of-range ." cr ; 
 : pin-count constant ; 
 : alternate-count constant ; 
 : validate-pin pin-count u< averts x-pin-out-of-range ; 
 : validate-alternate alternate-count u< averts x-alternate-out-of-range ; 
 : high constant ; 
 : low constant ; 
 : input-pin dup validate-pin true over PADS_BANK0_IE! true over PADS_BANK0_OD! 5 over GPIO_CTRL_FUNCSEL! bit GPIO_OE_CLR ! ; 
 : output-pin dup validate-pin false over PADS_BANK0_IE! false over PADS_BANK0_OD! 5 over GPIO_CTRL_FUNCSEL! bit GPIO_OE_SET ! ; 
 : alternate-pin dup validate-pin over validate-alternate true over PADS_BANK0_IE! false over PADS_BANK0_OD! GPIO_CTRL_FUNCSEL! ; 
 : pull-up-pin dup validate-pin true over PADS_BANK0_PUE! false swap PADS_BANK0_PDE! ; 
 : pull-down-pin dup validate-pin true over PADS_BANK0_PDE! false swap PADS_BANK0_PUE! ; 
 : floating-pin dup validate-pin false over PADS_BANK0_PUE! false swap PADS_BANK0_PDE! ; 
 : slow-pin dup validate-pin false swap PADS_BANK0_SLEWFAST! ; 
 : fast-pin dup validate-pin true swap PADS_BANK0_SLEWFAST! ; 
 : pin! dup validate-pin bit swap if GPIO_OUT_SET else GPIO_OUT_CLR then ! ; 
 : pin@ dup validate-pin bit GPIO_IN bit@ ; 
 : pin-out@ dup validate-pin bit GPIO_OUT bit@ ; 
 : toggle-pin dup validate-pin bit GPIO_OUT_XOR ! ; 
 : pin-monitor 1 [: begin dup pin@ green led! pause again ;] 256 128 512 spawn run ; 
 : blinker-vary variable ; 
 : handle-pio blinker-vary @ 0 PIO0 sm-txf! PIO0_IRQ0 NVIC_ICPR_CLRPEND! ; 
 : init-blinker 500 blinker-vary ! %0001 PIO0 sm-disable %0001 PIO0 sm-restart 0 62500 0 PIO0 sm-clkdiv! 25 1 0 PIO0 sm-set-pins! 0 7 0 PIO0 sm-wrap! on 0 PIO0 sm-out-sticky! pio-init 2 0 PIO0 sm-instr! pio-code 8 PIO0 pio-instr-mem! 0 0 PIO0 sm-addr! blinker-vary @ 0 PIO0 sm-txf! ['] handle-pio PIO0_IRQ0 16 + vector! 0 INT_SM_TXNFULL IRQ0 PIO0 pio-interrupt-enable PIO0_IRQ0 NVIC_ISER_SETENA! %0001 PIO0 sm-enable ; 
 : init-blinker %0001 PIO0 sm-disable %0001 PIO0 sm-restart 0 62500 0 PIO0 sm-clkdiv! 25 1 0 PIO0 sm-set-pins! 0 9 0 PIO0 sm-wrap! on 0 PIO0 sm-out-sticky! pio-init 2 0 PIO0 sm-instr! pio-code 10 PIO0 pio-instr-mem! 0 0 PIO0 sm-addr! %0001 PIO0 sm-enable ; 
 : blinker-state variable ; 
 : blinker-max-input-shade variable ; 
 : blinker-input-shade variable ; 
 : blinker-max-shade variable ; 
 : blinker-shade variable ; 
 : blinker-max-input-step-delay variable ; 
 : blinker-input-step-delay variable ; 
 : blinker-max-step-delay variable ; 
 : blinker-min-step-delay variable ; 
 : blinker-step-delay variable ; 
 : blinker-step-delay-step-delay variable ; 
 : convert-shade 0 swap 2dup 2dup f* 0,01 f* d+ nip ; 
 : step-delay-poly 0 swap 2dup 2dup f* 0,1 f* d+ ; 
 : convert-step-delay step-delay-poly blinker-max-input-step-delay @ step-delay-poly f/ 0 blinker-max-step-delay @ f* nip blinker-min-step-delay @ max ; 
 : handle-pio blinker-state @ not if blinker-shade @ 0 PIO0 TXF ! else blinker-max-shade @ blinker-shade @ - 0 PIO0 TXF ! then blinker-state @ not blinker-state ! 0 INT_SM_TXNFULL PIO0 INTR ! PIO0_IRQ0 NVIC_ICPR_CLRPEND! ; 
 : blinker-shade! blinker-max-input-shade @ convert-shade blinker-max-shade ! convert-shade blinker-shade ! ; 
 : blinker-shade-loop 0 systick-counter current-action action-delay begin begin blinker-max-input-shade @ blinker-input-shade @ > while blinker-input-shade +! linker-input-shade @ blinker-shade! linker-step-delay @ current-action action-delay-latest + urrent-action action-delay ield repeat yield begin 0 blinker-input-shade @ < while 1 blinker-input-shade +! linker-input-shade @ blinker-shade! linker-step-delay @ current-action action-delay-latest + urrent-action action-delay ield repeat yield again ; 
 : blinker-rate-loop 0 systick-counter current-action action-delay begin begin blinker-max-input-step-delay @ blinker-input-step-delay @ > while blinker-input-step-delay +! linker-input-step-delay @ convert-step-delay blinker-step-delay ! linker-step-delay-step-delay @ current-action action-delay-latest + urrent-action action-delay ield repeat yield begin 0 blinker-input-step-delay @ < while 1 blinker-input-step-delay +! linker-input-step-delay @ convert-step-delay blinker-step-delay ! linker-step-delay-step-delay @ current-action action-delay-latest + urrent-action action-delay ield repeat yield again ; 
 : init-blinker true blinker-state ! 500 blinker-max-input-shade ! 0 blinker-input-shade ! 1000 blinker-max-input-step-delay ! 0 blinker-input-step-delay ! 25 blinker-max-step-delay ! 1 blinker-min-step-delay ! 0 blinker-step-delay ! 100 blinker-step-delay-step-delay ! 0 blinker-shade! %0000 CTRL_SM_ENABLE_MASK CTRL_SM_ENABLE_LSB PIO0 CTRL field! %0001 CTRL_SM_RESTART_MASK CTRL_SM_RESTART_LSB PIO0 CTRL field! 6 25 GPIO_CTRL_FUNCSEL! 25 bit GPIO_OE_SET ! 25 bit GPIO_OUT_CLR ! 781 SM_CLKDIV_INT_MASK SM_CLKDIV_INT_LSB 0 PIO0 SM_CLKDIV field! 0 SM_CLKDIV_FRAC_MASK SM_CLKDIV_FRAC_LSB 0 PIO0 SM_CLKDIV field! 1 SM_PINCTRL_SET_COUNT_MASK SM_PINCTRL_SET_COUNT_LSB 0 PIO0 SM_PINCTRL field! 25 SM_PINCTRL_SET_BASE_MASK SM_PINCTRL_SET_BASE_LSB 0 PIO0 SM_PINCTRL field! 0 SM_EXECCTRL_WRAP_BOTTOM_MASK SM_EXECCTRL_WRAP_BOTTOM_LSB 0 PIO0 SM_EXECCTRL field! 7 SM_EXECCTRL_WRAP_TOP_MASK SM_EXECCTRL_WRAP_TOP_LSB 0 PIO0 SM_EXECCTRL field! SM_EXECCTRL_OUT_STICKY 0 PIO0 SM_EXECCTRL bis! 2 0 ?do pio-init i 2 * + h@ 0 PIO0 SM_INSTR ! loop 8 0 ?do pio-code i 2 * + h@ i PIO0 INSTR_MEM ! loop 0 0 PIO0 SM_ADDR ! blinker-shade @ 0 PIO0 TXF ! ['] handle-pio PIO0_IRQ0 16 + vector! 0 INT_SM_TXNFULL IRQ0 PIO0 INTE bis! PIO0_IRQ0 NVIC_ISER_SETENA! %0001 CTRL_SM_ENABLE_MASK CTRL_SM_ENABLE_LSB PIO0 CTRL field! blinker-schedule init-schedule ['] blinker-shade-loop blinker-shade-action blinker-schedule init-action ['] blinker-rate-loop blinker-rate-action blinker-schedule init-action blinker-shade-action enable-action blinker-rate-action enable-action 0 [: blinker-schedule run-schedule ;] 420 128 512 spawn run ; 
 : blinker-state variable ; 
 : blinker-max-input-shade variable ; 
 : blinker-max-shade variable ; 
 : blinker-shade variable ; 
 : blinker-step-delay variable ; 
 : convert-shade 0 swap 2dup 2dup f* 0,01 f* d+ nip ; 
 : handle-pio blinker-state @ not if blinker-shade @ 0 PIO0 sm-txf! else blinker-max-shade @ blinker-shade @ - 0 PIO0 sm-txf! then blinker-state @ not blinker-state ! PIO0_IRQ0 NVIC_ICPR_CLRPEND! ; 
 : blinker-shade! blinker-max-input-shade @ convert-shade blinker-max-shade ! convert-shade blinker-shade ! ; 
 : blinker-shade-loop begin blinker-max-input-shade @ 0 ?do blinker-shade! ystick-counter blinker-step-delay @ current-task delay loop 0 blinker-max-input-shade @ ?do blinker-shade! ystick-counter blinker-step-delay @ current-task delay -1 +loop again ; 
 : init-blinker true blinker-state ! 500 blinker-max-input-shade ! 25 blinker-step-delay ! 0 blinker-shade! %0001 PIO0 sm-disable %0001 PIO0 sm-restart 0 758 0 PIO0 sm-clkdiv! 25 1 0 PIO0 sm-set-pins! 0 7 0 PIO0 sm-wrap! on 0 PIO0 sm-out-sticky! pio-init 2 0 PIO0 sm-instr! pio-code 8 PIO0 pio-instr-mem! 0 0 PIO0 sm-addr! blinker-shade @ 0 PIO0 sm-txf! ['] handle-pio PIO0_IRQ0 16 + vector! 0 INT_SM_TXNFULL IRQ0 PIO0 pio-interrupt-enable PIO0_IRQ0 NVIC_ISER_SETENA! %0001 PIO0 sm-enable 0 ['] blinker-shade-loop 420 128 512 spawn run ; 
 : on constant ; 
 : off constant ; 
 : right constant ; 
 : left constant ; 
 : out constant ; 
 : in constant ; 
 : PIO0 constant ; 
 : PIO1 constant ; 
 : x-sm-out-of-range ." cr ; 
 : x-pio-out-of-range ." cr ; 
 : x-too-many-instructions ." cr ; 
 : x-address-out-of-range ." cr ; 
 : x-too-many-pins ." cr ; 
 : x-pin-out-of-range ." cr ; 
 : x-clkdiv-out-of-range ." cr ; 
 : x-irq-out-of-range ." cr ; 
 : x-interrupt-out-of-range ." cr ; 
 : x-threshold-out-of-range ." cr ; 
 : x-bit-out-of-range ." cr ; 
 : x-relocate-out-of-range ." cr ; 
 : validate-pio dup PIO0 = swap PIO1 = or averts x-pio-out-of-range ; 
 : validate-sm 4 u< averts x-sm-out-of-range ; 
 : validate-sm-pio validate-pio validate-sm ; 
 : validate-pin 30 u< averts x-pin-out-of-range ; 
 : validate-irq 2 u< averts x-irq-out-of-range ; 
 : validate-interrupt $FFF bic 0= averts x-interrupt-out-of-range ; 
 : make-pio-field ' >r swap 2dup token dup 0<> averts x-token-expected start-compile lit, postpone swap lit, postpone swap r@ lit, postpone execute postpone field! visible end-compile, token dup 0<> averts x-token-expected start-compile lit, postpone swap lit, postpone swap r> lit, postpone execute postpone field@ visible end-compile, ; 
 : make-pio-field-getter ' >r swap token dup 0<> averts x-token-expected start-compile lit, postpone swap lit, postpone swap r> lit, postpone execute postpone field@ visible end-compile, ; 
 : make-bit ' >r dup token dup 0<> averts x-token-expected start-compile r@ lit, postpone execute postpone >r lit, postpone swap postpone 0<> postpone if postpone r@ postpone @ postpone or postpone else postpone r@ postpone @ postpone swap postpone bic postpone then postpone r> postpone ! visible end-compile, token dup 0<> averts x-token-expected start-compile r> lit, postpone execute postpone bit@ visible end-compile, ; 
 : make-bit-getter ' >r token dup 0<> averts x-token-expected start-compile r> lit, postpone execute postpone bit@ visible end-compile, ; 
 : make-sm-field ' >r swap 2dup token dup 0<> averts x-token-expected start-compile lit, postpone -rot lit, postpone -rot r@ lit, postpone execute postpone field! visible end-compile, token dup 0<> averts x-token-expected start-compile lit, postpone -rot lit, postpone -rot r> lit, postpone execute postpone field@ visible end-compile, ; 
 : PIO0_IRQ0 constant ; 
 : PIO0_IRQ1 constant ; 
 : PIO1_IRQ0 constant ; 
 : PIO1_IRQ1 constant ; 
 : CTRL [inlined] $000 + ; 
 : CTRL_CLKDIV_RESTART_LSB constant ; 
 : CTRL_SM_RESTART_LSB constant ; 
 : CTRL_SM_ENABLE_LSB constant ; 
 : FSTAT [inlined] $004 + ; 
 : FSTAT_TXEMPTY_LSB constant ; 
 : FSTAT_TXFULL_LSB constant ; 
 : FSTAT_RXEMPTY_LSB constant ; 
 : FSTAT_RXFULL_LSB constant ; 
 : FDEBUG [inlined] $008 + ; 
 : FDEBUG_TXSTALL_LSB constant ; 
 : FDEBUG_TXOVER_LSB constant ; 
 : FDEBUG_RXUNDER_LSB constant ; 
 : FDEBUG_RXSTALL_LSB constant ; 
 : FLEVEL [inlined] $00C + ; 
 : FLEVEL_RX_LSB [inlined] 8 * 4 + ; 
 : FLEVEL_RX_MASK [inlined] $F swap FLEVEL_RX_LSB lshift ; 
 : FLEVEL_RX@ swap dup FLEVEL_RX_MASK swap FLEVEL_RX_LSB rot FLEVEL field@ ; 
 : FLEVEL_TX_LSB [inlined] 8 * ; 
 : FLEVEL_TX_MASK [inlined] $F swap FLEVEL_TX_LSB lshift ; 
 : FLEVEL_TX@ swap dup FLEVEL_TX_MASK swap FLEVEL_TX_LSB rot FLEVEL field@ ; 
 : TXF [inlined] swap cells + $010 + ; 
 : RXF [inlined] swap cells + $020 + ; 
 : IRQ [inlined] $030 + ; 
 : IRQ_FORCE [inlined] $034 + ; 
 : INPUT_SYNC_BYPASS [inlined] $038 + ; 
 : DBG_PADOUT [inlined] $03C + ; 
 : DBG_PADOE [inlined] $040 + ; 
 : DBG_CFGINFO [inlined] $044 + ; 
 : DBG_CFGINFO_IMEM_SIZE_LSB constant ; 
 : DBG_CFGINFO_SM_COUNT_LSB constant ; 
 : DBG_CFGINFO_FIFO_DEPTH_LSB constant ; 
 : INSTR_MEM [inlined] $048 + swap cells + ; 
 : SM_CLKDIV [inlined] swap $18 * + $0C8 + ; 
 : SM_CLKDIV_INT_LSB constant ; 
 : SM_CLKDIV_FRAC_LSB constant ; 
 : SM_EXECCTRL [inlined] swap $18 * + $0CC + ; 
 : SM_EXECCTRL_JMP_PIN_LSB constant ; 
 : SM_EXECCTRL_OUT_EN_SEL_LSB constant ; 
 : SM_EXECCTRL_WRAP_TOP_LSB constant ; 
 : SM_EXECCTRL_WRAP_BOTTOM_LSB constant ; 
 : SM_EXECCTRL_STATUS_N_LSB constant ; 
 : SM_SHIFTCTRL [inlined] swap $18 * + $0D0 + ; 
 : SM_SHIFTCTRL_PULL_THRESH_LSB constant ; 
 : SM_SHIFTCTRL_PUSH_THRESH_LSB constant ; 
 : SM_ADDR [inlined] swap $18 * + $0D4 + ; 
 : SM_INSTR [inlined] swap $18 * + $0D8 + ; 
 : SM_PINCTRL [inlined] swap $18 * + $0DC + ; 
 : SM_PINCTRL_SIDESET_COUNT_LSB constant ; 
 : SM_PINCTRL_SET_COUNT_LSB constant ; 
 : SM_PINCTRL_OUT_COUNT_LSB constant ; 
 : SM_PINCTRL_IN_BASE_LSB constant ; 
 : SM_PINCTRL_SIDESET_BASE_LSB constant ; 
 : SM_PINCTRL_SET_BASE_LSB constant ; 
 : SM_PINCTRL_OUT_BASE_LSB constant ; 
 : INTR [inlined] $128 + ; 
 : INTE [inlined] $12C + swap $0C * + ; 
 : INTF [inlined] $130 + swap $0C * + ; 
 : INTS [inlined] $134 + swap $0C * + ; 
 : INT_SM [inlined] 8 + bit ; 
 : INT_SM_TXNFULL [inlined] 4 + bit ; 
 : INT_SM_RXNEMPTY [inlined] bit ; 
 : IRQ0 constant ; 
 : IRQ1 constant ; 
 : REL %10000 or ; 
 : COND_ALWAYS constant ; 
 : COND_X0= constant ; 
 : COND_X1- constant ; 
 : COND_Y0= constant ; 
 : COND_Y1- constant ; 
 : COND_XY<> constant ; 
 : COND_PIN constant ; 
 : COND_IOSRE constant ; 
 : WAIT_GPIO constant ; 
 : WAIT_PIN constant ; 
 : WAIT_IRQ constant ; 
 : IN_PINS constant ; 
 : IN_X constant ; 
 : IN_Y constant ; 
 : IN_NULL constant ; 
 : IN_ISR constant ; 
 : IN_OSR constant ; 
 : OUT_PINS constant ; 
 : OUT_X constant ; 
 : OUT_Y constant ; 
 : OUT_NULL constant ; 
 : OUT_PINDIRS constant ; 
 : OUT_PC constant ; 
 : OUT_ISR constant ; 
 : OUT_EXEC constant ; 
 : PUSH_NOT_FULL constant ; 
 : PUSH_IF_FULL constant ; 
 : PUSH_NO_BLOCK constant ; 
 : PUSH_BLOCK constant ; 
 : PULL_NOT_EMPTY constant ; 
 : PULL_IF_EMPTY constant ; 
 : PULL_NO_BLOCK constant ; 
 : PULL_BLOCK constant ; 
 : MOV_DEST_PINS constant ; 
 : MOV_DEST_X constant ; 
 : MOV_DEST_Y constant ; 
 : MOV_DEST_EXEC constant ; 
 : MOV_DEST_PC constant ; 
 : MOV_DEST_ISR constant ; 
 : MOV_DEST_OSR constant ; 
 : MOV_OP_NONE constant ; 
 : MOV_OP_INVERT constant ; 
 : MOV_OP_REVERSE constant ; 
 : MOV_SRC_PINS constant ; 
 : MOV_SRC_X constant ; 
 : MOV_SRC_Y constant ; 
 : MOV_SRC_NULL constant ; 
 : MOV_SRC_STATUS constant ; 
 : MOV_SRC_ISR constant ; 
 : MOV_SRC_OSR constant ; 
 : IRQ_SET constant ; 
 : IRQ_CLEAR constant ; 
 : IRQ_WAIT constant ; 
 : SET_PINS constant ; 
 : SET_X constant ; 
 : SET_Y constant ; 
 : SET_PINDIRS constant ; 
 : jmp, h, ; 
 : wait, 0<> 1 and 7 lshift swap 3 and 5 lshift or swap $1F and or $2000 or h, ; 
 : in, $07 and 5 lshift swap $1F and or $4000 or h, ; 
 : out, $07 and 5 lshift swap $1F and or $6000 or h, ; 
 : push, 0<> 1 and 6 lshift swap 0<> 1 and 5 lshift or $8000 or h, ; 
 : pull, 0<> 1 and 6 lshift swap 0<> 1 and 5 lshift or $8080 or h, ; 
 : mov, $07 and 5 lshift swap $03 and 3 lshift or swap $03 and or $A000 or h, ; 
 : irq, $03 and 5 lshift swap $1F and or $C000 or h, ; 
 : set, $07 and 5 lshift swap $1F and or $E000 or h, ; 
 : jmp+, h, ; 
 : wait+, 0<> 1 and 7 lshift swap 3 and 5 lshift or swap $1F and 8 lshift or swap $1F and or $2000 or h, ; 
 : in+, $07 and 5 lshift swap $1F and 8 lshift or swap $1F and or $4000 or h, ; 
 : out+, $07 and 5 lshift swap $1F and 8 lshift or swap $1F and or $6000 or h, ; 
 : push+, 0<> 1 and 6 lshift swap 0<> 1 and 5 lshift or swap $1F and 8 lshift or $8000 or h, ; 
 : pull+, 0<> 1 and 6 lshift swap 0<> 1 and 5 lshift or swap $1F and 8 lshift or $8080 or h, ; 
 : mov+, $07 and 5 lshift swap $03 and 3 lshift or swap $1F and 8 lshift or swap $03 and or $A000 or h, ; 
 : irq+, $03 and 5 lshift swap $1F and 8 lshift or swap $1F and or $C000 or h, ; 
 : set+, $07 and 5 lshift swap $1F and 8 lshift or swap $1F and or $E000 or h, ; 
 : sm-enable dup validate-pio over %1111 bic 0= averts x-sm-out-of-range swap CTRL_SM_ENABLE_LSB lshift swap CTRL bis! ; 
 : sm-disable dup validate-pio over %1111 bic 0= averts x-sm-out-of-range swap CTRL_SM_ENABLE_LSB lshift swap CTRL bic! ; 
 : sm-restart dup validate-pio over %1111 bic 0= averts x-sm-out-of-range CTRL_SM_RESTART! ; 
 : sm-clkdiv! 2dup validate-sm-pio 2 pick $10000 u<= averts x-clkdiv-out-of-range 3 pick $100 u< averts x-clkdiv-out-of-range 3 pick 0<> 3 pick $FFFF and 0= and triggers x-clkdiv-out-of-range 2dup 2>r SM_CLKDIV_INT! 2r> SM_CLKDIV_FRAC! ; 
 : sm-addr! 2dup validate-sm-pio 2 pick 32 u< averts x-address-out-of-range SM_INSTR ! ; 
 : sm-wrap! 2dup validate-sm-pio 2 pick 32 u< averts x-address-out-of-range 3 pick 32 u< averts x-address-out-of-range 2dup 2>r SM_EXECCTRL_WRAP_TOP! 2r> SM_EXECCTRL_WRAP_BOTTOM! ; 
 : sm-out-sticky! 2dup validate-sm-pio SM_EXECCTRL_OUT_STICKY! ; 
 : sm-sideset-high-enable! 2dup validate-sm-pio SM_EXECCTRL_SIDE_EN! ; 
 : sm-sideset-pindir! 2dup validate-sm-pio SM_EXECCTRL_SIDE_PINDIR! ; 
 : sm-jmp-pin! 2dup validate-sm-pio 2 pick 32 u< averts x-pin-out-of-range SM_EXECCTRL_JMP_PIN! ; 
 : sm-inline-out-enable! 2dup validate-sm-pio 2 pick 32 u< averts x-bit-out-of-range 2dup 2>r SM_EXECCTRL_OUT_EN_SEL! on 2r> SM_EXECCTRL_INLINE_OUT_EN! ; 
 : sm-inline-out-enable-clear 2dup validate-sm-pio off -rot SM_EXECCTRL_INLINE_OUT_EN! ; 
 : sm-pull-threshold! 2dup validate-sm-pio 2 pick dup 0 u> swap 33 u< and averts x-threshold-out-of-range rot dup 32 = if drop 0 then -rot SM_SHIFTCTRL_PULL_THRESH! ; 
 : sm-push-threshold! 2dup validate-sm-pio 2 pick dup 0 u> swap 33 u< and averts x-threshold-out-of-range rot dup 32 = if drop 0 then -rot SM_SHIFTCTRL_PUSH_THRESH! ; 
 : sm-txf! 2dup validate-sm-pio TXF ! ; 
 : sm-rxf@ 2dup validate-sm-pio RXF @ ; 
 : pins-pio-alternate dup 30 u<= averts x-too-many-pins over 30 u< averts x-pin-out-of-range over + swap ?do 6 i 30 umod alternate-pin loop ; 
 : sm-sideset-pins! 2dup validate-sm-pio 2 pick 6 u< averts x-too-many-pins 3 pick validate-pin 2>r 2dup pins-pio-alternate 2r@ SM_PINCTRL_SIDESET_COUNT! 2r> SM_PINCTRL_SIDESET_BASE! ; 
 : sm-set-pins! 2dup validate-sm-pio 2 pick 6 u< averts x-too-many-pins 3 pick validate-pin 2>r 2dup pins-pio-alternate 2r@ SM_PINCTRL_SET_COUNT! 2r> SM_PINCTRL_SET_BASE! ; 
 : sm-out-pins! 2dup validate-sm-pio 2 pick 32 u<= averts x-too-many-pins 3 pick validate-pin 2>r 2dup pins-pio-alternate 2r@ SM_PINCTRL_OUT_COUNT! 2r> SM_PINCTRL_OUT_BASE! ; 
 : sm-in-pin-base! 2dup validate-sm-pio 2 pick validate-pin SM_PINCTRL_IN_BASE! ; 
 : sm-pin! 2dup validate-sm-pio 2 pick validate-pin 2dup SM_PINCTRL @ >r 2dup 0 -rot SM_PINCTRL ! rot 2 pick 2 pick SM_PINCTRL_SET_BASE! 2dup 1 -rot SM_PINCTRL_SET_COUNT! rot if %00001 else %00000 then SET_PINS 5 lshift or $E000 or 2 pick 2 pick SM_INSTR ! r> -rot SM_PINCTRL ! ; 
 : sm-pindir! 2dup validate-sm-pio 2 pick validate-pin 2dup SM_PINCTRL @ >r 2dup 0 -rot SM_PINCTRL ! rot 2 pick 2 pick SM_PINCTRL_SET_BASE! 2dup 1 -rot SM_PINCTRL_SET_COUNT! rot if %00001 else %00000 then SET_PINDIRS 5 lshift or $E000 or 2 pick 2 pick SM_INSTR ! r> -rot SM_PINCTRL ! ; 
 : sm-rx-fifo-level@ 2dup validate-sm-pio FLEVEL_RX@ ; 
 : sm-tx-fifo-level@ 2dup validate-sm-pio FLEVEL_TX@ ; 
 : sm-join-rx-fifo! 2dup validate-sm-pio SM_SHIFTCTRL_FJOIN_RX! ; 
 : sm-join-tx-fifo! 2dup validate-sm-pio SM_SHIFTCTRL_FJOIN_TX! ; 
 : sm-out-shift-dir 2dup validate-sm-pio SM_SHIFTCTRL_OUT_SHIFTDIR! ; 
 : sm-in-shift-dir 2dup validate-sm-pio SM_SHIFTCTRL_IN_SHIFTDIR! ; 
 : sm-autopull! 2dup validate-sm-pio SM_SHIFTCTRL_AUTOPULL! ; 
 : sm-autopush! 2dup validate-sm-pio SM_SHIFTCTRL_AUTOPUSH! ; 
 : sm-instr! 2dup validate-sm-pio SM_INSTR -rot 0 ?do 2dup h@ swap ! 2 + loop 2drop ; 
 : pio-instr-mem! dup validate-pio over 32 u<= averts x-too-many-instructions -rot 0 ?do 2dup h@ i rot INSTR_MEM ! 2 + loop 2drop ; 
 : pio-instr-relocate-mem! dup validate-pio 2 pick 32 u<= averts x-too-many-instructions 2 pick 2 pick + 32 u<= averts x-address-out-of-range 2 pick 0 ?do 3 pick i 2 * + h@ dup $E000 and 0= if $1F and 2 pick + 32 u< averts x-relocate-out-of-range else drop then loop rot 0 ?do 2 pick i 2 * + h@ dup $E000 and 0= if dup >r $1F and 2 pick + r> $1F bic or then i 2 pick INSTR_MEM ! loop 2drop drop ; 
 : pio-interrupt-enable dup validate-pio over validate-irq 2 pick validate-interrupt INTE bis! ; 
 : pio-interrupt-disable dup validate-pio over validate-irq 2 pick validate-interrupt INTE bic! ; 
 : pio-interrupt-enable-force dup validate-pio over validate-irq 2 pick validate-interrupt INTF bis! ; 
 : pio-interrupt-disable-force dup validate-pio over validate-irq 2 pick validate-interrupt INTF bic! ; 
 : pio-interrupt-raw@ dup validate-pio INTR @ ; 
 : pio-interrupt@ dup validate-pio over validate-irq INTS @ ; 
 : blinker-state variable ; 
 : blinker-max-input-shade variable ; 
 : blinker-max-shade variable ; 
 : blinker-shade variable ; 
 : blinker-step-delay variable ; 
 : convert-shade 0 swap blinker-max-input-shade @ 0 swap f/ pi f* cos dnegate 1,0 d+ 2,0 f/ blinker-premultiply 2@ f* expm1 blinker-premultiply 2@ expm1 f/ blinker-multiply 2@ f* nip ; 
 : handle-pio blinker-state @ not if blinker-shade @ 0 PIO0 sm-txf! else blinker-max-shade @ blinker-shade @ - 0 PIO0 sm-txf! then blinker-state @ not blinker-state ! PIO0_IRQ0 NVIC_ICPR_CLRPEND! ; 
 : blinker-shade! blinker-max-input-shade @ convert-shade blinker-max-shade ! convert-shade blinker-shade ! ; 
 : blinker-shade-loop begin blinker-max-input-shade @ 0 ?do blinker-shade! ystick-counter blinker-step-delay @ current-task delay loop 0 blinker-max-input-shade @ ?do blinker-shade! ystick-counter blinker-step-delay @ current-task delay -1 +loop again ; 
 : init-blinker true blinker-state ! 125 blinker-max-input-shade ! 500,0 blinker-multiply 2! 5,0 blinker-premultiply 2! 25 blinker-step-delay ! 0 blinker-shade! %0001 PIO0 sm-disable %0001 PIO0 sm-restart 0 758 0 PIO0 sm-clkdiv! 25 1 0 PIO0 sm-set-pins! 0 7 0 PIO0 sm-wrap! on 0 PIO0 sm-out-sticky! pio-init 2 0 PIO0 sm-instr! pio-code 8 PIO0 pio-instr-mem! 0 0 PIO0 sm-addr! blinker-shade @ 0 PIO0 sm-txf! ['] handle-pio PIO0_IRQ0 16 + vector! 0 INT_SM_TXNFULL IRQ0 PIO0 pio-interrupt-enable PIO0_IRQ0 NVIC_ISER_SETENA! %0001 PIO0 sm-enable 0 ['] blinker-shade-loop 420 128 512 spawn run ; 
 : your-pin constant ; 
 : init-test %0001 PIO0 sm-disable %0001 PIO0 sm-restart 0 1 0 PIO0 sm-clkdiv! your-pin 1 0 PIO0 sm-set-pins! 0 3 0 PIO0 sm-wrap! on 0 PIO0 sm-out-sticky! pio-init 2 0 PIO0 sm-instr! pio-code 4 PIO0 pio-instr-mem! your-pin fast-pin 0 0 PIO0 sm-addr! %0001 PIO0 sm-enable ; 
 : your-pin constant ; 
 : init-test %0001 PIO0 sm-disable %0001 PIO0 sm-restart on 0 PIO0 sm-sideset-pindir! 0 1 0 PIO0 sm-clkdiv! your-pin 1 0 PIO0 sm-sideset-pins! your-pin 1 0 PIO0 sm-set-pins! 0 1 0 PIO0 sm-wrap! on 0 PIO0 sm-out-sticky! pio-init 2 0 PIO0 sm-instr! pio-code 2 PIO0 pio-instr-mem! your-pin fast-pin 0 0 PIO0 sm-addr! %0001 PIO0 sm-enable ; 
 : your-pin constant ; 
 : init-test %0001 PIO0 sm-disable %0001 PIO0 sm-restart 0 1 0 PIO0 sm-clkdiv! your-pin 1 0 PIO0 sm-set-pins! your-pin 1 0 PIO0 sm-sideset-pins! 0 3 0 PIO0 sm-wrap! on 0 PIO0 sm-out-sticky! pio-init 2 0 PIO0 sm-instr! pio-code 4 PIO0 pio-instr-mem! your-pin fast-pin 0 0 PIO0 sm-addr! %0001 PIO0 sm-enable ; 
 : x-allocate-failed ." cr ; 
 : init-pool 0 over pool-first-free ! 0 over pool-last-free ! 0 over pool-free-count ! 0 over pool-total-count ! swap pool-header-size max swap pool-block-size ! ; 
 : free-pool 1 over pool-free-count +! over 0 swap pool-next-free ! dup pool-first-free @ 0= if 2dup pool-first-free ! else 2dup pool-last-free @ pool-next-free ! then pool-last-free ! ; 
 : add-pool begin dup pool-block-size @ 2 pick <= while 2 pick over free-pool 1 over pool-total-count +! dup pool-block-size @ 3 roll + over pool-block-size @ 3 roll swap - rot repeat 2drop drop ; 
 : allocate-pool dup pool-first-free @ ?dup if dup pool-next-free @ 2 pick pool-first-free ! over pool-first-free @ 0= if 2 pick pool-last-free ! then -1 rot pool-free-count +! else drop ['] x-allocate-failed ?raise then ; 
 : pool-block-size pool-block-size @ ; 
 : pool-free-count pool-free-count @ ; 
 : pool-total-count pool-total-count @ ; 
 : busy-wait 1000000 0 ['] drop qcount ; 
 : high-priority 1 current-task task-priority! [: 10 0 [: [: display-red ." . display-normal ;] my-lock with-lock busy-wait ;] qcount 5000 ms ;] qagain ; 
 : low-priority 0 current-task task-priority! [: 10 0 [: [: ." . ;] my-lock with-lock busy-wait ;] qcount ;] qagain ; 
 : init-test my-lock init-lock 0 ['] low-priority 256 128 512 spawn run 0 ['] high-priority 256 128 512 spawn run ; 
 : my-chan-count constant ; 
 : producer 0 begin dup [: my-chan send-chan ;] provide-allot-cell 1+ again ; 
 : consumer begin [: my-chan recv-chan ;] extract-allot-cell h.8 space again ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : consumer-0 [: [: my-fchan recv-fchan ;] extract-allot-cell [: ." . ;] my-lock with-lock 0 toggle-led 500 ms ;] qagain ; 
 : consumer-1 [: [: my-fchan recv-fchan ;] extract-allot-cell [: ." . ;] my-lock with-lock 0 toggle-led 500 ms ;] qagain ; 
 : producer 0 [: dup [: my-fchan send-fchan ;] provide-allot-cell 1+ ;] qagain ; 
 : init-test my-fchan init-fchan my-lock init-lock 0 ['] consumer-0 256 128 512 spawn run 0 ['] consumer-1 256 128 512 spawn run 0 ['] producer 256 128 512 spawn run ; 
 : my-chan-size constant ; 
 : producer begin [char] Z 1+ [char] A ?do [: my-chan send-chan ;] provide-allot-byte pause loop again ; 
 : consumer begin [: my-chan recv-chan ;] extract-allot-byte emit pause again ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : pwm-out-index constant ; 
 : pwm-in-index constant ; 
 : pwm-out-pin constant ; 
 : pwm-in-pin constant ; 
 : pwm-out-wrap constant ; 
 : pwm-in-wrap constant ; 
 : pwm-out-compare constant ; 
 : handle-pwm pwm-in-wrap s>d counter 2+! pwm-in-index bit clear-pwm-int clear-pwm-pending ; 
 : run-test inited? not if pwm-out-pin pull-up-pin pwm-out-pin fast-pin pwm-out-pin pwm-pin pwm-in-pin pull-up-pin pwm-in-pin fast-pin pwm-in-pin pwm-pin ['] handle-pwm pwm-vector! true to inited? then pwm-out-index bit pwm-in-index bit or disable-pwm pwm-in-index bit disable-pwm-int 0. counter 2! 0 pwm-out-index pwm-counter! 0 pwm-in-index pwm-counter! pwm-out-wrap pwm-out-index pwm-top! pwm-in-wrap pwm-in-index pwm-top! pwm-out-compare pwm-out-index pwm-counter-compare-a! pwm-out-index free-running-pwm pwm-in-index rising-edge-pwm 0 16 pwm-out-index pwm-clock-div! 0 1 pwm-in-index pwm-clock-div! pwm-in-index bit enable-pwm-int pwm-out-index bit pwm-in-index bit or enable-pwm begin key? not while cr counter 2@ d. 500 ms repeat key drop ; 
 : x-out-of-range-pwm ." cr ; 
 : x-out-of-range-clock-div ." cr ; 
 : x-out-of-range-counter ." cr ; 
 : x-out-of-range-compare ." cr ; 
 : x-out-of-range-top ." cr ; 
 : PWM_BASE constant ; 
 : pwm-regs $14 * PWM_BASE + ; 
 : CH_CSR pwm-regs $00 + ; 
 : CH_DIV pwm-regs $04 + ; 
 : CH_CTR pwm-regs $08 + ; 
 : CH_CC pwm-regs $0C + ; 
 : CH_TOP pwm-regs $10 + ; 
 : DIVMODE_FREE_RUNNING constant ; 
 : DIVMODE_GATED constant ; 
 : DIVMODE_RISING_EDGE constant ; 
 : DIVMODE_FALLING_EDGE constant ; 
 : CH_CSR_PH_ADV! 7 bit swap CH_CSR bis! ; 
 : CH_CSR_PH_ADV@ 7 bit swap CH_CSR bit@ ; 
 : CH_CSR_PH_RET! 6 bit swap CH_CSR bis! ; 
 : CH_CSR_PH_RET@ 6 bit swap CH_CSR bit@ ; 
 : CH_CSR_DIVMODE! CH_CSR { reg } reg @ $30 bic swap $3 and 4 lshift or reg ! ; 
 : CH_CSR_B_INV! swap if 3 bit swap CH_CSR bis! else 3 bit swap CH_CSR bic! then ; 
 : CH_CSR_A_INV! swap if 2 bit swap CH_CSR bis! else 2 bit swap CH_CSR bic! then ; 
 : CH_CSR_PH_CORRECT! swap if 1 bit swap CH_CSR bis! else 1 bit swap CH_CSR bic! then ; 
 : CH_DIV! { fract int index -- } int $FF and 4 lshift fract $F and or index CH_DIV ! ; 
 : CH_CC_B! { cc index -- } index CH_CC { reg } reg @ $FFFF0000 bic cc 16 lshift or reg ! ; 
 : CH_CC_A! { cc index -- } index CH_CC { reg } reg @ $0000FFFF bic cc $FFFF and or reg ! ; 
 : pwm-alternate constant ; 
 : pwm-irq constant ; 
 : core-init-hook-saved variable ; 
 : init-pwm-core-1 task::core-init-hook @ core-init-hook-saved ! [: core-init-hook-saved @ execute disable-int 0 pwm-irq NVIC_IPR_IP! pwm-irq NVIC_ISER_SETENA! enable-int ;] task::core-init-hook ! ; 
 : init-pwm disable-int [: $F INTR ! pwm-irq NVIC_ICPR_CLRPEND! ;] pwm-vector vector! 0 pwm-irq NVIC_IPR_IP! pwm-irq NVIC_ISER_SETENA! enable-int init-pwm-core-1 ; 
 : validate-pwm-index 8 u< averts x-out-of-range-pwm ; 
 : validate-pwm-mask $FF bic 0= averts x-out-of-range-pwm ; 
 : pwm-pin pwm-alternate swap alternate-pin ; 
 : pwm-vector! pwm-vector vector! ; 
 : enable-pwm dup validate-pwm-mask EN bis! ; 
 : disable-pwm dup validate-pwm-mask EN bic! ; 
 : enable-pwm-int dup validate-pwm-mask INTE bis! ; 
 : disable-pwm-int dup validate-pwm-mask INTE bic! ; 
 : clear-pwm-int dup validate-pwm-mask INTR bis! ; 
 : pwm-int@ INTS @ ; 
 : clear-pwm-pending pwm-irq NVIC_ICPR_CLRPEND! ; 
 : advance-pwm-phase { index -- } index validate-pwm-index index CH_CSR_PH_ADV! begin index CH_CSR_PH_ADV@ 0= until ; 
 : retard-pwm-phase { index -- } index validate-pwm-index index CH_CSR_PH_RET! begin index CH_CSR_PH_RET@ = until ; 
 : free-running-pwm dup validate-pwm-index DIVMODE_FREE_RUNNING swap CH_CSR_DIVMODE! ; 
 : gated-pwm dup validate-pwm-index DIVMODE_GATED swap CH_CSR_DIVMODE! ; 
 : rising-edge-pwm dup validate-pwm-index DIVMODE_RISING_EDGE swap CH_CSR_DIVMODE! ; 
 : falling-edge-pwm dup validate-pwm-index DIVMODE_FALLING_EDGE swap CH_CSR_DIVMODE! ; 
 : pwm-invert-b! dup validate-pwm-index CH_CSR_B_INV! ; 
 : pwm-invert-a! dup validate-pwm-index CH_CSR_A_INV! ; 
 : pwm-phase-correct! dup validate-pwm-index CH_CSR_PH_CORRECT! ; 
 : pwm-clock-div! dup validate-pwm-index over 0 u> averts x-out-of-range-clock-div over 256 u< averts x-out-of-range-clock-div 2 pick 16 u< averts x-out-of-range-clock-div CH_DIV! ; 
 : pwm-counter-compare-b! dup validate-pwm-index over 65536 u< averts x-out-of-range-compare CH_CC_B! ; 
 : pwm-counter-compare-a! dup validate-pwm-index over 65536 u< averts x-out-of-range-compare CH_CC_A! ; 
 : pwm-top! dup validate-pwm-index over 65536 u< averts x-out-of-range-top CH_TOP ! ; 
 : pwm-counter! dup validate-pwm-index over 65536 u< averts x-out-of-range-counter CH_CTR ! ; 
 : pwm-counter@ CH_CTR @ ; 
 : shade-max-input-shade variable ; 
 : shade-max-shade variable ; 
 : shade-shade variable ; 
 : shade-step-delay variable ; 
 : convert-shade s>f shade-max-input-shade @ s>f f/ pi f* cos dnegate 1,0 d+ 2,0 f/ shade-premultiply 2@ f* expm1 shade-premultiply 2@ expm1 f/ shade-multiply 2@ f* f>s ; 
 : shade-increment variable ; 
 : shade-level variable ; 
 : max-shade-level variable ; 
 : alarm-interval variable ; 
 : pwm-slice constant ; 
 : run-shade-led pwm-slice bit disable-pwm 125 shade-max-input-shade ! 125,0 shade-multiply 2! 15,0 shade-premultiply 2! 2500 alarm-interval ! 0 shade-level ! 1 shade-increment ! shade-max-input-shade @ convert-shade max-shade-level ! 25 pwm-pin 0 pwm-slice pwm-counter! max-shade-level @ pwm-slice pwm-top! 0 255 pwm-slice pwm-clock-div! true pwm-slice pwm-phase-correct! pwm-slice bit enable-pwm us-counter-lsb alarm-interval @ + ['] handle-alarm 0 set-alarm ; 
 : test0 0 [: 0 [: dup 4 umod dup 0= [: drop ." ;] qifelse ;] qifelse ;] qifelse 1+ 0 toggle-led 250 ms ;] qagain ;] 256 128 512 spawn run ; 
 : QUADSPI_Map_Base constant ; 
 : QUADSPI_Hidden_Size constant ; 
 : QUADSPI_Size constant ; 
 : qspi-inited? true ; 
 : map-qspi-enabled? true ; 
 : qspi-base QUADSPI_Map_Base QUADSPI_Hidden_Size + ; 
 : qspi-size QUADSPI_Size QUADSPI_Hidden_Size - ; 
 : erase-qspi-bulk qspi-base begin dup [ qspi-base qspi-size + ] literal < while dup erase-qspi-sector $10000 + repeat drop ; 
 : heap-size constant ; 
 : my-file-0-size constant ; 
 : my-file-1-size constant ; 
 : my-mount-file-size constant ; 
 : file-size@ 0 seek-end 2 pick seek-file tell-file ; 
 : init-test init-files heap-block-size heap-block-count my-heap init-heap my-mount-file-buffer my-mount-file-size 0 s" my-parent-fs <file-context> my-context init-object ; 
 : test-0 s" [: 0 swap list-dirs ;] my-context find-with-entity ; 
 : test-1 s" [: 1 [: begin 2dup 1 rot read-file 0> if dup c@ h.2 space false else true then until ;] with-allot ;] my-context find-with-entity ; 
 : heap-size constant ; 
 : my-file-0-size constant ; 
 : my-file-1-size constant ; 
 : my-mount-file-size constant ; 
 : file-size@ 0 seek-end 2 pick seek-file tell-file ; 
 : init-test init-files heap-block-size heap-block-count my-heap init-heap my-mount-file-buffer my-mount-file-size 0 s" my-parent-fs <file-context> my-context init-object ; 
 : test-0 s" [: 0 swap list-dirs ;] my-context find-with-entity ; 
 : bit-count constant ; 
 : init-rng-stats bit-count cells 0 fill ; 
 : rng-stats. bit-count 0 ?do cr ." f. drop ; 
 : rng-stats ram-here bit-count 2 * cells ram-allot dup init-rng-stats over 0 ?do random bit-count 0 ?do up i rshift 1 and if over 1 swap i cells + +! hen loop drop loop tuck swap rng-stats. ram-here! ; 
 : my-task-count constant ; 
 : producer 0 begin dup cr ." . 1+ 500 ms again ; 
 : consumer begin [: my-rchan recv-rchan ;] extract-allot-cell cr ." dup . [: my-rchan reply-rchan ;] provide-allot-cell again ; 
 : closer 8000 ms my-rchan close-rchan ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : closer-task variable ; 
 : init-test 420 128 512 my-task-count my-task-pool init-task-pool my-rchan init-rchan 0 ['] producer my-task-pool spawn-from-task-pool producer-task ! 0 ['] consumer my-task-pool spawn-from-task-pool consumer-task ! 0 ['] closer my-task-pool spawn-from-task-pool closer-task ! producer-task @ run consumer-task @ run closer-task @ run pause ; 
 : init-rchan-queue 0 over rchan-queue-first ! 0 swap rchan-queue-last ! ; 
 : find-rchan-queue-next rchan-queue-last @ begin dup while up rchan-wait-task @ task-priority@ pick >= if nip exit then chan-wait-next @ repeat nip ; 
 : push-rchan-queue then ; 
 : pop-rchan-queue then ; 
 : remove-rchan-queue ; 
 : wake-all-rchan-queue >r r@ rchan-queue-first @ begin ?dup while up rchan-wait-task @ ready chan-wait-prev @ repeat 0 r@ rchan-queue-first ! 0 r> rchan-queue-last ! ; 
 : x-rchan-closed ." cr ; 
 : x-reply-pending ." cr ; 
 : init-rchan dup rchan-slock init-slock false over rchan-closed ! dup rchan-send-queue init-rchan-queue dup rchan-recv-queue init-rchan-queue 0 over rchan-reply-task ! 0 over rchan-reply-buf ! 0 over rchan-reply-buf-size ! ; 
 : send-rchan hen ;] with-aligned-allot then s" trace ; 
 : recv-rchan hen ;] with-aligned-allot then s" trace ; 
 : reply-rchan then ; 
 : close-rchan [: >r true r@ rchan-closed ! r@ rchan-send-queue wake-all-rchan-queue r@ rchan-recv-queue wake-all-rchan-queue r@ rchan-reply-task @ 1 bic ?dup if ready then 0 r> rchan-reply-task ! ;] over rchan-slock with-slock ; 
 : rchan-closed? rchan-closed @ ; 
 : reopen-rchan [: true swap rchan-closed ! ;] over rchan-slock with-slock ; 
 : send-task variable ; 
 : middle-task variable ; 
 : reply-task variable ; 
 : send-loop 0 begin dup cr ." . 1+ again ; 
 : middle-loop begin [: my-rchan-0 recv-rchan ;] extract-allot-cell dup cr ." . [: my-rchan-0 reply-rchan ;] provide-allot-cell again ; 
 : reply-loop 0 begin [: my-rchan-1 recv-rchan ;] extract-allot-cell cr ." . dup [: my-rchan-1 reply-rchan ;] provide-allot-cell 1+ again ; 
 : init-test my-rchan-0 init-rchan my-rchan-1 init-rchan 0 ['] send-loop 420 128 512 spawn send-task ! 0 ['] middle-loop 420 128 512 spawn middle-task ! 0 ['] reply-loop 420 128 512 spawn reply-task ! send-task @ run middle-task @ run reply-task @ run ; 
 : consumer-task variable ; 
 : producer-task variable ; 
 : consumer begin [: my-rchan recv-rchan ;] extract-allot-cell drop 0 [: my-rchan reply-rchan ;] provide-allot-cell again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer begin 0 [: [: my-rchan send-rchan ;] extract-allot-cell ;] provide-allot-cell drop 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! my-rchan init-rchan 0 ['] consumer 420 128 512 1 spawn-on-core consumer-task ! 0 ['] producer 420 128 512 spawn producer-task ! consumer-task @ run producer-task @ run pause ; 
 : consumer begin [: my-rchan recv-rchan ;] extract-allot-cell drop 0 [: my-rchan reply-rchan ;] provide-allot-cell again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer begin 0 [: [: my-rchan send-rchan ;] extract-allot-cell ;] provide-allot-cell drop 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! my-rchan init-rchan consumer-task run producer-task run pause ; 
 : send-task variable ; 
 : reply-task variable ; 
 : send-loop 0 begin dup cr ." . 1+ again ; 
 : reply-loop 0 begin [: my-rchan recv-rchan ;] extract-allot-cell cr ." dup . dup [: my-rchan reply-rchan ;] provide-allot-cell 1+ again ; 
 : init-test my-rchan init-rchan 0 ['] send-loop 420 128 512 spawn send-task ! 0 ['] reply-loop 420 128 512 spawn reply-task ! send-task @ run reply-task @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! [: my-rchan recv-rchan ;] extract-allot-cell cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms 0 [: [: my-rchan send-rchan ;] extract-allot-cell ;] provide-allot-cell cr ." ; 
 : do-task-3 5000 timeout ! 50 ms 0 [: [: my-rchan send-rchan ;] extract-allot-cell ;] provide-allot-cell cr ." ; 
 : do-task-4 no-timeout timeout ! 75 ms 0 [: [: my-rchan send-rchan ;] extract-allot-cell ;] provide-allot-cell cr ." ; 
 : init-test my-rchan init-rchan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! 0 ['] do-task-4 420 128 512 spawn my-task-4 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run my-task-4 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms cr ." ; 
 : do-task-3 5000 timeout ! 50 ms cr ." ; 
 : do-task-4 no-timeout timeout ! 75 ms cr ." ; 
 : init-test my-rchan init-rchan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! 0 ['] do-task-4 420 128 512 spawn my-task-4 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run my-task-4 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms cr ." ; 
 : do-task-3 no-timeout timeout ! 50 ms cr ." ; 
 : do-task-4 no-timeout timeout ! 1000 ms cr ." ; 
 : init-test my-rchan init-rchan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! 0 ['] do-task-4 420 128 512 spawn my-task-4 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run my-task-4 @ run ; 
 : my-task-1 variable ; 
 : my-task-2 variable ; 
 : my-task-3 variable ; 
 : my-task-4 variable ; 
 : do-task-1 no-timeout timeout ! cr ." ; 
 : do-task-2 no-timeout timeout ! 25 ms 0 [: [: my-rchan send-rchan ;] extract-allot-cell ;] provide-allot-cell cr ." ; 
 : do-task-3 5000 timeout ! 50 ms 0 [: [: my-rchan send-rchan ;] extract-allot-cell ;] provide-allot-cell cr ." ; 
 : do-task-4 no-timeout timeout ! 75 ms 0 [: [: my-rchan send-rchan ;] extract-allot-cell ;] provide-allot-cell cr ." ; 
 : init-test my-rchan init-rchan 0 ['] do-task-1 420 128 512 spawn my-task-1 ! 0 ['] do-task-2 420 128 512 spawn my-task-2 ! 0 ['] do-task-3 420 128 512 spawn my-task-3 ! 0 ['] do-task-4 420 128 512 spawn my-task-4 ! my-task-1 @ run my-task-2 @ run my-task-3 @ run my-task-4 @ run ; 
 : my-task-count constant ; 
 : producer 0 begin dup cr ." . 1+ 500 ms again ; 
 : consumer [: my-rchan recv-rchan ;] extract-allot-cell cr ." . ; 
 : closer 2000 ms my-rchan close-rchan ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : closer-task variable ; 
 : init-test 420 128 512 my-task-count my-task-pool init-task-pool my-rchan init-rchan 0 ['] producer my-task-pool spawn-from-task-pool producer-task ! 0 ['] consumer my-task-pool spawn-from-task-pool consumer-task ! 0 ['] closer my-task-pool spawn-from-task-pool closer-task ! producer-task @ run consumer-task @ run closer-task @ run pause ; 
 : ROSC_Base constant ; 
 : random 32 0 begin over 0> while swap 1- swap 1 lshift RANDOMBIT @ 1 and or repeat nip ; 
 : rng-test-task variable ; 
 : rng-test begin 0 systick-counter begin ystick-counter over - 1000 systick-divisor * u< while wap 1+ swap random drop repeat drop cr . again ; 
 : rng-test-task 0 ['] rng-test 420 128 512 spawn rng-test-task ! rng-test-task @ run ; 
 : x-invalid-date-time ." cr ; 
 : RTC_Base constant ; 
 : rtc-irq constant ; 
 : RTC_SETUP_0_YEAR! { year -- } RTC_SETUP_0 @ $FFF000 bic year 12 lshift or RTC_SETUP_0 ! ; 
 : RTC_SETUP_0_MONTH! { month -- } RTC_SETUP_0 @ $F00 bic month 8 lshift or RTC_SETUP_0 ! ; 
 : RTC_SETUP_0_DAY! { day -- } RTC_SETUP_0 @ $1F bic day or RTC_SETUP_0 ! ; 
 : RTC_SETUP_1_DOTW! { dotw -- } RTC_SETUP_1 @ $7000000 bic dotw 24 lshift or RTC_SETUP_1 ! ; 
 : RTC_SETUP_1_HOUR! { hour -- } RTC_SETUP_1 @ $1F0000 bic hour 16 lshift or RTC_SETUP_1 ! ; 
 : RTC_SETUP_1_MIN! { minute -- } RTC_SETUP_1 @ $3F00 bic minute 8 lshift or RTC_SETUP_1 ! ; 
 : RTC_SETUP_1_SEC! { second -- } RTC_SETUP_1 @ $3F bic second or RTC_SETUP_1 ! ; 
 : RTC_CTRL_FORCE_NOTLEAPYEAR! { not-leap-year -- } 8 bit RTC_CTRL not-leap-year if bis! else bic! then ; 
 : RTC_CTRL_LOAD! 4 bit RTC_CTRL bis! ; 
 : RTC_CTRL_RTC_ACTIVE@ 1 bit RTC_CTRL bit@ ; 
 : RTC_CTRL_RTC_ENABLE! { enable -- } 0 bit RTC_CTRL enable if bis! else bic! then ; 
 : RTC_IRQ_SETUP_0_MATCH_ACTIVE@ 29 bit RTC_IRQ_SETUP_0 bit@ ; 
 : RTC_IRQ_SETUP_0_MATCH_ENA! { enable -- } 28 bit RTC_IRQ_SETUP_0 enable if bis! else bic! then ; 
 : RTC_IRQ_SETUP_0_YEAR_ENA! { enable -- } 26 bit RTC_IRQ_SETUP_0 enable if bis! else bic! then ; 
 : RTC_IRQ_SETUP_0_MONTH_ENA! { enable -- } 25 bit RTC_IRQ_SETUP_0 enable if bis! else bic! then ; 
 : RTC_IRQ_SETUP_0_DAY_ENA! { enable -- } 24 bit RTC_IRQ_SETUP_0 enable if bis! else bic! then ; 
 : RTC_IRQ_SETUP_0_YEAR! { year -- } RTC_IRQ_SETUP_0 @ $FFF000 bic year 12 lshift or RTC_IRQ_SETUP_0 ! ; 
 : RTC_IRQ_SETUP_0_MONTH! { month -- } RTC_IRQ_SETUP_0 @ $F00 bic month 8 lshift or RTC_IRQ_SETUP_0 ! ; 
 : RTC_IRQ_SETUP_0_DAY! { day -- } RTC_IRQ_SETUP_0 @ $1F bic day or RTC_IRQ_SETUP_0 ! ; 
 : RTC_IRQ_SETUP_1_DOTW_ENA! { enable -- } 31 bit RTC_IRQ_SETUP_1 enable if bis! else bic! then ; 
 : RTC_IRQ_SETUP_1_HOUR_ENA! { enable -- } 30 bit RTC_IRQ_SETUP_1 enable if bis! else bic! then ; 
 : RTC_IRQ_SETUP_1_MIN_ENA! { enable -- } 29 bit RTC_IRQ_SETUP_1 enable if bis! else bic! then ; 
 : RTC_IRQ_SETUP_1_SEC_ENA! { enable -- } 28 bit RTC_IRQ_SETUP_1 enable if bis! else bic! then ; 
 : RTC_IRQ_SETUP_1_DOTW! { dotw -- } RTC_IRQ_SETUP_1 @ $7000000 bic dotw 24 lshift or RTC_IRQ_SETUP_1 ! ; 
 : RTC_IRQ_SETUP_1_HOUR! { hour -- } RTC_IRQ_SETUP_1 @ $1F0000 bic hour 16 lshift or RTC_IRQ_SETUP_1 ! ; 
 : RTC_IRQ_SETUP_1_MIN! { minute -- } RTC_IRQ_SETUP_1 @ $3F00 bic minute 8 lshift or RTC_IRQ_SETUP_1 ! ; 
 : RTC_IRQ_SETUP_1_SEC! { second -- } RTC_IRQ_SETUP_1 @ $3F bic second or RTC_IRQ_SETUP_1 ! ; 
 : RTC_RTC_1_YEAR@ RTC_RTC_1 @ $FFF000 and 12 rshift ; 
 : RTC_RTC_1_MONTH@ RTC_RTC_1 @ $F00 and 8 rshift ; 
 : RTC_RTC_1_DAY@ RTC_RTC_1 @ $1F and ; 
 : RTC_RTC_0_DOTW@ RTC_RTC_0 @ $7000000 and 24 rshift ; 
 : RTC_RTC_0_HOUR@ RTC_RTC_0 @ $1F0000 and 16 rshift ; 
 : RTC_RTC_0_MIN@ RTC_RTC_0 @ $3F00 and 8 rshift ; 
 : RTC_RTC_0_SEC@ RTC_RTC_0 @ $3F and ; 
 : date-time@ [: { date-time } RTC_RTC_0_SEC@ date-time date-time-second c! RTC_RTC_0_MIN@ date-time date-time-minute c! RTC_RTC_0_HOUR@ date-time date-time-hour c! RTC_RTC_0_DOTW@ date-time date-time-dotw c! RTC_RTC_1_DAY@ date-time date-time-day c! RTC_RTC_1_MONTH@ date-time date-time-month c! RTC_RTC_1_YEAR@ date-time date-time-year ! ;] rtc-spinlock critical-with-spinlock ; 
 : test-range { test-value min-value max-value -- } test-value min-value >= averts x-invalid-date-time test-value max-value <= averts x-invalid-date-time ; 
 : leap-year? { year -- } year 100 umod 0= if year 400 umod 0= else year 4 umod 0= then ; 
 : validate-date-time date-time-size [: { new-date-time old-date-time } old-date-time date-time@ new-date-time date-time-year @ -1 <> if new-date-time date-time-year @ 0 4095 test-range new-date-time date-time-year @ else old-date-time date-time-year @ then { test-year } new-date-time date-time-month c@ $FF <> if new-date-time date-time-month c@ 1 31 test-range new-date-time date-time-month c@ else old-date-time date-time-month c@ then { test-month } new-date-time date-time-day c@ $FF <> if test-month 2 <> if new-date-time date-time-day c@ 1 days-in-month test-month + c@ test-range else new-date-time date-time-day c@ 1 test-year leap-year? if 29 else 28 then test-month then then new-date-time date-time-dotw c@ $FF <> if new-date-time date-time-dotw c@ 0 6 test-range then new-date-time date-time-hour c@ $FF <> if new-date-time date-time-hour c@ 0 23 test-range then new-date-time date-time-minute c@ $FF <> if new-date-time date-time-minute c@ 0 59 test-range then new-date-time date-time-second c@ $FF <> if new-date-time date-time-second c@ 0 59 test-range then ;] with-aligned-allot ; 
 : validate-date-time-not-current { date-time -- } date-time date-time-year @ -1 <> if date-time date-time-year @ 0 4095 test-range then date-time date-time-month c@ $FF <> if date-time date-time-month c@ 1 31 test-range then date-time date-time-day c@ $FF <> if date-time date-time-month c@ $FF <> if date-time date-time-month c@ 2 <> if date-time date-time-day c@ 1 days-in-month date-time date-time-month c@ + c@ test-range else date-time date-time-day c@ 1 date-time date-time-year @ -1 <> if date-time date-time-year @ leap-year? if 29 else 28 then else 29 then test-range then else date-time date-time-day c@ 1 31 test-range then then date-time date-time-dotw c@ $FF <> if date-time date-time-dotw c@ 0 6 test-range then date-time date-time-hour c@ $FF <> if date-time date-time-hour c@ 0 23 test-range then date-time date-time-minute c@ $FF <> if date-time date-time-minute c@ 0 59 test-range then date-time date-time-second c@ $FF <> if date-time date-time-second c@ 0 59 test-range then ; 
 : raw-date-time! { date-time -- } date-time date-time-year @ -1 <> if date-time date-time-year @ RTC_SETUP_0_YEAR! then date-time date-time-month c@ $FF <> if date-time date-time-month c@ RTC_SETUP_0_MONTH! then date-time date-time-day c@ $FF <> if date-time date-time-day c@ RTC_SETUP_0_DAY! then date-time date-time-dotw c@ $FF <> if date-time date-time-dotw c@ RTC_SETUP_1_DOTW! then date-time date-time-hour c@ $FF <> if date-time date-time-hour c@ RTC_SETUP_1_HOUR! then date-time date-time-minute c@ $FF <> if date-time date-time-minute c@ RTC_SETUP_1_MIN! then date-time date-time-second c@ $FF <> if date-time date-time-second c@ RTC_SETUP_1_SEC! then RTC_CTRL_LOAD! ; 
 : raw-date-time-match! { date-time -- } date-time date-time-year @ -1 <> if date-time date-time-year @ RTC_IRQ_SETUP_0_YEAR! true RTC_IRQ_SETUP_0_YEAR_ENA! else false RTC_IRQ_SETUP_0_YEAR_ENA! then date-time date-time-month c@ $FF <> if date-time date-time-month c@ RTC_IRQ_SETUP_0_MONTH! true RTC_IRQ_SETUP_0_MONTH_ENA! else false RTC_IRQ_SETUP_0_MONTH_ENA! then date-time date-time-day c@ $FF <> if date-time date-time-day c@ RTC_IRQ_SETUP_0_DAY! true RTC_IRQ_SETUP_0_DAY_ENA! else false RTC_IRQ_SETUP_0_DAY_ENA! then date-time date-time-dotw c@ $FF <> if date-time date-time-dotw c@ RTC_IRQ_SETUP_1_DOTW! true RTC_IRQ_SETUP_1_DOTW_ENA! else false RTC_IRQ_SETUP_1_DOTW_ENA! then date-time date-time-hour c@ $FF <> if date-time date-time-hour c@ RTC_IRQ_SETUP_1_HOUR! true RTC_IRQ_SETUP_1_HOUR_ENA! else false RTC_IRQ_SETUP_1_HOUR_ENA! then date-time date-time-minute c@ $FF <> if date-time date-time-minute c@ RTC_IRQ_SETUP_1_MIN! true RTC_IRQ_SETUP_1_MIN_ENA! else false RTC_IRQ_SETUP_1_MIN_ENA! then date-time date-time-second c@ $FF <> if date-time date-time-second c@ RTC_IRQ_SETUP_1_SEC! true RTC_IRQ_SETUP_1_SEC_ENA! else false RTC_IRQ_SETUP_1_SEC_ENA! then ; 
 : disable-rtc false RTC_CTRL_RTC_ENABLE! begin RTC_CTRL_RTC_ACTIVE@ not until ; 
 : enable-rtc true RTC_CTRL_RTC_ENABLE! begin RTC_CTRL_RTC_ACTIVE@ until ; 
 : init-rtc disable-rtc 46874 RTC_CLKDIV_M1 ! date-time-size [: { date-time } 1970 date-time date-time-year ! 1 date-time date-time-month c! 1 date-time date-time-day c! 4 date-time date-time-dotw c! 0 date-time date-time-hour c! 0 date-time date-time-minute c! 0 date-time date-time-second c! date-time raw-date-time! ;] with-aligned-allot enable-rtc ; 
 : date-time! { date-time -- } date-time validate-date-time disable-rtc date-time raw-date-time! enable-rtc ; 
 : set-rtc-alarm { date-time xt -- } date-time validate-date-time-not-current rtc-irq NVIC_ICER_CLRENA! 0 bit RTC_INTE bic! false RTC_IRQ_SETUP_0_MATCH_ENA! begin RTC_IRQ_SETUP_0_MATCH_ACTIVE@ not until date-time raw-date-time-match! xt rtc-vector vector! true RTC_IRQ_SETUP_0_MATCH_ENA! begin RTC_IRQ_SETUP_0_MATCH_ACTIVE@ until 0 bit RTC_INTE bis! rtc-irq NVIC_ISER_SETENA! ; 
 : clear-rtc-alarm rtc-irq NVIC_ICER_CLRENA! 0 bit RTC_INTE bic! false RTC_IRQ_SETUP_0_MATCH_ENA! begin RTC_IRQ_SETUP_0_MATCH_ACTIVE@ not until rtc-irq NVIC_ISER_SETENA! ; 
 : dotw-name case 0 of s" rot endcase ; 
 : month-name case 1 of s" rot endcase ; 
 : max-date-time-format-size constant ; 
 : format-date-time { addr date-time -- addr bytes } date-time validate-date-time-not-current addr { cur-addr } date-time date-time-dotw c@ $FF <> if date-time date-time-dotw c@ dotw-name cur-addr swap move s" cur-addr 3 + swap move 5 +to cur-addr then date-time date-time-day c@ s>d <# # # #> cur-addr swap move $20 cur-addr 2 + c! 3 +to cur-addr date-time date-time-month c@ month-name cur-addr swap move $20 cur-addr 3 + c! 4 +to cur-addr date-time date-time-year @ s>d <# # # # # #> cur-addr swap move $20 cur-addr 4 + c! 5 +to cur-addr date-time date-time-hour c@ s>d <# # # #> cur-addr swap move [char] : cur-addr 2 + c! 3 +to cur-addr date-time date-time-minute c@ s>d <# # # #> cur-addr swap move 2 +to cur-addr date-time date-time-second c@ $FF <> if [char] : cur-addr c! 1 +to cur-addr date-time date-time-second c@ s>d <# # # #> cur-addr swap move 2 +to cur-addr then addr cur-addr over - ; 
 : date-time. max-date-time-format-size [: swap format-date-time type ;] with-allot ; 
 : get-dotw { date-time -- dotw } date-time validate-date-time-not-current date-time date-time-year @ { year } date-time date-time-month c@ { month } year -1 <> month $FF <> and date-time date-time-day c@ $FF <> and if month 3 < if -1 +to year then year year 4 / + year 100 / - year 400 / + dotw-t month 1- + c@ + date-time date-time-day c@ + 7 umod else $FF then ; 
 : update-dotw { date-time -- } $FF date-time date-time-dotw c! date-time validate-date-time-not-current date-time get-dotw date-time date-time-dotw c! ; 
 : simple-date-time! date-time-size [: { year month day hour minute second date-time } year -1 <> if year 0 4095 test-range then month -1 <> month $FF <> and if month 1 12 test-range else $FF to month then day -1 <> day $FF <> and if day 1 31 test-range else $FF to day then hour -1 <> hour $FF <> and if hour 0 23 test-range else $FF to hour then minute -1 <> minute $FF <> and if minute 0 59 test-range else $FF to minute then second -1 <> second $FF <> and if second 0 59 test-range else $FF to second then year date-time date-time-year ! month date-time date-time-month c! day date-time date-time-day c! $FF date-time date-time-dotw c! hour date-time date-time-hour c! minute date-time date-time-minute c! second date-time date-time-second c! date-time update-dotw date-time date-time! ;] with-aligned-allot ; 
 : x-schan-closed ." cr ; 
 : schan-full? dup schan-recv-index @ 1+ over schan-count @ umod swap schan-send-index @ = ; 
 : schan-empty? dup schan-recv-index @ swap schan-send-index @ = ; 
 : send-schan-addr dup schan-send-index @ over schan-data-size @ * schan-header-size + + ; 
 : recv-schan-addr dup schan-recv-index @ over schan-data-size @ * schan-header-size + + ; 
 : advance-send-schan dup schan-send-index @ 1+ over schan-count @ umod swap schan-send-index ! ; 
 : advance-recv-schan dup schan-recv-index @ 1+ over schan-count @ umod swap schan-recv-index ! ; 
 : wait-send-schan begin up schan-send-slock claim-slock-timeout up schan-closed @ if schan-send-slock release-slock ['] x-schan-closed ?raise hen up schan-full? if dup schan-send-slock release-slock pause false lse true hen until drop ; 
 : wait-recv-schan begin up schan-recv-slock claim-slock-timeout up schan-empty? if dup schan-closed @ if schan-recv-slock release-slock ['] x-schan-closed ?raise then dup schan-recv-slock release-slock pause false lse true hen until drop ; 
 : schan-size 1+ * schan-header-size + 4 align ; 
 : init-schan dup schan-send-slock init-slock dup schan-recv-slock init-slock swap 1+ over schan-count ! tuck schan-data-size ! 0 over schan-send-index ! 0 over schan-recv-index ! false swap schan-closed ! ; 
 : send-schan dup schan-closed @ triggers x-schan-closed current-task prepare-block dup wait-send-schan dup send-schan-addr over schan-data-size @ 0 fill dup >r schan-data-size @ min r@ send-schan-addr swap move r> dup advance-send-schan schan-send-slock release-slock ; 
 : recv-schan current-task prepare-block dup wait-recv-schan >r 2dup 0 fill r@ schan-data-size @ min r@ recv-schan-addr -rot dup >r move 2r> dup advance-recv-schan schan-recv-slock release-slock ; 
 : peek-schan current-task prepare-block dup wait-recv-schan >r 2dup 0 fill r@ schan-data-size @ min r@ recv-schan-addr -rot dup >r move 2r> schan-recv-slock release-slock ; 
 : skip-schan current-task prepare-block dup wait-recv-schan dup advance-recv-schan schan-recv-slock release-slock ; 
 : send-schan-no-block dup schan-closed @ triggers x-schan-closed dup schan-send-slock try-claim-slock averts x-would-block dup schan-closed @ if schan-send-slock release-slock ['] x-schan-closed ?raise then dup schan-full? if schan-send-slock release-slock ['] x-would-block ?raise then dup send-schan-addr over schan-data-size @ 0 fill dup >r schan-data-size @ min r@ send-schan-addr swap move r> dup advance-send-schan schan-send-slock release-slock ; 
 : recv-schan-no-block dup schan-recv-slock try-claim-slock averts x-would-block dup schan-empty? if dup schan-closed @ if chan-recv-slock release-slock '] x-schan-closed ?raise else chan-recv-slock release-slock '] x-would-block ?raise then then >r 2dup 0 fill r@ schan-data-size @ min r@ recv-schan-addr -rot dup >r move 2r> dup advance-recv-schan schan-recv-slock release-slock ; 
 : peek-schan-no-block dup schan-recv-slock try-claim-slock averts x-would-block dup schan-empty? if dup schan-closed @ if chan-recv-slock release-slock '] x-schan-closed ?raise else chan-recv-slock release-slock '] x-would-block ?raise then then >r 2dup 0 fill r@ schan-data-size @ min r@ recv-schan-addr -rot dup >r move 2r> schan-recv-slock release-slock ; 
 : skip-schan-no-block dup schan-recv-slock try-claim-slock averts x-would-block dup schan-empty? if dup schan-closed @ if chan-recv-slock release-slock '] x-schan-closed ?raise else chan-recv-slock release-slock '] x-would-block ?raise then then dup wait-recv-schan dup advance-recv-schan schan-recv-slock release-slock ; 
 : close-schan true swap schan-closed ! ; 
 : schan-closed? schan-closed @ ; 
 : reopen-schan false swap schan-closed ! ; 
 : schan-count schan-count @ 1- ; 
 : schan-data-size schan-data-size @ ; 
 : element-size constant ; 
 : element-count constant ; 
 : consumer begin [: [: my-schan recv-schan-no-block ;] extract-allot-cell drop ;] try if ause then again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer begin [: 0 [: my-schan send-schan-no-block ;] provide-allot-cell ;] try if ause else send-count +! end-count @ send-count-limit > if 0 send-count ! systick-counter dup start-systick @ - cr ." 0 swap 0 send-count-limit f/ 10000,0 f/ 1,0 2swap f/ f. start-systick ! hen then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! element-size element-count my-schan init-schan consumer-task run producer-task run pause ; 
 : element-size constant ; 
 : element-count constant ; 
 : consumer begin [: [: my-schan recv-schan-no-block ;] extract-allot-cell drop ;] try drop again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer begin [: 0 [: my-schan send-schan-no-block ;] provide-allot-cell ;] try 0= if send-count +! end-count @ send-count-limit > if 0 send-count ! systick-counter dup start-systick @ - cr ." 0 swap 0 send-count-limit f/ 10000,0 f/ 1,0 2swap f/ f. start-systick ! hen then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! element-size element-count my-schan init-schan consumer-task run producer-task run pause ; 
 : element-size constant ; 
 : element-count constant ; 
 : consumer begin [: [: my-schan recv-schan-no-block ;] extract-allot-cell drop ;] try drop again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer begin [: 0 [: my-schan send-schan-no-block ;] provide-allot-cell ;] try 0= if send-count +! end-count @ send-count-limit > if 0 send-count ! systick-counter dup start-systick @ - cr ." 0 swap 0 send-count-limit f/ 10000,0 f/ 1,0 2swap f/ f. start-systick ! hen then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! element-size element-count my-schan init-schan consumer-task run producer-task run pause ; 
 : element-size constant ; 
 : element-count constant ; 
 : consumer begin [: my-schan recv-schan ;] extract-allot-cell drop again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer begin 0 [: my-schan send-schan ;] provide-allot-cell 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! element-size element-count my-schan init-schan consumer-task run producer-task run pause ; 
 : element-size constant ; 
 : element-count constant ; 
 : consumer begin [: my-schan recv-schan ;] extract-allot-cell drop again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : producer begin 0 [: my-schan send-schan ;] provide-allot-cell 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! element-size element-count my-schan init-schan consumer-task run producer-task run pause ; 
 : current-action user ; 
 : prev-action dup begin dup action-next @ 2 pick <> while action-next @ repeat tuck = if rop 0 then ; 
 : init-schedule 0 over schedule-current ! 0 swap schedule-last ! ; 
 : reset-action tuck action-xt ! 0 over action-active ! 0 over action-systick-start ! -1 swap action-systick-delay ! ; 
 : set-action-xt action-xt ! ; 
 : init-action begin-critical swap 2dup action-schedule ! 2 roll over action-xt ! 0 over action-active ! 0 over action-systick-start ! -1 over action-systick-delay ! over schedule-last @ 0= if 2dup swap schedule-last ! then over schedule-current @ 0<> if over schedule-current @ action-next @ over action-next ! tuck swap schedule-current @ action-next ! else dup dup action-next ! tuck swap schedule-current ! then end-critical ; 
 : dispose-action begin-critical dup action-schedule @ over -1 swap action-schedule ! dup schedule-current @ 2 pick = if over action-next @ 2 pick <> if wap action-next @ swap 2dup schedule-last @ action-next ! chedule-current ! else ip 0 over schedule-current ! 0 swap schedule-last ! then else dup schedule-last @ 2 pick = if ver prev-action 2dup swap schedule-last ! ip swap action-next @ swap action-next ! else rop dup prev-action swap action-next @ swap action-next ! then then end-critical ; 
 : action-disposed? action-schedule @ -1 = ; 
 : enable-action begin-critical dup action-active @ 1+ swap action-active ! end-critical ; 
 : disable-action begin-critical dup action-active @ 1- swap action-active ! end-critical ; 
 : force-enable-action begin-critical dup action-active @ 1 < if 1 swap action-active ! else drop then end-critical ; 
 : force-disable-action begin-critical dup action-active @ 0> if 0 swap action-active ! else drop then end-critical ; 
 : action-delay begin-critical tuck action-systick-start ! action-systick-delay ! end-critical ; 
 : action-delay-latest begin-critical dup action-systick-delay @ swap action-systick-start @ end-critical ; 
 : cancel-action-delay begin-critical 0 over action-systick-start ! -1 swap action-systick-delay ! end-critical ; 
 : run-schedule begin begin-critical dup schedule-current @ dup if up action-active @ 0> ver action-systick-delay @ -1 = ystick-counter 3 pick action-systick-start @ - pick action-systick-delay @ u>= or and f dup current-action ! dup [: end-critical action-xt @ execute begin-critical ;] try ?dup if end-critical execute begin-critical then 2dup swap schedule-last ! lse 2dup swap schedule-last @ = if wait-hook @ end-critical ?execute begin-critical then hen ction-next @ over schedule-current ! else rop then end-critical again ; 
 : yield r> 1 bic current-action @ action-xt ! ; 
 : yield-until postpone if postpone true postpone else postpone yield postpone false postpone then postpone until ; 
 : current-action current-action @ ; 
 : x-sd-timeout ." cr ; 
 : x-sd-init-error ." cr ; 
 : x-sd-read-error ." cr ; 
 : x-sd-write-error ." cr ; 
 : x-sd-not-sdhc ." cr ; 
 : x-block-zero-protected ." cr ; 
 : sd-init-timeout constant ; 
 : sd-erase-timeout constant ; 
 : sd-read-timeout constant ; 
 : sd-write-timeout constant ; 
 : sd-dummy-timeout constant ; 
 : sd-real-read-timeout constant ; 
 : sd-real-write-timeout constant ; 
 : CMD_GO_IDLE_STATE constant ; 
 : CMD_SEND_IF_COND constant ; 
 : CMD_SEND_CSD constant ; 
 : CMD_SEND_CID constant ; 
 : CMD_SEND_STATUS constant ; 
 : CMD_READ_BLOCK constant ; 
 : CMD_WRITE_BLOCK constant ; 
 : CMD_WRITE_MULTIPLE_BLOCK constant ; 
 : CMD_ERASE_WR_BLK_START constant ; 
 : CMD_ERASE_WR_BLK_END constant ; 
 : CMD_ERASE constant ; 
 : CMD_APP_CMD constant ; 
 : CMD_READ_OCR constant ; 
 : CMD_CRC_ON_OFF constant ; 
 : ACMD_SET_WR_BLOCK_ERASE_COUNT constant ; 
 : ACMD_SD_SEND_OP_CMD constant ; 
 : R1_READY_STATE constant ; 
 : R1_IDLE_STATE constant ; 
 : R1_ILLEGAL_COMMAND constant ; 
 : DATA_START_TOKEN constant ; 
 : buffer-count constant ; 
 : sector-size constant ; 
 : block-size constant ; 
 : my-spi constant ; 
 : init-test my-spi 2 spi-pin my-spi 3 spi-pin my-spi 4 spi-pin 5 output-pin 6 2 ?do i pull-up-pin loop 5 my-spi <sd> my-sd init-object my-sd init-sd my-buffer block-size 0 my-sd block@ my-buffer my-buffer block-size + dump ; 
 : flush-clear my-sd flush-blocks my-sd clear-blocks ; 
 : read-block my-buffer block-size $7F fill my-buffer block-size rot my-sd block@ my-buffer my-buffer block-size + dump ; 
 : read-block-part swap >r my-buffer block-size $7F fill my-buffer block-size r@ - rot r@ swap my-sd block-part@ my-buffer my-buffer block-size r> - + dump ; 
 : write-block my-buffer block-size $00 fill >r my-buffer ! my-buffer block-size r> my-sd block! ; 
 : write-block-part my-sd block-part! ; 
 : rw-block my-buffer block-size $00 fill >r my-buffer ! my-buffer block-size r@ my-sd block! my-sd flush-blocks my-sd clear-blocks my-buffer block-size $7F fill my-buffer block-size r> my-sd block@ my-buffer my-buffer block-size + dump ; 
 : find-first-block swap ?do my-buffer block-size i my-sd block@ my-buffer block-size + my-buffer ?do i c@ if j unloop unloop exit then loop loop -1 ; 
 : clear-blocks my-buffer block-size $00 fill swap ?do my-buffer block-size i my-sd block! loop ; 
 : target-task variable ; 
 : source-task variable ; 
 : target c" current-task task-name! target-sema take begin target-sema take source-sema give again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : source source-sema take begin target-sema give source-sema take 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! no-sema-limit 0 target-sema init-sema no-sema-limit 0 source-sema init-sema 0 ['] source 512 256 512 spawn source-task ! 0 ['] target 512 256 512 1 spawn-on-core target-task ! c" source-task @ task-name! target-task @ run source-task @ run target-sema give source-sema give pause ; 
 : no-sema-limit constant ; 
 : init-sema dup sema-slock init-slock dup sema-slock swap sema-tqueue init-tqueue-full ; 
 : take [: current-task prepare-block sema-tqueue wait-tqueue ;] over sema-slock with-slock ; 
 : give [: sema-tqueue wake-tqueue ;] over sema-slock with-slock ; 
 : ungive [: sema-tqueue unwake-tqueue ;] over sema-slock with-slock ; 
 : broadcast [: sema-tqueue wake-tqueue-all ;] over sema-slock with-slock ; 
 : target-task variable ; 
 : source-task variable ; 
 : target target-sema take begin target-sema take source-sema give again ; 
 : send-count variable ; 
 : start-systick variable ; 
 : send-count-limit constant ; 
 : source source-sema take begin target-sema give source-sema take 1 send-count +! send-count @ send-count-limit > if send-count ! ystick-counter dup start-systick @ - r ." 0 swap 0 send-count-limit f/ 0000,0 f/ 1,0 2swap f/ f. tart-systick ! then again ; 
 : init-test 0 send-count ! systick-counter start-systick ! c" source-task @ task-name! no-sema-limit 0 target-sema init-sema no-sema-limit 0 source-sema init-sema target-task @ run source-task @ run target-sema give source-sema give pause ; 
 : my-task-count constant ; 
 : init-sema-counter constant ; 
 : do-action [: cr ." dup . ;] my-lock with-lock my-sema give ; 
 : do-init-tasks 0 begin dup my-task-count 1- < while [: cr ." dup . ;] my-lock with-lock dup 1 ['] do-action my-task-pool spawn-from-task-pool run 1+ 1000 ms repeat drop ; 
 : init-test 420 128 512 my-task-count my-task-pool init-task-pool my-lock init-lock no-sema-limit init-sema-counter my-sema init-sema 0 ['] do-init-tasks my-task-pool spawn-from-task-pool run ; 
 : my-read-size constant ; 
 : small-read-size constant ; 
 : my-spi constant ; 
 : init-test 2 3 4 5 0 <simple-fat32-fs> my-fs init-object true my-fs write-through! ; 
 : ls-root <fat32-entry> my-entry init-object my-dir my-fs root-dir@ begin my-entry my-dir read-dir if 12 [: 12 my-entry file-name@ cr type space false ;] with-allot else true then until ; 
 : create-file [: my-file swap create-file ;] my-fs with-root-path my-file write-file ; 
 : create-dir [: my-dir swap create-dir ;] my-fs with-root-path ; 
 : ls [: my-dir swap open-dir ;] my-fs with-root-path begin my-entry my-dir read-dir if 12 [: 12 my-entry file-name@ cr type space false ;] with-allot else true then until ; 
 : cat cr [: my-file swap open-file ;] my-fs with-root-path begin my-read-buffer my-read-size my-file read-file dup 0> if my-read-buffer swap type false else drop true then until ; 
 : remove-file ['] remove-file my-fs with-root-path ; 
 : remove-dir ['] remove-dir my-fs with-root-path ; 
 : rename ['] rename my-fs with-root-path ; 
 : seek-test my-dir my-fs root-dir@ s" my-read-buffer small-read-size my-file read-file my-read-buffer swap type ; 
 : create-big-file false my-fs write-through! [: my-file swap fat32::create-file ;] my-fs with-root-path $10000 0 ?do key? if key drop leave then hex i 0 <# # # # # # # # # #> decimal my-file write-file drop i $FF and 0= if i h.8 then loop true my-fs write-through! ; 
 : char-cols constant ; 
 : char-rows constant ; 
 : char-count constant ; 
 : %% 0 { data } source >parse @ 8 + min + source drop >parse @ 1+ + ?do data 1 lshift to data i c@ [char] # = if data 1 or to data then loop source >parse @ 8 + min >parse ! drop data c, ." data h.2 ; 
 : align-this variable ; 
 : load-simple-font { char-data -- } begin char-data c@ 0<> while char-data c@ { c } 1 +to char-data char-rows 0 ?do char-data c@ i c a-simple-font char-row! 1 +to char-data loop repeat ; 
 : init-simple-font a-font-buf $20 char-cols char-rows $20 $7E <font> a-simple-font init-object char-data load-simple-font ; 
 : init-slock 0 swap ! ; 
 : try-claim-slock current-task swap slock-task test-set ; 
 : claim-slock begin current-task over slock-task test-set dup not if pause-reschedule-last then until drop ; 
 : claim-slock-timeout begin current-task compare-timeout if ['] x-timed-out ?raise else current-task over slock-task test-set dup not if pause-reschedule-last then then until drop ; 
 : release-slock 0 swap ! ; 
 : release-slock-block 0 swap current-task block-set ; 
 : with-slock >r r@ claim-slock try r> release-slock ?raise ; 
 : action [: rot recv-fchan ;] extract-allot-cell drop begin dup 0> while 1- swap . repeat drop pause 0 [: rot send-fchan ;] provide-allot-cell begin pause again ; 
 : init-test signal-0-fchan init-fchan signal-1-fchan init-fchan signal-2-fchan init-fchan signal-3-fchan init-fchan 420 128 512 3 my-task-pool init-task-pool signal-1-fchan 2 1 0 3 signal-0-fchan 6 ['] action my-task-pool spawn-from-task-pool run signal-2-fchan 12 11 10 3 signal-1-fchan 6 ['] action my-task-pool spawn-from-task-pool run signal-3-fchan 22 21 20 3 signal-2-fchan 6 ['] action my-task-pool spawn-from-task-pool run 0 [: signal-0-fchan send-fchan ;] provide-allot-cell [: signal-3-fchan recv-fchan ;] extract-allot-cell drop ; 
 : x-invalid-spi ." cr ; 
 : x-invalid-spi-clock ." cr ; 
 : x-invalid-spi-data-size ." cr ; 
 : spi-rx-buffer-size constant ; 
 : spi-tx-buffer-size constant ; 
 : spi-count constant ; 
 : validate-spi spi-count u< averts x-invalid-spi ; 
 : SPI_Base $4000 * $4003C000 + ; 
 : SPI_SSPCR0 SPI_Base $000 + ; 
 : SPI_SSPCR1 SPI_Base $004 + ; 
 : SPI_SSPDR SPI_Base $008 + ; 
 : SPI_SSPSR SPI_Base $00C + ; 
 : SPI_SSPCPSR SPI_Base $010 + ; 
 : SPI_SSPIMSC SPI_Base $014 + ; 
 : SPI_SSPRIS SPI_Base $018 + ; 
 : SPI_SSPMIS SPI_Base $01C + ; 
 : SPI_SSPICR SPI_Base $020 + ; 
 : SPI_SSPDMACR SPI_Base $024 + ; 
 : SPI_SSPCR0_SCR! SPI_SSPCR0 dup >r @ $FF00 bic swap $FF and 8 lshift or r> ! ; 
 : SPI_SSPCR0_SPH! 7 bit swap SPI_SSPCR0 rot if bis! else bic! then ; 
 : SPI_SSPCR0_SPO! 6 bit swap SPI_SSPCR0 rot if bis! else bic! then ; 
 : SPI_SSPCR0_FRF! SPI_SSPCR0 dup >r @ $30 bic swap $3 and 4 lshift or r> ! ; 
 : SPI_SSPCR0_DSS! SPI_SSPCR0 dup >r @ $F bic swap $F and or r> ! ; 
 : SPI_SSPCR1_SOD! 3 bit swap SPI_SSPCR1 rot if bis! else bic! then ; 
 : SPI_SSPCR1_MS! 2 bit swap SPI_SSPCR1 rot if bis! else bic! then ; 
 : SPI_SSPCR1_SSE! 1 bit swap SPI_SSPCR1 rot if bis! else bic! then ; 
 : SPI_SSPCR1_LBM! 0 bit swap SPI_SSPCR1 rot if bis! else bic! then ; 
 : SPI_SSPSR_BSY@ 4 bit swap SPI_SSPSR bit@ ; 
 : SPI_SSPSR_RFF@ 3 bit swap SPI_SSPSR bit@ ; 
 : SPI_SSPSR_RNE@ 2 bit swap SPI_SSPSR bit@ ; 
 : SPI_SSPSR_TNF@ 1 bit swap SPI_SSPSR bit@ ; 
 : SPI_SSPSR_TFE@ 0 bit swap SPI_SSPSR bit@ ; 
 : SPI_SSPIMSC_TXIM! 3 bit swap SPI_SSPIMSC rot if bis! else bic! then ; 
 : SPI_SSPIMSC_RXIM! 2 bit swap SPI_SSPIMSC rot if bis! else bic! then ; 
 : SPI_SSPIMSC_RTIM! 1 bit swap SPI_SSPIMSC rot if bis! else bic! then ; 
 : SPI_SSPIMSC_RORIM! 0 bit swap SPI_SSPIMSC rot if bis! else bic! then ; 
 : SPI_SSPMIS_TXMIS@ 3 bit swap SPI_SSPMIS bit@ ; 
 : SPI_SSPMIS_RXMIS@ 2 bit swap SPI_SSPMIS bit@ ; 
 : SPI_SSPMIS_RTMIS@ 1 bit swap SPI_SSPMIS bit@ ; 
 : SPI_SSPMIS_RORMIS@ 0 bit swap SPI_SSPMIS bit@ ; 
 : SPI_SSPICR_RTIC! 1 bit swap SPI_SSPICR rot if bis! else bic! then ; 
 : SPI_SSPICR_RORIC! 0 bit swap SPI_SSPICR rot if bis! else bic! then ; 
 : spi-irq 18 + ; 
 : spi-vector spi-irq 16 + ; 
 : spi-select spi-size * spi-buffers + ; 
 : spi-rx-read-index spi-select spi-rx-read-index ; 
 : spi-rx-write-index spi-select spi-rx-write-index ; 
 : spi-rx-buffer spi-select spi-rx-buffer ; 
 : spi-tx-read-index spi-select spi-tx-read-index ; 
 : spi-tx-write-index spi-select spi-tx-write-index ; 
 : spi-tx-buffer spi-select spi-tx-buffer ; 
 : spi-rx-handler spi-select spi-rx-handler ; 
 : spi-core-lock spi-select spi-core-lock ; 
 : spi-rx-full? dup spi-rx-write-index c@ swap spi-rx-read-index c@ spi-rx-buffer-size 1- + spi-rx-buffer-size umod = ; 
 : spi-rx-empty? dup spi-rx-read-index c@ swap spi-rx-write-index c@ = ; 
 : spi-write-rx dup spi-rx-full? not if uck dup spi-rx-write-index c@ swap spi-rx-buffer + h! up spi-rx-write-index c@ 2 + spi-rx-buffer-size mod wap spi-rx-write-index c! else drop then ; 
 : spi-read-rx dup spi-rx-empty? not if up spi-rx-read-index c@ over spi-rx-buffer + h@ ver spi-rx-read-index c@ 2 + spi-rx-buffer-size mod ot spi-rx-read-index c! else rop 0 then ; 
 : spi-tx-full? dup spi-tx-write-index c@ swap spi-tx-read-index c@ spi-tx-buffer-size 1- + spi-tx-buffer-size umod = ; 
 : spi-tx-empty? dup spi-tx-read-index c@ swap spi-tx-write-index c@ = ; 
 : spi-write-tx dup spi-tx-full? not if uck dup spi-tx-write-index c@ swap spi-tx-buffer + h! up spi-tx-write-index c@ 2 + spi-tx-buffer-size mod wap spi-tx-write-index c! else drop then ; 
 : spi-read-tx dup spi-tx-empty? not if up spi-tx-read-index c@ over spi-tx-buffer + h@ ver spi-tx-read-index c@ 2 + spi-tx-buffer-size mod ot spi-tx-read-index c! else rop 0 then ; 
 : handle-spi [: egin dup spi-tx-empty? not if dup SPI_SSPSR_TNF@ if dup spi-read-tx over SPI_SSPDR h! false else true then else true then ntil alse egin over spi-rx-full? not if over SPI_SSPSR_RNE@ if over SPI_SSPDR h@ 2 pick spi-write-rx drop true false else true then else true then ntil rue 2 pick SPI_SSPICR_RTIC! rue 2 pick SPI_SSPICR_RORIC! ;] over spi-core-lock with-core-lock-spin if dup spi-rx-handler @ ?execute then dup spi-tx-empty? not over SPI_SSPIMSC_TXIM! spi-irq NVIC_ICPR_CLRPEND! ; 
 : handle-spi0 0 handle-spi ; 
 : handle-spi1 1 handle-spi ; 
 : init-spi disable-int dup spi-core-lock init-core-lock 0 over spi-rx-read-index c! 0 over spi-rx-write-index c! 0 over spi-tx-read-index c! 0 over spi-tx-write-index c! 0 over spi-irq NVIC_IPR_IP! 0 over spi-rx-handler ! dup if ['] handle-spi1 else ['] handle-spi0 then over spi-vector vector! true over SPI_SSPIMSC_RXIM! spi-irq NVIC_ISER_SETENA! enable-int ; 
 : core-init-hook-saved variable ; 
 : init-spi-core-1 task::core-init-hook @ core-init-hook-saved ! [: core-init-hook-saved @ execute disable-int 0 0 spi-irq NVIC_IPR_IP! 0 1 spi-irq NVIC_IPR_IP! 0 spi-irq NVIC_ISER_SETENA! 1 spi-irq NVIC_ISER_SETENA! enable-int ;] task::core-init-hook ! ; 
 : find-spi-prescale 2 begin dup 254 <= while up 2 + 256 * 2 pick * 125000000 > if nip exit lse 2 + hen repeat nip ; 
 : find-spi-postdiv 256 begin dup 1 > while dup 1- * 125000000 swap / 3 pick > if nip nip exit lse 1- hen repeat nip nip ; 
 : spi-baud! dup validate-spi swap dup 125000000 u<= averts x-invalid-spi-clock dup find-spi-prescale dup 254 u<= averts x-invalid-spi-clock tuck find-spi-postdiv 1- rot tuck SPI_SSPCR0_SCR! SPI_SSPCPSR ! ; 
 : master-spi dup validate-spi false swap SPI_SSPCR1_MS! ; 
 : slave-spi dup validate-spi true swap SPI_SSPCR1_MS! ; 
 : motorola-spi dup validate-spi tuck SPI_SSPCR0_SPO! tuck SPI_SSPCR0_SPH! 0 swap SPI_SSPCR0_FRF! ; 
 : ti-ss-spi dup validate-spi 1 swap SPI_SSPCR0_FRF! ; 
 : natl-microwire-spi dup validate-spi 2 swap SPI_SSPCR0_FRF! ; 
 : spi-data-size! dup validate-spi swap dup 4 u>= averts x-invalid-spi-data-size dup 16 u<= averts x-invalid-spi-data-size 1- swap SPI_SSPCR0_DSS! ; 
 : enable-spi dup validate-spi true swap SPI_SSPCR1_SSE! ; 
 : disable-spi dup validate-spi false swap SPI_SSPCR1_SSE! ; 
 : enable-spi-tx dup validate-spi false swap SPI_SSPCR1_SOD! ; 
 : disable-spi-tx dup validate-spi true swap SPI_SSPCR1_SOD! ; 
 : enable-spi-loopback dup validate-spi true swap SPI_SSPCR1_LBM! ; 
 : disable-spi-loopback dup validate-spi false swap SPI_SSPCR1_LBM! ; 
 : spi-rx-handler! dup validate-spi spi-rx-handler ! ; 
 : spi-alternate validate-spi 1 ; 
 : spi-pin swap spi-alternate swap alternate-pin ; 
 : >spi dup validate-spi [: disable-int dup spi-tx-empty? if dup SPI_SSPSR_TNF@ not if dup spi-tx-full? not if tuck spi-write-tx true swap SPI_SSPIMSC_TXIM! then else SPI_SSPDR h! then else dup spi-tx-full? not if tuck spi-write-tx true swap SPI_SSPIMSC_TXIM! then then enable-int ;] over spi-core-lock with-core-lock-spin ; 
 : spi> dup validate-spi begin [: isable-int up spi-rx-empty? if dup SPI_SSPSR_RNE@ if SPI_SSPDR h@ enable-int false true else enable-int false then lse enable-int true true hen ;] over spi-core-lock with-core-lock-spin dup not if pause then until if spi-read-rx then ; 
 : >spi? dup validate-spi spi-tx-full? not ; 
 : spi>? dup validate-spi dup spi-rx-empty? not swap SPI_SSPSR_RNE@ or ; 
 : flush-spi dup validate-spi begin dup spi-tx-empty? not while pause repeat begin dup SPI_SSPSR_BSY@ while repeat drop ; 
 : drain-spi dup validate-spi begin dup spi>? while dup spi> drop repeat begin dup SPI_SSPSR_BSY@ while repeat begin dup spi>? while dup spi> drop repeat drop ; 
 : buffer>spi { buffer bytes spi -- } spi validate-spi spi drain-spi spi flush-spi spi spi-irq NVIC_ICER_CLRENA! bytes { bytes-to-recv } begin bytes 0> bytes-to-recv 0> or while buffer bytes bytes-to-recv spi [: { buffer bytes bytes-to-recv spi } 0 { bytes-sent } disable-int spi SPI_SSPSR_TNF@ spi SPI_SSPSR_RFF@ not and bytes-sent bytes < and if buffer bytes-sent + c@ spi SPI_SSPDR h! 1 +to bytes-sent then spi SPI_SSPSR_RNE@ bytes-to-recv 0> and if spi SPI_SSPDR h@ drop -1 +to bytes-to-recv then enable-int bytes-to-recv bytes-sent ;] over spi-core-lock with-core-lock-spin dup +to buffer negate +to bytes to bytes-to-recv repeat spi spi-irq NVIC_ISER_SETENA! ; 
 : spi>buffer { buffer bytes filler spi -- } spi validate-spi spi drain-spi spi flush-spi spi spi-irq NVIC_ICER_CLRENA! bytes { bytes-to-send } begin bytes 0> bytes-to-send 0> or while buffer bytes bytes-to-send filler spi [: { buffer bytes bytes-to-send filler spi } 0 { bytes-recvd } disable-int spi SPI_SSPSR_TNF@ spi SPI_SSPSR_RFF@ not and bytes-to-send 0> and if filler spi SPI_SSPDR h! -1 +to bytes-to-send then spi SPI_SSPSR_RNE@ bytes-recvd bytes < and if spi SPI_SSPDR h@ buffer bytes-recvd + c! 1 +to bytes-recvd then enable-int bytes-to-send bytes-recvd ;] over spi-core-lock with-core-lock-spin dup +to buffer negate +to bytes to bytes-to-send repeat spi spi-irq NVIC_ISER_SETENA! ; 
 : init-test 0 6 spi-pin 0 7 spi-pin 1 8 spi-pin 1 9 spi-pin 1 10 spi-pin 1 11 spi-pin 0 16 spi-pin 0 17 spi-pin 0 master-spi 1 slave-spi 2 0 do 1000000 i spi-baud! false false i motorola-spi 16 i spi-data-size! i enable-spi loop 100 ms 0 [: 256 begin dup 1 >spi 1 spi> ." . loop ;] 256 128 512 spawn run ; 
 : init-test 1 8 spi-pin 1 9 spi-pin 1 10 spi-pin 1 11 spi-pin 1 master-spi 281250 1 spi-baud! 16 1 spi-data-size! true false 1 motorola-spi 1 enable-spi 100 ms 0 [: 355 256 do i 1 >spi 1 spi> . 1 ms loop ;] 256 128 512 spawn run ; 
 : init-test 1 8 spi-pin 1 9 spi-pin 1 10 spi-pin 1 11 spi-pin 1 slave-spi true false 1 motorola-spi 16 1 spi-data-size! 9 pull-up-pin 10 pull-down-pin 1 enable-spi 100 ms 0 [: 65535 begin 1 >spi 1 spi> again ;] 256 128 512 spawn run ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-sprite-width constant ; 
 : my-sprite-height constant ; 
 : my-particle-count constant ; 
 : particle-ready-count variable ; 
 : init-display 14 15 my-buf my-width my-height SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object ; 
 : init-sprite my-sprite-buf my-sprite-width my-sprite-height <bitmap> my-sprite init-object my-sprite clear-bitmap $FF 1 2 0 1 op-set my-sprite draw-rect-const $FF 0 4 1 2 op-set my-sprite draw-rect-const $FF 1 2 3 1 op-set my-sprite draw-rect-const ; 
 : init-test init-display init-sprite my-schedule init-schedule 320 128 512 1 my-task-pool init-task-pool my-particle-count 1+ my-action-pool init-action-pool particle-size my-pool init-pool my-pool-data my-pool-size my-pool add-pool true to inited? ; 
 : draw-particle 0 current-data particle-x 2@ nip my-sprite-width 0 current-data particle-y 2@ nip my-sprite-height op-xor my-sprite my-ssd1306 draw-rect ; 
 : bounce-particle current-data particle-x 2@ 0,0 d<= if current-data particle-x-delta 2@ dabs current-data particle-x-delta 2! else current-data particle-x 2@ 0 my-width my-sprite-width - d>= if current-data particle-x-delta 2@ dabs dnegate current-data particle-x-delta 2! then then current-data particle-y 2@ 0,0 d<= if current-data particle-y-delta 2@ dabs current-data particle-y-delta 2! else current-data particle-y 2@ 0 my-height my-sprite-height - d>= if current-data particle-y-delta 2@ dabs dnegate current-data particle-y-delta 2! then then ; 
 : move-particle systick-counter { current-systick } current-systick current-data last-systick @ - { systick-diff } current-systick current-data last-systick ! 0 systick-diff 10000,0 f/ { fract-lo fract-hi } fract-lo fract-hi current-data particle-x-delta 2@ f* current-data particle-x 2+! fract-lo fract-hi current-data particle-y-delta 2@ f* current-data particle-y 2+! bounce-particle ; 
 : init-particle my-pool allocate-pool { particle } systick-counter particle last-systick ! random 0 2,0 f* { angle-lo angle-hi } random 0 0 my-width my-sprite-width - f* particle particle-x 2! random 0 0 my-height my-sprite-height - f* particle particle-y 2! angle-lo angle-hi cos my-particle-speed f* particle particle-x-delta 2! angle-lo angle-hi sin my-particle-speed f* particle particle-y-delta 2! my-schedule particle ['] particle-cycle my-action-pool add-action-from-pool drop ; 
 : init-updater my-schedule 0 ['] display-update my-action-pool add-action-from-pool drop ; 
 : run-bounce inited? not if init-test my-particle-count 0 ?do init-particle loop init-updater then 0 [: 0 particle-ready-count ! my-schedule run-schedule 0 particle-ready-count ! my-ssd1306 clear-bitmap my-ssd1306 update-display ;] my-task-pool spawn-from-task-pool run ; 
 : stop-bounce inited? if my-schedule stop-schedule then ; 
 : my-cols constant ; 
 : my-rows constant ; 
 : my-sprite-cols constant ; 
 : my-sprite-rows constant ; 
 : my-ball-count constant ; 
 : my-frame-delay constant ; 
 : generate-ufmod { mod-lo mod-hi -- value-lo value-hi } random random mod-lo mod-hi uf/mod 2drop ; 
 : init-ball { ball -- } 0 my-cols my-sprite-cols - generate-ufmod 0 my-sprite-cols 2,0 f/ d+ ball ball-col 2! 0 my-rows my-sprite-rows - generate-ufmod 0 my-sprite-rows 2,0 f/ d+ ball ball-row 2! pi 2,0 f* generate-ufmod { ball-dir-lo ball-dir-hi } ball-dir-lo ball-dir-hi cos my-ball-init-speed f* ball ball-delta-col 2! ball-dir-lo ball-dir-hi sin my-ball-init-speed f* ball ball-delta-row 2! ; 
 : init-display 14 15 my-buf my-cols my-rows SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object ; 
 : init-sprite my-sprite-buf my-sprite-cols my-sprite-rows <bitmap> my-sprite init-object $FF my-sprite-cols 2 / my-sprite-rows 2 / my-sprite-rows 2 / 1- op-set my-sprite draw-pixel-circle ; 
 : for-all-balls { xt -- } my-ball-count 0 ?do my-balls ball-size i * + xt execute loop ; 
 : draw-ball { ball -- } ball ball-col 2@ nip my-sprite-cols 2 / - { sprite-col } ball ball-row 2@ nip my-sprite-rows 2 / - { sprite-row } 0 sprite-col my-sprite-cols 0 sprite-row my-sprite-rows op-xor my-sprite my-ssd1306 draw-rect ; 
 : move-ball { ball -- } ball ball-delta-col 2@ ball ball-col 2+! ball ball-delta-row 2@ ball ball-row 2+! ; 
 : bounce-ball { ball -- } ball ball-col 2@ 0 my-sprite-cols 2,0 f/ d<= if ball ball-delta-col 2@ dabs ball ball-delta-col 2! else ball ball-col 2@ 0 my-cols 0 my-sprite-cols 2,0 f/ d- d>= if ball ball-delta-col 2@ dabs dnegate ball ball-delta-col 2! then then ball ball-row 2@ 0 my-sprite-rows 2,0 f/ d<= if ball ball-delta-row 2@ dabs ball ball-delta-row 2! else ball ball-row 2@ 0 my-rows 0 my-sprite-rows 2,0 f/ d- d>= if ball ball-delta-row 2@ dabs dnegate ball ball-delta-row 2! then then ; 
 : init-balls inited? not if init-display init-sprite ['] init-ball for-all-balls true to inited? then ; 
 : cycle-balls ['] draw-ball for-all-balls my-ssd1306 update-display ['] draw-ball for-all-balls ['] move-ball for-all-balls ['] bounce-ball for-all-balls ; 
 : run-balls init-balls systick-counter { last-frame } begin key? not while cycle-balls my-frame-delay last-frame current-task delay my-frame-delay +to last-frame repeat key drop my-ssd1306 clear-bitmap my-ssd1306 update-display ; 
 : run-balls-bkg init-balls 0 [: systick-counter { last-frame } begin cycle-balls my-frame-delay last-frame current-task delay my-frame-delay +to last-frame again ;] 320 128 512 spawn run ; 
 : my-cols constant ; 
 : my-rows constant ; 
 : width constant ; 
 : height constant ; 
 : init-sprite my-sprite-buf width height <bitmap> my-sprite init-object my-sprite clear-bitmap $FF 1 2 0 1 op-set my-sprite draw-rect-const $FF 0 4 1 2 op-set my-sprite draw-rect-const $FF 1 2 3 1 op-set my-sprite draw-rect-const ; 
 : init-test 14 15 my-buf my-cols my-rows SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object init-sprite ; 
 : bounce-square inited? not if init-test true to inited? then 0 0 1 1 { column row delta-column delta-row } begin key? not while $FF column width row height op-xor my-ssd1306 draw-rect-const my-ssd1306 update-display column width + my-cols >= if -1 to delta-column else column 0 <= if 1 to delta-column then then row height + my-rows >= if -1 to delta-row else row 0 <= if 1 to delta-row then then delta-column +to column delta-row +to row 100 ms repeat key drop ; 
 : bounce-sprite inited? not if init-test true to inited? then 0 0 1 1 { column row delta-column delta-row } begin key? not while 0 column width 0 row height op-or my-sprite my-ssd1306 draw-rect my-ssd1306 update-display column width + my-cols >= if -1 to delta-column else column 0 <= if 1 to delta-column then then row height + my-rows >= if -1 to delta-row else row 0 <= if 1 to delta-row then then delta-column +to column delta-row +to row 100 ms repeat key drop ; 
 : bounce-pixel inited? not if init-test true to inited? then my-cols 5 / 0 1 1 { column row delta-column delta-row } begin key? not while $FF column row op-xor my-ssd1306 draw-pixel-const my-ssd1306 update-display column my-cols >= if -1 to delta-column else column 0 <= if 1 to delta-column then then row my-rows >= if -1 to delta-row else row 0 <= if 1 to delta-row then then delta-column +to column delta-row +to row 100 ms repeat key drop ; 
 : bounce-pixel-cycle inited? not if init-test true to inited? then my-cols 5 / 1 { cycle delta-cycle } cycle 0 1 1 { column row delta-column delta-row } begin key? not while $FF column row op-xor my-ssd1306 draw-pixel-const column my-cols >= if -1 to delta-column else column 0 <= if 1 to delta-column then then row my-rows >= if -1 to delta-row else row 0 <= if 1 to delta-row then then delta-column +to column delta-row +to row column cycle = row 0= and if my-ssd1306 update-display cycle my-cols >= if -1 to delta-cycle else cycle 0 <= if 1 to delta-cycle then then delta-cycle +to cycle cycle to column 100 ms then repeat key drop ; 
 : random-sprites inited? not if init-test true to inited? then begin key? not while 0 random my-cols width - umod width 0 random my-rows height - umod height op-xor my-sprite my-ssd1306 draw-rect my-ssd1306 update-display repeat key drop ; 
 : random-pixels inited? not if init-test true to inited? then begin key? not while 256 0 do $FF random my-cols umod random my-rows umod op-xor my-ssd1306 draw-pixel-const loop my-ssd1306 update-display repeat key drop ; 
 : old-emit variable ; 
 : run-test emit-hook @ old-emit ! [: dup $20 >= over $0A = or over $0D = or over $08 = or over $09 = or if dup emit-ssd1306 then old-emit @ execute ;] emit-hook ! ; 
 : stop-test old-emit @ emit-hook ! erase-ssd1306 ; 
 : SSD1306_I2C_ADDR constant ; 
 : SSD1306_CMD_START constant ; 
 : SSD1306_DATA_START constant ; 
 : SSD1306_SETCONTRAST constant ; 
 : SSD1306_ENTIREDISPLAY_ON constant ; 
 : SSD1306_ENTIREDISPLAY_OFF constant ; 
 : SSD1306_SETINVERT_ON constant ; 
 : SSD1306_SETINVERT_OFF constant ; 
 : SSD1306_SETDISPLAY_OFF constant ; 
 : SSD1306_SETDISPLAY_ON constant ; 
 : SSD1306_SCROLL_SETUP_H_RIGHT constant ; 
 : SSD1306_SCROLL_SETUP_H_LEFT constant ; 
 : SSD1306_SCROLL_SETUP_HV_RIGHT constant ; 
 : SSD1306_SCROLL_SETUP_HV_LEFT constant ; 
 : SSD1306_SCROLL_SETUP_V constant ; 
 : SSD1306_SCROLL_DEACTIVATE constant ; 
 : SSD1306_SCROLL_ACTIVATE constant ; 
 : SSD1306_PAGE_COLSTART_LOW constant ; 
 : SSD1306_PAGE_COLSTART_HIGH constant ; 
 : SSD1306_PAGE_PAGESTART constant ; 
 : SSD1306_SETADDRESSMODE constant ; 
 : SSD1306_SETCOLRANGE constant ; 
 : SSD1306_SETPAGERANGE constant ; 
 : SSD1306_SETSTARTLINE constant ; 
 : SSD1306_COLSCAN_ASCENDING constant ; 
 : SSD1306_COLSCAN_DESCENDING constant ; 
 : SSD1306_SETMULTIPLEX constant ; 
 : SSD1306_COMSCAN_ASCENDING constant ; 
 : SSD1306_COMSCAN_DESCENDING constant ; 
 : SSD1306_VERTICALOFFSET constant ; 
 : SSD1306_SETCOMPINS constant ; 
 : SSD1306_SETDISPLAYCLOCKDIV constant ; 
 : SSD1306_SETPRECHARGE constant ; 
 : SSD1306_SETVCOMLEVEL constant ; 
 : SSD1306_NOP constant ; 
 : SSD1306_SETCHARGEPUMP constant ; 
 : init-i2c { self -- } self ssd1306-device @ { device } device self ssd1306-pin0 @ i2c-pin device self ssd1306-pin1 @ i2c-pin device master-i2c device 7-bit-i2c-addr self ssd1306-addr @ device i2c-target-addr! device enable-i2c ; 
 : begin-cmd { self -- } ram-here self ssd1306-cmd-base ! ; 
 : >cmd cram, ; 
 : send-cmd { self -- } self [: dup { self } self ssd1306-cmd-base @ dup ram-here swap - self ssd1306-device @ >i2c-stop drop ;] try nip self ssd1306-cmd-base @ ram-here! ?raise ; 
 : init-display { self -- } self begin-cmd SSD1306_CMD_START >cmd SSD1306_SETDISPLAY_OFF >cmd SSD1306_SETDISPLAYCLOCKDIV >cmd $80 >cmd SSD1306_SETMULTIPLEX >cmd self bitmap-rows @ 1 - >cmd SSD1306_VERTICALOFFSET >cmd 0 >cmd SSD1306_SETSTARTLINE $00 or >cmd SSD1306_SETCHARGEPUMP >cmd $14 >cmd SSD1306_SETADDRESSMODE >cmd $00 >cmd SSD1306_COLSCAN_DESCENDING >cmd SSD1306_COMSCAN_DESCENDING >cmd SSD1306_SETCOMPINS >cmd self bitmap-rows @ 32 > if $12 else $02 then >cmd SSD1306_SETCONTRAST >cmd $01 >cmd SSD1306_SETPRECHARGE >cmd $F1 >cmd SSD1306_SETVCOMLEVEL >cmd $40 >cmd SSD1306_ENTIREDISPLAY_OFF >cmd SSD1306_SETINVERT_OFF >cmd SSD1306_SCROLL_DEACTIVATE >cmd SSD1306_SETDISPLAY_ON >cmd self send-cmd ; 
 : send-row { start-col end-col page self -- } self begin-cmd SSD1306_DATA_START >cmd page self page-addr dup end-col + swap start-col + ?do i c@ >cmd loop self send-cmd ; 
 : send-area { start-col end-col start-page end-page self -- } end-page start-page ?do start-col end-col i self send-row loop ; 
 : update-area { start-col end-col start-row end-row self -- } start-row 3 rshift { start-page } end-row 8 align 3 rshift { end-page } start-page end-page < if self begin-cmd SSD1306_CMD_START >cmd SSD1306_SETPAGERANGE >cmd start-page >cmd end-page 1- >cmd SSD1306_SETCOLRANGE >cmd start-col >cmd end-col 1- >cmd self send-cmd start-col end-col start-page end-page self send-area then ; 
 : life-width constant ; 
 : life-height constant ; 
 : life-start-col variable ; 
 : life-end-col variable ; 
 : life-start-row variable ; 
 : life-end-row variable ; 
 : redraw-life? variable ; 
 : magnify-life? variable ; 
 : life-line-buffer variable ; 
 : current-buffer variable ; 
 : new-buffer variable ; 
 : life-task variable ; 
 : cmd-stop-life constant ; 
 : cmd-step-life constant ; 
 : cmd-run-life constant ; 
 : cmd-pause-life constant ; 
 : cmd-unpause-life constant ; 
 : pause-life-counter variable ; 
 : draw-alive-cell { col row -- } magnify-life? @ if $FF col life-start-col @ - 2 * 2 row life-start-row @ - 2 * 2 op-set my-ssd1306 draw-rect-const else $FF col row op-set my-ssd1306 draw-pixel-const then ; 
 : draw-dead-cell { col row -- } magnify-life? @ if $00 col life-start-col @ - 2 * 2 row life-start-row @ - 2 * 2 op-set my-ssd1306 draw-rect-const else $00 col row op-set my-ssd1306 draw-pixel-const then ; 
 : draw-cell { alive col row -- } alive if col row draw-alive-cell else col row draw-dead-cell then ; 
 : wrap-coord dup life-height >= if drop 0 then dup 0< if drop life-height 1- then swap dup life-width >= if drop 0 then dup 0< if drop life-width 1- then swap ; 
 : alive? life-width * + current-buffer @ + c@ 16 >= ; 
 : +alive life-width * + current-buffer @ + 1 swap c+! ; 
 : -alive life-width * + current-buffer @ + -1 swap c+! ; 
 : set-dead 2dup 1+ wrap-coord -alive 2dup 1+ swap 1+ swap wrap-coord -alive 2dup 1+ swap 1- swap wrap-coord -alive 2dup swap 1+ swap wrap-coord -alive 2dup 1- wrap-coord -alive 2dup 1- swap 1+ swap wrap-coord -alive 2dup 1- swap 1- swap wrap-coord -alive 2dup swap 1- swap wrap-coord -alive 2dup draw-dead-cell life-width * + current-buffer @ + 16 swap cbic! ; 
 : set-alive 2dup 1+ wrap-coord +alive 2dup 1+ swap 1+ swap wrap-coord +alive 2dup 1+ swap 1- swap wrap-coord +alive 2dup swap 1+ swap wrap-coord +alive 2dup 1- wrap-coord +alive 2dup 1- swap 1+ swap wrap-coord +alive 2dup 1- swap 1- swap wrap-coord +alive 2dup swap 1- swap wrap-coord +alive 2dup draw-alive-cell life-width * + current-buffer @ + 16 swap cbis! ; 
 : alive! rot if 2dup alive? not if set-alive else 2drop then else 2dup alive? if set-dead else 2drop then then ; 
 : new-alive? life-width * + new-buffer @ + c@ 16 >= ; 
 : +new-alive life-width * + new-buffer @ + 1 swap c+! ; 
 : -new-alive life-width * + new-buffer @ + -1 swap c+! ; 
 : set-new-dead 2dup 1+ wrap-coord -new-alive 2dup 1+ swap 1+ swap wrap-coord -new-alive 2dup 1+ swap 1- swap wrap-coord -new-alive 2dup swap 1+ swap wrap-coord -new-alive 2dup 1- wrap-coord -new-alive 2dup 1- swap 1+ swap wrap-coord -new-alive 2dup 1- swap 1- swap wrap-coord -new-alive 2dup swap 1- swap wrap-coord -new-alive 2dup draw-dead-cell life-width * + new-buffer @ + 16 swap cbic! ; 
 : set-new-alive 2dup 1+ wrap-coord +new-alive 2dup 1+ swap 1+ swap wrap-coord +new-alive 2dup 1+ swap 1- swap wrap-coord +new-alive 2dup swap 1+ swap wrap-coord +new-alive 2dup 1- wrap-coord +new-alive 2dup 1- swap 1+ swap wrap-coord +new-alive 2dup 1- swap 1- swap wrap-coord +new-alive 2dup swap 1- swap wrap-coord +new-alive 2dup draw-alive-cell life-width * + new-buffer @ + 16 swap cbis! ; 
 : new-alive! rot if 2dup alive? not if set-new-alive else 2drop then else 2dup alive? if set-new-dead else 2drop then then ; 
 : set-new-dead-nonborder 2dup 1+ -new-alive 2dup 1+ swap 1+ swap -new-alive 2dup 1+ swap 1- swap -new-alive 2dup swap 1+ swap -new-alive 2dup 1- -new-alive 2dup 1- swap 1+ swap -new-alive 2dup 1- swap 1- swap -new-alive 2dup swap 1- swap -new-alive 2dup draw-dead-cell life-width * + new-buffer @ + 16 swap cbic! ; 
 : set-new-alive-nonborder 2dup 1+ +new-alive 2dup 1+ swap 1+ swap +new-alive 2dup 1+ swap 1- swap +new-alive 2dup swap 1+ swap +new-alive 2dup 1- +new-alive 2dup 1- swap 1+ swap +new-alive 2dup 1- swap 1- swap +new-alive 2dup swap 1- swap +new-alive 2dup draw-alive-cell life-width * + new-buffer @ + 16 swap cbis! ; 
 : cycle-cell 2dup life-width * + current-buffer @ + c@ 2 lshift nonborder-state-table + @ execute ; 
 : switch-buffers current-buffer @ new-buffer @ current-buffer ! new-buffer ! ; 
 : cycle-life [: current-buffer @ new-buffer @ life-width life-height * move 0 begin dup life-height < while 0 over false -rot new-alive! life-width 1- over false -rot new-alive! 1+ repeat drop 0 begin dup life-width < while dup 0 false -rot new-alive! dup life-height 1- false -rot new-alive! 1+ repeat drop 1 begin dup life-width 1- < while 1 begin dup life-height 1- < while 2dup cycle-cell 1+ repeat drop 1+ repeat drop switch-buffers ;] life-lock with-lock ; 
 : redraw-life redraw-life? @ if life-end-row @ life-start-row @ ?do life-end-col @ life-start-col @ ?do i j alive? i j draw-cell loop loop false redraw-life? ! then ; 
 : display-life redraw-life my-ssd1306 update-display ; 
 : send-cmd [: life-cmd-chan send-chan ;] provide-allot-cell [: life-resp-chan recv-chan ;] extract-allot-cell drop ; 
 : recv-cmd [: life-cmd-chan recv-chan ;] extract-allot-cell ; 
 : ack-cmd 0 [: life-resp-chan send-chan ;] provide-allot-cell ; 
 : do-step-life cycle-life display-life ; 
 : do-pause-life begin recv-cmd case cmd-pause-life of 1 pause-life-counter +! endof cmd-unpause-life of -1 pause-life-counter +! endof endcase ack-cmd pause-life-counter @ 0<= display-life until ; 
 : do-run-life begin life-cmd-chan chan-empty? if cycle-life display-life false else recv-cmd case cmd-stop-life of ack-cmd true endof cmd-pause-life of ack-cmd 1 pause-life-counter +! pause-life-counter @ 0> if do-pause-life then false endof cmd-unpause-life of ack-cmd -1 pause-life-counter +! false endof ack-cmd false swap endcase then until ; 
 : run-life-task begin recv-cmd case cmd-stop-life of ack-cmd endof cmd-step-life of do-step-life ack-cmd endof cmd-run-life of ack-cmd do-run-life endof cmd-pause-life of ack-cmd 1 pause-life-counter +! pause-life-counter @ 0> if do-pause-life then endof cmd-unpause-life of ack-cmd -1 pause-life-counter +! endof ack-cmd endcase again ; 
 : run-life cmd-run-life send-cmd ; 
 : step-life cmd-step-life send-cmd ; 
 : stop-life cmd-stop-life send-cmd ; 
 : pause-life cmd-pause-life send-cmd ; 
 : unpause-life cmd-unpause-life send-cmd ; 
 : with-life-paused pause-life [: life-lock with-lock ;] try unpause-life ?raise ; 
 : clear-life [: current-buffer @ life-width life-height * 0 fill true redraw-life? ! ;] with-life-paused ; 
 : zoom-out [: 0 life-start-col ! life-width life-end-col ! 0 life-start-row ! life-height life-end-row ! true redraw-life? ! false magnify-life? ! ;] with-life-paused ; 
 : zoom-in [: { col row } col 0 max life-width 2 / min to col row 0 max life-height 2 / min to row col life-start-col ! col life-width 2 / + life-end-col ! row life-start-row ! row life-height 2 / + life-end-row ! true redraw-life? ! true magnify-life? ! ;] with-life-paused ; 
 : init-life lock-inited? not if life-lock init-lock true to lock-inited? then [: life-buffer-0 current-buffer ! life-buffer-1 new-buffer ! 0 life-start-col ! life-width life-end-col ! 0 life-start-row ! life-height life-end-row ! false redraw-life? ! false magnify-life? ! ;] life-lock with-lock display-inited? not if 14 15 my-framebuffer life-width life-height SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object $01 my-ssd1306 display-contrast! true to display-inited? then task-inited? not if 0 pause-life-counter ! cell 1 life-cmd-chan init-chan cell 1 life-resp-chan init-chan 0 ['] run-life-task 320 128 512 spawn life-task ! life-task @ run true to task-inited? then clear-life ; 
 : get-char begin dup 0 > if ver c@ dup $20 <> if rot 1 + rot 1 - rot true lse drop 1 - swap 1 + swap false hen else true then until ; 
 : set-multiple [: over >r 2swap begin get-char dup 0<> while case [char] _ of 2swap 2dup false -rot alive! swap 1 + swap 2swap endof [char] * of 2swap 2dup true -rot alive! swap 1 + swap 2swap endof [char] / of 2swap 1 + nip r@ swap 2swap endof endcase repeat drop 2drop 2drop rdrop ;] with-life-paused ; 
 : flip-vert [: { x cols y rows } rows 2 u/ { rows2/ } rows 2 umod 0= if rows2/ 0 ?do cols 0 ?do x i + y rows2/ + 1- j - alive? { alive0? } x i + y rows2/ + j + alive? { alive1? } alive0? x i + y rows2/ + j + alive! alive1? x i + y rows2/ + 1- j - alive! loop loop else rows2/ 0 ?do cols 0 ?do x i + y rows2/ + 1- j - alive? { alive0? } x i + y rows2/ + 1+ j + alive? { alive1? } alive0? x i + y rows2/ + 1+ j + alive! alive1? x i + y rows2/ + 1- j - alive! loop loop then ;] with-life-paused ; 
 : flip-horiz [: { x cols y rows } cols 2 u/ { cols2/ } cols 2 umod 0= if rows 0 ?do cols2/ 0 ?do x cols2/ + 1- i - y j + alive? { alive0? } x cols2/ + i + y j + alive? { alive1? } alive0? y cols2/ + i + y j + alive! alive1? y cols2/ + 1- i - y j + alive! loop loop else rows 0 ?do cols2/ 0 ?do x cols2/ + 1- i - y j + alive? { alive0? } x cols2/ + 1+ i + y j + alive? { alive1? } alive0? y cols2/ + 1+ i + y j + alive! alive1? y cols2/ + 1- i - y j + alive! loop loop then ;] with-life-paused ; 
 : block s" 2swap set-multiple ; 
 : tub s" 2swap set-multiple ; 
 : boat s" 2swap set-multiple ; 
 : blinker rot case 0 of s" endof endcase 2swap set-multiple ; 
 : glider rot case 0 of s" endof endcase 2swap set-multiple ; 
 : r-pentomino s" 2swap set-multiple ; 
 : alive! [: 3dup alive! ;] with-life-paused drop 2drop ; 
 : alive? [: 2dup alive? ;] with-life-paused >r 2drop r> ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-sprite-width constant ; 
 : my-sprite-height constant ; 
 : run-test 14 15 my-buf my-width my-height SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object my-sprite-buf my-sprite-width my-sprite-height <bitmap> my-sprite init-object $FF 1 2 0 1 op-set my-sprite draw-rect-const $FF 0 4 1 2 op-set my-sprite draw-rect-const $FF 1 2 3 1 op-set my-sprite draw-rect-const $FF 64 32 16 - 64 32 16 + op-set my-ssd1306 draw-pixel-line $FF 64 16 - 32 64 16 + 32 op-set my-ssd1306 draw-pixel-line $FF 4 4 2 2 2 61 op-set my-ssad1306 draw-rect-line $FF 4 4 2 61 125 61 op-set my-ssad1306 draw-rect-line $FF 4 4 126 61 126 2 op-set my-ssad1306 draw-rect-line $FF 4 4 126 2 2 2 op-set my-ssad1306 draw-rect-line 0 0 4 4 64 16 - 32 16 - 64 16 + 32 16 + op-or my-sprite my-ssd1306 draw-bitmap-line 0 0 4 4 64 16 - 32 16 + 64 16 + 32 16 - op-or my-sprite my-ssd1306 draw-bitmap-line my-ssd1306 update-display ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-brush-width constant ; 
 : my-brush-height constant ; 
 : init-test 14 15 my-buf my-width my-height SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object my-brush-buf my-brush-width my-brush-height <bitmap> my-brush init-object $FF 2 2 0 my-brush-height op-set my-brush draw-rect-const $FF 0 my-brush-width 2 2 op-set my-brush draw-rect-const $FF 1 4 1 4 op-set my-brush draw-rect-const $FF 0 0 my-width 1- my-height 1- op-set my-ssd1306 draw-pixel-line $FF 4 4 0 my-height 1- my-width 1- 0 op-set my-ssd1306 draw-rect-line 0 0 my-brush-width my-brush-height my-width 3 / my-height 2 / my-width 3 / 2 * my-height 2 / op-or my-brush my-ssd1306 draw-bitmap-line $FF my-width 4 / my-width 2 / my-height 4 / my-height 2 / op-xor my-ssd1306 draw-rect-const 0 my-width 2 / my-brush-width 2 / - my-brush-width 0 my-height 2 / my-brush-height 2 / - my-brush-height op-xor my-brush my-ssd1306 draw-rect my-ssd1306 update-display ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-char-width constant ; 
 : my-char-height constant ; 
 : old-cursor-col variable ; 
 : old-cursor-row variable ; 
 : cursor-col variable ; 
 : cursor-row variable ; 
 : dirty-start-col variable ; 
 : dirty-start-row variable ; 
 : dirty-end-col variable ; 
 : dirty-end-row variable ; 
 : dirty-all-ssd1306-text 0 dirty-start-col ! 0 dirty-start-row ! my-chars-width dirty-end-col ! my-chars-height dirty-end-row ! ; 
 : clear-ssd1306-dirty 0 dirty-start-col ! 0 dirty-start-row ! 0 dirty-end-col ! 0 dirty-end-row ! ; 
 : dirty-ssd1306-char { col row -- } dirty-start-col @ col min dirty-start-col ! dirty-start-row @ row min dirty-start-row ! dirty-end-col @ col 1+ max dirty-end-col ! dirty-end-row @ row 1+ max dirty-end-row ! ; 
 : draw-cursor { col row -- } $FF col my-char-width * my-char-width row my-char-height * my-char-height op-xor my-ssd1306 draw-rect-const ; 
 : init-ssd1306-text my-lock init-lock [: 14 15 my-buf my-width my-height SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object my-char-buf my-char-buf-size $20 fill 0 old-cursor-col ! 0 old-cursor-row ! 0 cursor-col ! 0 cursor-row ! dirty-all-ssd1306-text init-simple-font 0 0 draw-cursor true to inited? ;] my-lock with-lock ; 
 : render-ssd1306-text old-cursor-col @ old-cursor-row @ draw-cursor dirty-end-row @ dirty-start-row @ ?do dirty-end-col @ dirty-start-col @ ?do my-char-buf my-chars-width j * + i + c@ my-char-width i * my-char-height j * op-set my-ssd1306 a-simple-font draw-char loop loop cursor-col @ cursor-row @ draw-cursor my-ssd1306 update-display clear-ssd1306-dirty cursor-col @ old-cursor-col ! cursor-row @ old-cursor-row ! ; 
 : scroll-ssd1306-text my-char-buf my-chars-width + my-char-buf my-chars-width my-chars-height 1- * move my-char-buf my-chars-width my-chars-height 1- * + my-chars-width $20 fill cursor-row @ 1- 0 max cursor-row ! dirty-all-ssd1306-text ; 
 : pre-advance-ssd1306-cursor cursor-col @ my-chars-width = if 0 cursor-col ! 1 cursor-row +! then cursor-row @ my-chars-height = if scroll-ssd1306-text 0 cursor-col ! then ; 
 : advance-ssd1306-cursor 1 cursor-col +! ; 
 : bs-ssd1306-cursor -1 cursor-col +! cursor-col @ 0< if my-chars-width 1- cursor-col ! cursor-row @ 0> if -1 cursor-row +! else 0 cursor-col ! then then ; 
 : add-ssd1306-char { c -- } c $0A = if cursor-row @ 1+ my-chars-height min cursor-row ! cursor-row @ my-chars-height = if scroll-ssd1306-text then else c $0D = if 0 cursor-col ! else c $08 = if bs-ssd1306-cursor else pre-advance-ssd1306-cursor c my-char-buf my-chars-width cursor-row @ * + cursor-col @ + c! cursor-col @ cursor-row @ dirty-ssd1306-char advance-ssd1306-cursor then then then ; 
 : erase-ssd1306 inited? not if init-ssd1306-text then [: my-char-buf my-chars-width my-chars-height * $20 fill 0 cursor-col ! 0 cursor-row ! 0 old-cursor-col ! 0 old-cursor-row ! dirty-all-ssd1306-text my-ssd1306 clear-bitmap my-ssd1306 update-display 0 0 draw-cursor ;] my-lock with-lock ; 
 : clear-ssd1306 inited? not if init-ssd1306-text then [: my-char-buf my-chars-width my-chars-height * $20 fill 0 cursor-col ! 0 cursor-row ! dirty-all-ssd1306-text render-ssd1306-text ;] my-lock with-lock ; 
 : emit-ssd1306 inited? not if init-ssd1306-text then [: add-ssd1306-char render-ssd1306-text ;] my-lock with-lock ; 
 : type-ssd1306 inited? not if init-ssd1306-text then [: { c-addr u } u 0 ?do c-addr i + c@ add-ssd1306-char loop render-ssd1306-text ;] my-lock with-lock ; 
 : cr-ssd1306 inited? not if init-ssd1306-text then [: cursor-row @ 1+ my-chars-height min cursor-row ! 0 cursor-col ! cursor-row @ my-chars-height = if scroll-ssd1306-text then render-ssd1306-text ;] my-lock with-lock ; 
 : bs-ssd1306 inited? not if init-ssd1306-text then [: bs-ssd1306-cursor render-ssd1306-text ;] my-lock with-lock ; 
 : goto-ssd1306 inited? not if init-ssd1306-text then [: { col row } col 0 max my-chars-width min cursor-col ! row 0 max my-chars-height min cursor-row ! render-ssd1306-text ;] my-lock with-lock ; 
 : ssd1306-cursor@ [: cursor-col @ cursor-row @ ;] my-lock with-lock ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-sprite-width constant ; 
 : my-sprite-height constant ; 
 : run-test 14 15 my-buf my-width my-height SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object my-sprite-buf my-sprite-width my-sprite-height <bitmap> my-sprite init-object $FF 1 2 0 1 op-set my-sprite draw-rect-const $FF 0 4 1 2 op-set my-sprite draw-rect-const $FF 1 2 3 1 op-set my-sprite draw-rect-const 0 { counter } begin key? not while random my-width umod { start-col } random my-height umod { start-row } random my-width umod { end-col } random my-height umod { end-row } 0 0 4 4 start-col start-row end-col end-row op-or my-sprite my-ssd1306 draw-bitmap-line my-ssd1306 update-display 100 ms 1 +to counter counter 25 umod 0= if 0 to counter my-ssd1306 clear-bitmap then repeat key drop ; 
 : >s { x y -- } x c, y c, [char] * c, ; 
 : >l { x y -- } x c, y c, [char] _ c, ; 
 : >f { x y -- } x c, y c, [char] / c, ; 
 : >b { x y -- } x c, y c, $5C c, ; 
 : >d { x y -- } x y >b x 1+ y >f ; 
 : >u { x y -- } x y >f x 1+ y >b ; 
 : draw-snowflake here { start } 3 0 >s 10 0 >s 3 7 >s 10 7 >s 3 1 >l 10 1 >l 6 2 do 4 i >l 9 i >l loop 0 3 >l 2 3 >l 11 3 >l 13 3 >l 4 1 >d 8 1 >d 5 2 >d 7 2 >d 5 3 >d 7 3 >d 5 4 >u 7 4 >u 5 5 >u 7 5 >u 4 6 >u 8 6 >u 1 3 >b 3 3 >b 10 3 >f 12 3 >f 1 4 >f 3 4 >f 10 4 >b 12 4 >b $FF c, start begin dup c@ $FF <> while dup c@ over 1+ c@ goto-ssd1306 dup 2 + c@ emit-ssd1306 3 + repeat drop start ram-here! 0 0 goto-ssd1306 ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-char-width constant ; 
 : my-char-height constant ; 
 : my-flake-count constant ; 
 : free-flake-count variable ; 
 : x-no-flakes-available ." cr ; 
 : flake@ flake-size * my-flakes + ; 
 : init-snow 14 15 my-buf my-width my-height SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object init-simple-font true to inited? ; 
 : clear-snow my-flake-count free-flake-count ! my-flake-count 0 do false i flake@ flake-active ! loop my-ssd1306 clear-bitmap my-ssd1306 update-display ; 
 : free-flake? free-flake-count @ 0> ; 
 : new-flake? free-flake? if random 0 my-flake-chance d<= else false then ; 
 : find-free-flake free-flake-count @ 0> averts x-no-flakes-available -1 free-flake-count +! my-flake-count 0 do i flake@ flake-active @ not if unloop i exit then loop ; 
 : init-flake find-free-flake flake@ { flake } true flake flake-active ! random my-width my-char-width - umod flake flake-col ! 0 flake flake-row ! ; 
 : for-all-flakes { xt -- } my-flake-count 0 do i flake@ flake-active @ if i flake@ xt execute then loop ; 
 : draw-snow [: { flake } [char] * flake flake-col @ flake flake-row @ op-or my-ssd1306 a-simple-font draw-char ;] for-all-flakes my-ssd1306 update-display ; 
 : erase-snow [: { flake } [char] * flake flake-col @ flake flake-row @ op-bic my-ssd1306 a-simple-font draw-char ;] for-all-flakes ; 
 : free-snow [: { flake } flake flake-row @ my-height my-char-height 2 / - = if false flake flake-active ! 1 free-flake-count +! then ;] for-all-flakes ; 
 : snow-fall [: 1 swap flake-row +! ;] for-all-flakes ; 
 : draw-snow inited? not if init-snow then clear-snow begin key? not while draw-snow free-snow erase-snow snow-fall new-flake? if init-flake then 50 ms repeat key drop ; 
 : my-width constant ; 
 : my-height constant ; 
 : my-char-width constant ; 
 : my-char-height constant ; 
 : my-flake-count constant ; 
 : my-accumulate constant ; 
 : free-flake-count variable ; 
 : continue-run? variable ; 
 : x-no-flakes-available ." cr ; 
 : flake@ flake-size * my-flakes + ; 
 : flake-coord@ { flake -- x y } flake flake-x 2@ nip flake flake-y 2@ nip ; 
 : init-snow 14 15 my-buf my-width my-height SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object init-simple-font 320 128 512 1 my-task-pool init-task-pool true to inited? ; 
 : vary-wind random 0 my-max-wind-x-delta-vary my-min-wind-x-delta-vary d- f* my-min-wind-x-delta-vary d+ new-flake-x-delta 2@ d+ my-min-wind-x-delta dmax my-max-wind-x-delta dmin new-flake-x-delta 2@ d- ; 
 : clear-snow my-flake-count free-flake-count ! my-flake-count 0 do false i flake@ flake-active ! loop my-ssd1306 clear-bitmap my-ssd1306 update-display 0,0 new-flake-x-delta 2! vary-wind new-flake-x-delta 2+! 1,0 my-divider f/ new-flake-y-delta 2! ; 
 : free-flake? free-flake-count @ 0> ; 
 : new-flake? free-flake? if random 0 my-flake-chance d<= else false then ; 
 : find-free-flake free-flake-count @ 0> averts x-no-flakes-available -1 free-flake-count +! my-flake-count 0 do i flake@ flake-active @ not if unloop i exit then loop ; 
 : init-flake find-free-flake flake@ { flake } true flake flake-active ! random my-width 2 * umod my-width 2 / - 0 swap flake flake-x 2! 0,0 flake flake-y 2! random 0 my-max-flake-x-delta-vary my-min-flake-x-delta-vary d- f* my-min-flake-x-delta-vary d+ new-flake-x-delta 2@ d+ flake flake-x-delta 2! random 0 my-max-flake-y-delta-vary my-min-flake-y-delta-vary d- f* my-min-flake-y-delta-vary d+ new-flake-y-delta 2@ d+ flake flake-y-delta 2! ; 
 : for-all-flakes { xt -- } my-flake-count 0 do i flake@ flake-active @ if i flake@ xt execute then loop ; 
 : draw-snow [: { flake } [char] * flake flake-coord@ op-or my-ssd1306 a-simple-font draw-char ;] for-all-flakes my-ssd1306 update-display ; 
 : erase-snow [: { flake } [char] * flake flake-coord@ op-bic my-ssd1306 a-simple-font draw-char ;] for-all-flakes ; 
 : free-snow [: { flake } flake flake-y 2@ 0 my-height my-char-height 2 / - d>= if false flake flake-active ! 1 free-flake-count +! then ;] for-all-flakes ; 
 : snow-fall [: { flake } flake flake-x-delta 2@ flake flake-x 2+! flake flake-y-delta 2@ flake flake-y 2+! ;] for-all-flakes ; 
 : adjust-wind vary-wind 2dup new-flake-x-delta 2+! [: { flake } 2dup flake flake-x-delta 2+! ;] for-all-flakes 2drop ; 
 : draw-snow-w/-wind inited? not if init-snow then clear-snow systick-counter { start-systick } begin key? not while draw-snow my-accumulate if free-snow then erase-snow my-accumulate not if free-snow then snow-fall adjust-wind new-flake? if init-flake then my-delay start-systick current-task delay my-delay +to start-systick repeat clear-snow key drop ; 
 : run-snow-w/-wind inited? not if init-snow then clear-snow true continue-run? ! 0 [: systick-counter { start-systick } begin continue-run? @ while draw-snow my-accumulate if free-snow then erase-snow my-accumulate not if free-snow then snow-fall adjust-wind new-flake? if init-flake then my-delay start-systick current-task delay my-delay +to start-systick repeat clear-snow ;] my-task-pool spawn-from-task-pool run ; 
 : stop-snow-w/-wind false continue-run? ! ; 
 : run-test begin key case $0D of cr-ssd1306 cr false endof $7F of ssd1306-cursor@ 0<> swap 0<> or if bs-ssd1306 $20 emit-ssd1306 bs-ssd1306 $08 emit $20 emit $08 emit then false endof $1B of true endof dup emit-ssd1306 dup emit false swap endcase until ; 
 : my-cols constant ; 
 : my-rows constant ; 
 : init-test 14 15 my-buf my-cols my-rows SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object ; 
 : set-test { const start-col end-col start-row end-row -- } const start-col end-col over - start-row end-row over - op-set my-ssd1306 draw-rect-const my-ssd1306 update-display ; 
 : or-test { const start-col end-col start-row end-row -- } const start-col end-col over - start-row end-row over - op-or my-ssd1306 draw-rect-const my-ssd1306 update-display ; 
 : and-test { const start-col end-col start-row end-row -- } const start-col end-col over - start-row end-row over - op-and my-ssd1306 draw-rect-const my-ssd1306 update-display ; 
 : bic-test { const start-col end-col start-row end-row -- } const start-col end-col over - start-row end-row over - op-bic my-ssd1306 draw-rect-const my-ssd1306 update-display ; 
 : xor-test { const start-col end-col start-row end-row -- } const start-col end-col over - start-row end-row over - op-xor my-ssd1306 draw-rect-const my-ssd1306 update-display ; 
 : my-cols constant ; 
 : my-rows constant ; 
 : init-test 14 15 my-buf my-cols my-rows SSD1306_I2C_ADDR 1 <ssd1306> my-ssd1306 init-object init-simple-font ; 
 : draw-text { c-addr u col row -- } inited? not if init-test true to inited? then c-addr u col row op-set my-ssd1306 a-simple-font draw-string my-ssd1306 update-display ; 
 : bounce-text { c-addr u -- } inited? not if init-test true to inited? then 0 0 1 1 { column row delta-column delta-row } begin key? not while c-addr u column row op-xor my-ssd1306 a-simple-font draw-string my-ssd1306 update-display c-addr u column row op-xor my-ssd1306 a-simple-font draw-string column 7 u * + my-cols >= if -1 to delta-column else column 0 <= if 1 to delta-column then then row 8 + my-rows >= if -1 to delta-row else row 0 <= if 1 to delta-row then then delta-column +to column delta-row +to row 100 ms repeat key drop ; 
 : bounce-text-rotate dup [: { c-addr u copy-addr } c-addr copy-addr u move inited? not if init-test true to inited? then 0 0 1 1 0 { column row delta-column delta-row cycle } begin key? not while copy-addr u column row op-xor my-ssd1306 a-simple-font draw-string my-ssd1306 update-display copy-addr u column row op-xor my-ssd1306 a-simple-font draw-string column 7 u * + my-cols >= if -1 to delta-column else column 0 <= if 1 to delta-column then then row 8 + my-rows >= if -1 to delta-row else row 0 <= if 1 to delta-row then then delta-column +to column delta-row +to row 1 +to cycle cycle 10 umod 0= if copy-addr u + 1- c@ { last-c } copy-addr copy-addr 1+ u 1- move last-c copy-addr c! 0 to cycle then 100 ms repeat key drop ;] with-allot ; 
 : bounce-counter 10 [: { count buffer } inited? not if init-test true to inited? then 0 0 1 1 0 { column row delta-column delta-row cycle } begin key? not while count 0 <# #s #> { c-addr bytes } c-addr buffer bytes move buffer bytes column row op-xor my-ssd1306 a-simple-font draw-string my-ssd1306 update-display buffer bytes column row op-xor my-ssd1306 a-simple-font draw-string column 7 bytes * + my-cols >= if -1 to delta-column else column 0 <= if 1 to delta-column then then row 8 + my-rows >= if -1 to delta-row else row 0 <= if 1 to delta-row then then delta-column +to column delta-row +to row 1 +to cycle cycle 10 umod 0= if 1 +to count 0 to cycle then 100 ms repeat key drop ;] with-allot ; 
 : bounce-time 10 [: { buffer } inited? not if init-test true to inited? then 0 0 1 1 { column row delta-column delta-row } begin key? not while my-date-time rtc::date-time@ buffer { cur-buffer } my-date-time rtc::date-time-hour c@ s>d <# #s #> { c-addr bytes } bytes 2 < if [char] 0 cur-buffer c! 1 +to cur-buffer then c-addr cur-buffer bytes move bytes +to cur-buffer [char] : cur-buffer c! 1 +to cur-buffer my-date-time rtc::date-time-minute c@ s>d <# #s #> to bytes to c-addr bytes 2 < if [char] 0 cur-buffer c! 1 +to cur-buffer then c-addr cur-buffer bytes move bytes +to cur-buffer [char] : cur-buffer c! 1 +to cur-buffer my-date-time rtc::date-time-second c@ s>d <# #s #> to bytes to c-addr bytes 2 < if [char] 0 cur-buffer c! 1 +to cur-buffer then c-addr cur-buffer bytes move bytes +to cur-buffer buffer 8 column row op-xor my-ssd1306 a-simple-font draw-string my-ssd1306 update-display buffer 8 column row op-xor my-ssd1306 a-simple-font draw-string column 7 8 * + my-cols >= if -1 to delta-column else column 0 <= if 1 to delta-column then then row 8 + my-rows >= if -1 to delta-row else row 0 <= if 1 to delta-row then then delta-column +to column delta-row +to row 100 ms repeat key drop ;] with-allot ; 
 : init init 0 stack-fail-hook ! ; 
 : verify-marker constant ; 
 : verify-task variable ; 
 : init-stack-verify verify-schedule init-schedule verify-schedule 1 ['] run-schedule 256 128 512 spawn verify-task ! ; 
 : start-stack-verify verify-task @ run ; 
 : stop-stack-verify verify-task @ stop ; 
 : add-stack-verify dup ['] task-stack-end for-task@ verify-marker swap ! dup ['] task-rstack-end for-task@ verify-marker swap ! ram-here 4 align dup ram-here! >r action-size ram-allot ['] do-verify r@ init-action verify-schedule r> add-action ; 
 : stars-task variable ; 
 : stars begin ." 500000 0 ?do loop again ; 
 : init-stars 0 ['] stars 420 128 512 spawn stars-task ! ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream again ; 
 : consumer begin my-recv-count [: up my-recv-count my-stream recv-stream type ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] consumer 420 128 512 1 spawn-on-core consumer-task ! 0 ['] producer 420 128 512 spawn producer-task ! consumer-task @ run producer-task @ run ; 
 : inter-count constant ; 
 : end-count constant ; 
 : inter-recv-count constant ; 
 : end-recv-count constant ; 
 : end-interval constant ; 
 : producer-task variable ; 
 : inter-task variable ; 
 : consumer-task variable ; 
 : producer begin s" inter-stream send-stream again ; 
 : inter begin inter-recv-buf inter-recv-count inter-stream recv-stream inter-recv-buf swap end-stream send-stream again ; 
 : consumer end-interval 0 begin end-recv-buf end-recv-count end-stream recv-stream + 2dup <= if up . swap end-interval + swap then again ; 
 : init-test inter-count inter-stream init-stream end-count end-stream init-stream 0 ['] consumer 420 128 512 0 spawn-on-core consumer-task ! 0 ['] inter 420 128 512 1 spawn-on-core inter-task ! 0 ['] producer 420 128 512 0 spawn-on-core producer-task ! consumer-task @ run inter-task @ run producer-task @ run ; 
 : data-size constant ; 
 : stream-data [inlined] stream-size + ; 
 : x-stream-closed ." cr ; 
 : x-stream-data-too-big ." cr ; 
 : stream-full? dup stream-current-count @ swap stream-data-size @ = ; 
 : stream-empty? stream-current-count @ 0= ; 
 : stream-free dup stream-data-size @ swap stream-current-count @ - ; 
 : wait-send-stream { bytes stream -- } begin bytes stream stream-free > while stream stream-send-ready +! tream stream-send-tqueue ['] wait-tqueue try 1 stream stream-send-ready +! raise tream stream-closed @ triggers x-stream-closed repeat ; 
 : wait-send-stream-parts { stream -- } begin stream stream-full? while stream stream-send-ready +! tream stream-send-tqueue ['] wait-tqueue try 1 stream stream-send-ready +! raise tream stream-closed @ triggers x-stream-closed repeat ; 
 : wait-recv-stream { stream -- } begin stream stream-empty? while tream stream-closed @ triggers x-stream-closed stream stream-recv-ready +! tream stream-recv-tqueue ['] wait-tqueue try 1 stream stream-recv-ready +! raise repeat ; 
 : wait-recv-stream-min { min-bytes stream -- } begin min-bytes stream stream-current-count @ > while tream stream-closed @ triggers x-stream-closed stream stream-recv-ready +! tream stream-recv-tqueue ['] wait-tqueue try 1 stream stream-recv-ready +! raise repeat ; 
 : send-stream-addr dup stream-send-index @ stream-size + + ; 
 : recv-stream-addr dup stream-recv-index @ stream-size + + ; 
 : advance-send-stream 2dup stream-current-count +! dup stream-send-index @ rot + over stream-data-size @ umod swap stream-send-index ! ; 
 : advance-recv-stream 2dup swap negate swap stream-current-count +! dup stream-recv-index @ rot + over stream-data-size @ umod swap stream-recv-index ! ; 
 : write-stream { addr bytes stream -- } stream stream-send-index @ bytes + stream stream-data-size @ > if stream stream-data-size @ stream stream-send-index @ - { first-bytes } addr stream send-stream-addr first-bytes move addr first-bytes + stream stream-size + bytes first-bytes - move else addr stream send-stream-addr bytes move then ; 
 : read-stream { addr bytes stream -- } stream stream-recv-index @ bytes + stream stream-data-size @ > if stream stream-data-size @ stream stream-recv-index @ - { first-bytes } stream recv-stream-addr addr first-bytes move stream stream-size + addr first-bytes + bytes first-bytes - move else stream recv-stream-addr addr bytes move then ; 
 : init-stream dup stream-slock init-slock tuck stream-data-size ! 0 over stream-recv-index ! 0 over stream-send-index ! false over stream-closed ! 0 over stream-current-count ! 0 over stream-send-ready ! 0 over stream-recv-ready ! dup stream-slock over stream-send-tqueue init-tqueue dup stream-slock swap stream-recv-tqueue init-tqueue ; 
 : send-stream 2dup stream-data-size @ > triggers x-stream-data-too-big [: s" trace ;] over stream-slock with-slock ; 
 : send-stream-parts [: s" trace ;] over stream-slock with-slock ; 
 : recv-stream [: s" trace ;] over stream-slock with-slock ; 
 : recv-stream-min [: s" trace ;] over stream-slock with-slock ; 
 : peek-stream [: s" trace ;] over stream-slock with-slock ; 
 : peek-stream-min [: s" trace ;] over stream-slock with-slock ; 
 : skip-stream [: s" trace ;] over stream-slock with-slock ; 
 : skip-stream-min [: s" trace ;] over stream-slock with-slock ; 
 : send-stream-no-block [: s" trace ;] over stream-slock with-slock ; 
 : send-stream-partial-no-block [: s" trace ;] over stream-slock with-slock ; 
 : recv-stream-no-block [: s" trace ;] over stream-slock with-slock ; 
 : recv-stream-min-no-block [: s" trace ;] over stream-slock with-slock ; 
 : peek-stream-no-block [: s" trace ;] over stream-slock with-slock ; 
 : peek-stream-min-no-block [: s" trace ;] over stream-slock with-slock ; 
 : skip-stream-min-no-block [: s" trace ;] over stream-slock with-slock ; 
 : close-stream [: true over stream-closed ! dup stream-send-tqueue wake-tqueue-all stream-recv-tqueue wake-tqueue-all ;] over stream-slock with-slock ; 
 : stream-closed? stream-closed @ ; 
 : reopen-stream false swap stream-closed ! ; 
 : stream-size [inlined] stream-size + ; 
 : stream-data-size stream-data-size @ ; 
 : my-stream-size constant ; 
 : init-test my-stream-size my-stream init-stream 0 [: 0 { counter } begin my-buffer my-stream-size my-stream recv-stream { bytes-read } bytes-read 0 ?do my-buffer i + c@ { my-byte } my-byte counter <> if cr ." my-byte h.2 then my-byte 1+ $FF and to counter loop again ;] 320 128 512 spawn run 0 [: 0 { W^ counter } begin counter 1 my-stream send-stream counter c@ 1+ $FF and counter c! again ;] 320 128 512 spawn run ; 
 : my-stream-data-size constant ; 
 : recv-buf-size constant ; 
 : send-buf-size constant ; 
 : interval constant ; 
 : consumer interval 0 [: recv-buf recv-buf-size my-stream recv-stream + 2dup <= [: dup u. swap interval + swap ;] qif ;] qagain ; 
 : producer [: send-buf send-buf-size my-stream send-stream-parts ;] qagain ; 
 : init-test my-stream-data-size my-stream init-stream send-buf-size 0 [: dup send-buf + c! ;] qcount 0 ['] consumer 256 128 512 spawn run 0 ['] producer 256 128 512 spawn run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream 250 ms again ; 
 : consumer begin my-recv-count [: up my-recv-count my-recv-count my-stream peek-stream-min tuck type y-recv-count my-stream skip-stream-min drop ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream 250 ms again ; 
 : consumer begin my-recv-count [: up my-recv-count my-recv-count my-stream recv-stream-min-no-block type ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream 250 ms again ; 
 : consumer begin my-recv-count [: up my-recv-count my-recv-count my-stream peek-stream-min-no-block uck type up my-recv-count min my-stream skip-stream-min-no-block drop ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream-parts again ; 
 : consumer begin my-recv-count [: up my-recv-count my-stream recv-stream type ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream-partial-no-block drop again ; 
 : consumer begin my-recv-count [: up my-recv-count my-stream recv-stream type ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream again ; 
 : consumer begin my-recv-count [: up my-recv-count my-stream recv-stream-no-block type ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream again ; 
 : consumer begin my-recv-count [: up my-recv-count my-stream peek-stream tuck type y-stream skip-stream drop ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream again ; 
 : consumer begin my-recv-count [: up my-recv-count my-stream peek-stream-no-block tuck type y-stream skip-stream-no-block drop ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin [: s" my-stream send-stream-no-block ;] try dup ['] x-would-block = if drop 0 then ?raise again ; 
 : consumer begin my-recv-count [: up my-recv-count my-stream peek-stream-no-block tuck type y-stream skip-stream-no-block drop ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream 500 ms again ; 
 : consumer begin my-recv-count [: up my-recv-count my-stream recv-stream type ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream again ; 
 : consumer begin my-recv-count [: up my-recv-count my-stream recv-stream type 500 ms ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer begin s" my-stream send-stream 250 ms again ; 
 : consumer begin my-recv-count [: up my-recv-count my-recv-count my-stream recv-stream-min type ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-bytes constant ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer 5000 timeout ! begin s" my-stream send-stream-parts again ; 
 : consumer 0 begin my-recv-count [: up my-recv-count my-stream recv-stream type ;] with-allot dup ms 100 + again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer 0 begin s" my-stream send-stream dup ms 100 + again ; 
 : consumer 5000 timeout ! begin my-recv-count [: up my-recv-count my-stream recv-stream type ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer 0 begin s" my-stream send-stream-parts dup ms 100 + again ; 
 : consumer 5000 timeout ! begin my-recv-count [: up my-recv-count my-stream recv-stream type ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : my-min-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer 0 begin s" my-stream send-stream-parts dup ms 100 + again ; 
 : consumer 5000 timeout ! begin my-recv-count [: up my-recv-count my-min-recv-count my-stream recv-stream-min type ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer 0 begin s" my-stream send-stream-parts dup ms 100 + again ; 
 : consumer 5000 timeout ! begin my-recv-count [: up my-recv-count my-stream peek-stream tuck type y-stream skip-stream drop ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : my-min-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer 0 begin s" my-stream send-stream-parts dup ms 100 + again ; 
 : consumer 5000 timeout ! begin my-recv-count [: up my-recv-count my-min-recv-count my-stream peek-stream-min tuck type y-min-recv-count my-stream skip-stream-min drop ;] with-allot again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : my-count constant ; 
 : my-recv-count constant ; 
 : producer-task variable ; 
 : consumer-task variable ; 
 : producer 5000 timeout ! begin s" my-stream send-stream again ; 
 : consumer 0 begin my-recv-count [: up my-recv-count my-stream recv-stream type ;] with-allot dup ms 100 + again ; 
 : init-test my-count my-stream init-stream 0 ['] producer 420 128 512 spawn producer-task ! 0 ['] consumer 420 128 512 spawn consumer-task ! producer-task @ run consumer-task @ run ; 
 : c-inc 1 swap c+! [inlined] ; 
 : inc-rx-w swd-rx-w c-inc ; 
 : inc-rx-r swd-rx-r c-inc ; 
 : inc-tx-w swd-tx-w c-inc ; 
 : inc-tx-r swd-tx-r c-inc ; 
 : use-sleep variable ; 
 : pause-until use-sleep @ if ait else egin dup execute not while pause repeat rop then ; 
 : swd-key? serial-spinlock claim-spinlock disable-int swd h@ dup 8 rshift swap $ff and <> enable-int serial-spinlock release-spinlock ; 
 : swd-key serial-spinlock claim-spinlock [: swd-key? ;] pause-until disable-int swd-rx swd-rx-r c@ + c@ inc-rx-r enable-int serial-spinlock release-spinlock ; 
 : swd-emit? serial-spinlock claim-spinlock disable-int swd-tx-w h@ dup 8 rshift swap $ff and 1+ $ff and <> enable-int serial-spinlock release-spinlock ; 
 : swd-emit serial-spinlock claim-spinlock [: swd-emit? ;] pause-until disable-int swd-tx swd-tx-w c@ + c! inc-tx-w enable-int serial-spinlock release-spinlock ; 
 : swd-flush-console serial-spinlock claim-spinlock [: disable-int swd-tx-w h@ dup 8 rshift swap $FF and = enable-int ;] wait serial-spinlock release-spinlock ; 
 : >r11 [ $46b3 h, ] drop ; 
 : swd-init false use-sleep ! 0 swd ! swd >r11 ." swd h.8 cr ; 
 : swd-console ['] swd-key? key?-hook ! ['] swd-key key-hook ! ['] swd-emit? emit?-hook ! ['] swd-emit emit-hook ! ['] swd-emit? error-emit?-hook ! ['] swd-emit error-emit-hook ! ['] swd-flush-console flush-console-hook ! ['] swd-flush-console error-flush-console-hook ! ; 
 : enable-sleep true use-sleep ! ; 
 : disable-sleep false use-sleep ! ; 
 : with-swd-input ['] swd-key ['] swd-key? rot console::with-input ; 
 : with-swd-output ['] swd-emit ['] swd-emit? rot ['] swd-flush-console swap console::with-output ; 
 : with-swd-error-output ['] swd-emit ['] swd-emit? rot ['] swd-flush-console swap console::with-error-output ; 
 : c-inc 1 swap c+! [inlined] ; 
 : inc-rx-w swd-rx-w c-inc ; 
 : inc-rx-r swd-rx-r c-inc ; 
 : inc-tx-w swd-tx-w c-inc ; 
 : inc-tx-r swd-tx-r c-inc ; 
 : use-sleep variable ; 
 : pause-until use-sleep @ if ait else egin dup execute not while pause repeat rop then ; 
 : swd-key? serial-spinlock claim-spinlock disable-int swd h@ dup 8 rshift swap $ff and <> enable-int serial-spinlock release-spinlock ; 
 : swd-key serial-spinlock claim-spinlock [: swd-key? ;] pause-until disable-int swd-rx swd-rx-r c@ + c@ inc-rx-r enable-int serial-spinlock release-spinlock ; 
 : swd-emit? serial-spinlock claim-spinlock disable-int swd-tx-w h@ dup 8 rshift swap $ff and 1+ $ff and <> enable-int serial-spinlock release-spinlock ; 
 : swd-emit serial-spinlock claim-spinlock [: swd-emit? ;] pause-until disable-int swd-tx swd-tx-w c@ + c! inc-tx-w enable-int serial-spinlock release-spinlock ; 
 : swd-flush-console serial-spinlock claim-spinlock [: disable-int swd-tx-w h@ dup 8 rshift swap $FF and = enable-int ;] wait serial-spinlock release-spinlock ; 
 : >r11 [ $46b3 h, ] drop ; 
 : swd-init false use-sleep ! 0 swd ! swd >r11 ." swd h.8 cr ; 
 : swd-console ['] swd-key? key?-hook ! ['] swd-key key-hook ! ['] swd-emit? emit?-hook ! ['] swd-emit emit-hook ! ['] swd-emit? error-emit?-hook ! ['] swd-emit error-emit-hook ! ['] swd-flush-console flush-console-hook ! ; 
 : enable-sleep true use-sleep ! ; 
 : disable-sleep false use-sleep ! ; 
 : ICSR constant ; 
 : SYST_CSR constant ; 
 : SYST_RVR constant ; 
 : SYST_CVR constant ; 
 : SYST_CALIB constant ; 
 : SYST_CALIB_TENMS constant ; 
 : systick-counter variable ; 
 : systick-vector constant ; 
 : systick-handler SYST_CSR @ SYST_CSR_COUNTFLAG and if cpu-index 0= if systick-counter +! then wake then ; 
 : enable-systick SYST_CSR_TICKINT SYST_CSR_ENABLE or SYST_CSR bis! dmb dsb isb ; 
 : disable-systick SYST_CSR_TICKINT SYST_CSR_ENABLE or SYST_CSR bic! dmb dsb isb ; 
 : init-systick ['] systick-handler systick-vector vector! SYST_CALIB @ SYST_CALIB_TENMS and 10 / systick-divisor / time-multiplier * time-divisor / SYST_RVR ! 0 SYST_CVR ! 0 systick-counter ! enable-systick ; 
 : init-systick-aux-core SYST_CALIB @ SYST_CALIB_TENMS and 10 / systick-divisor / time-multiplier * time-divisor / SYST_RVR ! 0 SYST_CVR ! enable-systick ; 
 : systick-divisor systick-divisor ; 
 : systick-counter systick-counter @ ; 
 : test begin 1000 ms again ; 
 : exc space ." cr ; 
 : readied constant ; 
 : delayed constant ; 
 : blocked-timeout constant ; 
 : blocked-wait constant ; 
 : blocked-indefinite constant ; 
 : block-timed-out constant ; 
 : max-priority constant ; 
 : not-terminated constant ; 
 : terminated-normally constant ; 
 : terminated-killed constant ; 
 : terminated-crashed constant ; 
 : free-end variable ; 
 : default-timeslice constant ; 
 : default-min-timeslice constant ; 
 : cpu-active? cells cpu-active? + ; 
 : svcall-vector constant ; 
 : pendsv-vector constant ; 
 : terminated constant ; 
 : .task-rstack-size constant ; 
 : .task-stack-size constant ; 
 : .task-dict-size constant ; 
 : .task-rstack-current constant ; 
 : .task-dict-base constant ; 
 : .task-priority constant ; 
 : .task-active constant ; 
 : .task-state constant ; 
 : .task-saved-priority constant ; 
 : .task-prev constant ; 
 : .task-next constant ; 
 : .task-saved-systick-counter constant ; 
 : .task-ready-count constant ; 
 : .task-systick-start constant ; 
 : .task-systick-delay constant ; 
 : .task-timeslice constant ; 
 : .task-min-timeslice constant ; 
 : .timeout-systick-start constant ; 
 : .timeout-systick-delay constant ; 
 : .task-name constant ; 
 : .task-current-notify constant ; 
 : .task-notified-bitmap constant ; 
 : .task-notify-count constant ; 
 : .task-notify-area constant ; 
 : .spinlock-to-claim constant ; 
 : .task-core constant ; 
 : .task-wake-after constant ; 
 : .task-force-call constant ; 
 : .task-raise constant ; 
 : .task-terminate-hook constant ; 
 : .task-terminate-data constant ; 
 : .task-terminate-immed-reason constant ; 
 : .task-terminate-reason constant ; 
 : .pending-op-xt constant ; 
 : .pending-op-next constant ; 
 : .pending-op-priority constant ; 
 : core-init-hook variable ; 
 : current-lock-held user ; 
 : timeout user ; 
 : task-waited-for user ; 
 : no-timeout constant ; 
 : x-terminated ." cr ; 
 : x-would-block ." cr ; 
 : x-in-task-change ." cr ; 
 : x-out-of-range-priority ." cr ; 
 : x-timed-out ." cr ; 
 : x-out-of-range-notify ." cr ; 
 : x-current-wait-notify ." cr ; 
 : sleep sleep-enabled? @ if sleep then ; 
 : for-task code[ 1 r0 movs_,#_ r0 tos orrs_,_ tos blx_ ]code dict-base code[ cortex-m7? [if] 0 dp r0 ldr_,[_,#_] 4 dp r1 ldr_,[_,#_] 8 dp r2 ldr_,[_,#_] 12 dp adds_,#_ [else] r2 r1 r0 3 dp ldm [then] 0 tos tos ldr_,[_,#_] tos r0 r0 subs_,_,_ .task-dict-base r2 tos ldr_,[_,#_] r0 tos tos adds_,_,_ ]code ; 
 : for-task! code[ 1 r0 movs_,#_ r0 tos orrs_,_ tos blx_ ]code dict-base code[ cortex-m7? [if] 0 dp r0 ldr_,[_,#_] 4 dp r1 ldr_,[_,#_] 8 dp r2 ldr_,[_,#_] 12 dp r3 ldr_,[_,#_] 16 dp adds_,#_ [else] r3 r2 r1 r0 4 dp ldm [then] 0 tos tos ldr_,[_,#_] tos r0 r0 subs_,_,_ .task-dict-base r2 tos ldr_,[_,#_] r0 tos r3 str_,[_,_] tos 1 dp ldm ]code ; 
 : for-task@ code[ 1 r0 movs_,#_ r0 tos orrs_,_ tos blx_ ]code dict-base code[ cortex-m7? [if] 0 dp r0 ldr_,[_,#_] 4 dp r1 ldr_,[_,#_] 8 dp r2 ldr_,[_,#_] 12 dp adds_,#_ [else] r2 r1 r0 3 dp ldm [then] 0 tos tos ldr_,[_,#_] tos r0 r0 subs_,_,_ .task-dict-base r2 tos ldr_,[_,#_] r0 tos tos ldr_,[_,_] ]code ; 
 : pause-wo-reschedule disable-int false reschedule? ! pause enable-int ; 
 : pause-reschedule-last disable-int true reschedule-last? ! pause enable-int ; 
 : task-dict-end ; 
 : task-stack-current dup last-task @ = if drop sp@ else task-rstack-current @ 12 + @ then ; 
 : task-dict-current ['] task-ram-here for-task@ ; 
 : task-stack-current! dup last-task @ = if drop sp! else task-rstack-current @ 12 + ! then ; 
 : task-dict-current! ['] task-ram-here for-task! ; 
 : push-task-stack dup task-rstack-current @ 8 + @ over dup task-stack-current cell - tuck swap task-stack-current! ! task-rstack-current @ 8 + ! ; 
 : push-task-rstack dup task-rstack-current @ cell - tuck swap task-rstack-current ! ; 
 : task-priority@ task-priority h@ 16 lshift 16 arshift ; 
 : validate-not-terminated task-active h@ terminated = triggers x-terminated ; 
 : validate-notify task-notify-count @ u< averts x-out-of-range-notify ; 
 : find-higher-priority code[ .task-priority tos r0 ldrh_,[_,#_] 16 r0 r0 lsls_,_,#_ 16 r0 r0 asrs_,_,#_ r0 1 push .task-core tos tos ldr_,[_,#_] ]code cpu-last-task code[ 0 tos tos ldr_,[_,#_] mark> 0 tos cmp_,#_ ne bc> pc r0 2 pop >mark 0 r0 ldr_,[sp,#_] .task-priority tos r1 ldrh_,[_,#_] 16 r1 r1 lsls_,_,#_ 16 r1 r1 asrs_,_,#_ r0 r1 cmp_,_ lt bc> pc r0 2 pop >mark .task-next tos tos ldr_,[_,#_] b< ]code ; 
 : insert-task-before code[ .task-prev tos r0 ldr_,[_,#_] 0 r0 cmp_,#_ eq bc> 0 dp r1 ldr_,[_,#_] .task-next r0 r1 str_,[_,#_] .task-prev r1 r0 str_,[_,#_] b> 2swap >mark 0 dp r1 ldr_,[_,#_] 0 r2 movs_,#_ .task-prev r1 r2 str_,[_,#_] tos 1 push .task-core r1 tos ldr_,[_,#_] ]code cpu-last-task code[ 0 dp r1 ldr_,[_,#_] 0 tos r1 str_,[_,#_] tos 1 pop >mark .task-prev tos r1 str_,[_,#_] .task-next r1 tos str_,[_,#_] cortex-m7? [if] 0 dp r0 ldr_,[_,#_] 4 dp tos ldr_,[_,#_] 8 dp adds_,#_ [else] tos r0 2 dp ldm [then] ]code ; 
 : insert-task-first code[ tos 1 push .task-core tos tos ldr_,[_,#_] tos 1 push ]code cpu-first-task code[ 0 tos tos ldr_,[_,#_] 0 tos cmp_,#_ eq bc> 4 r0 ldr_,[sp,#_] .task-next tos r0 str_,[_,#_] .task-prev r0 tos str_,[_,#_] b> 2swap >mark 0 tos ldr_,[sp,#_] ]code cpu-last-task code[ 4 r0 ldr_,[sp,#_] 0 tos r0 str_,[_,#_] >mark tos 1 pop ]code cpu-first-task code[ r0 1 pop 0 tos r0 str_,[_,#_] 0 tos movs_,#_ .task-next r0 tos str_,[_,#_] tos 1 dp ldm ]code ; 
 : insert-task dup find-higher-priority ?dup if nsert-task-before else nsert-task-first then ; 
 : insert-task-last last-task @ ?dup if insert-task-before else insert-task-first then ; 
 : remove-task [ 0 cpu-last-task ] literal [ 0 cpu-first-task ] literal code[ r4 1 push tos r2 movs_,_ cortex-m7? [if] 0 dp r3 ldr_,[_,#_] 4 dp tos ldr_,[_,#_] 8 dp adds_,#_ [else] tos r3 2 dp ldm [then] .task-prev tos r0 ldr_,[_,#_] .task-next tos r1 ldr_,[_,#_] 0 r1 cmp_,#_ eq bc> .task-prev r1 r0 str_,[_,#_] b> 2swap >mark .task-core tos r4 ldr_,[_,#_] 2 r4 r4 lsls_,_,#_ r4 r2 r0 str_,[_,_] >mark 0 r0 cmp_,#_ eq bc> .task-next r0 r1 str_,[_,#_] b> 2swap >mark .task-core tos r4 ldr_,[_,#_] 2 r4 r4 lsls_,_,#_ r4 r3 r1 str_,[_,_] >mark 0 r0 movs_,#_ .task-prev tos r0 str_,[_,#_] .task-next tos r0 str_,[_,#_] tos 1 dp ldm pc r4 2 pop ]code ; 
 : test-remove-task dup task-prev @ 0<> over task-next @ 0<> or if remove-task else drop then ; 
 : start-validate-task-change ?raise then ; 
 : task-terminate-reason! 2dup task-terminate-immed-reason ! dup task-terminate-reason @ terminated-crashed u< if dup task-terminate-reason @ terminated-killed = 2 pick terminated-killed < and not if task-terminate-reason ! else 2drop then else 2drop then ; 
 : terminate [: dup task-active h@ terminated <> over current-task @ = or if tuck task-terminate-reason! terminated over task-active h! max-priority over task-priority h! dup current-task @ = if task-core @ release-other-core-spinlock end-critical begin pause again else drop then else 2drop then ;] over task-core @ critical-with-other-core-spinlock ; 
 : timed-out? dup validate-not-terminated task-state h@ block-timed-out = ; 
 : check-timeout [: dup validate-not-terminated dup task-state h@ block-timed-out = if readied swap task-state h! true else drop false then ;] over task-core @ critical-with-other-core-spinlock ; 
 : validate-timeout check-timeout triggers x-timed-out ; 
 : task-active@ task-active h@ 16 lshift 16 arshift ; 
 : task-saved-priority@ task-saved-priority h@ 16 lshift 16 arshift ; 
 : task-core@ task-core @ ; 
 : task-priority! over -32768 < triggers x-out-of-range-priority over 32767 > triggers x-out-of-range-priority task-priority h! ; 
 : task-saved-priority! over -32768 < triggers x-out-of-range-priority over 32767 > triggers x-out-of-range-priority task-saved-priority h! ; 
 : task-timeslice! disable-int dup validate-not-terminated dup current-task @ = if 2dup task-timeslice @ - task-systick-counter @ + task-systick-counter ! then swap 0 max swap task-timeslice ! enable-int ; 
 : task-timeslice@ dup validate-not-terminated task-timeslice @ ; 
 : task-min-timeslice! dup validate-not-terminated task-min-timeslice ! ; 
 : task-min-timeslice@ dup validate-not-terminated task-min-timeslice @ ; 
 : task-name@ dup validate-not-terminated task-name @ ; 
 : task-name! dup validate-not-terminated task-name ! ; 
 : task-terminate-hook! task-terminate-hook ! ; 
 : task-terminate-hook@ task-terminate-hook @ ; 
 : task-terminate-data! task-terminate-data ! ; 
 : task-terminate-data@ task-terminate-data @ ; 
 : task-terminate-immed-reason@ task-terminate-immed-reason @ ; 
 : task-terminate-reason@ task-terminate-reason @ ; 
 : run [: dup start-validate-task-change dup task-active@ 1+ dup 1 = if over test-remove-task over insert-task then swap task-active h! ;] over task-core @ critical-with-other-core-spinlock ; 
 : stop [: dup start-validate-task-change dup task-active@ 1- swap task-active h! ;] over task-core @ critical-with-other-core-spinlock ; 
 : kill terminated-killed swap terminate ; 
 : last-delay [: dup validate-not-terminated dup task-systick-delay @ swap task-systick-start @ ;] over task-core @ critical-with-other-core-spinlock ; 
 : delay [: dup validate-not-terminated tuck task-systick-start ! tuck task-systick-delay ! delayed over task-state h! ;] over task-core @ critical-with-other-core-spinlock current-task @ = if pause-wo-reschedule then ; 
 : block-timeout [: dup validate-not-terminated -1 over task-ready-count +! dup task-ready-count @ 0< if uck task-systick-start ! uck task-systick-delay ! locked-timeout over task-state h! else ip nip then ;] over task-core @ critical-with-other-core-spinlock current-task @ = if pause-wo-reschedule then ; 
 : wait-notify-timeout [: dup current-task @ validate-notify swap current-task @ task-systick-start ! swap current-task @ task-systick-delay ! begin dup bit current-task @ task-notified-bitmap bit@ not while up current-task @ task-current-notify ! blocked-timeout current-task @ task-state h! pu-index end-critical-with-other-core-spinlock pause-wo-reschedule cpu-index begin-critical-with-other-core-spinlock current-task @ check-timeout if -1 current-task @ task-current-notify ! ['] x-timed-out ?raise then repeat current-task @ task-notify-area @ over cells + @ swap bit current-task @ task-notified-bitmap bic! -1 current-task @ task-current-notify ! ;] cpu-index critical-with-other-core-spinlock ; 
 : block-wait dup validate-not-terminated tuck task-wake-after ! blocked-wait over task-state h! current-task @ = if pause-wo-reschedule then ; 
 : block-indefinite [: dup validate-not-terminated -1 over task-ready-count +! dup task-ready-count @ 0< if locked-indefinite over task-state h! then ;] over task-core @ critical-with-other-core-spinlock current-task @ = if pause-wo-reschedule then ; 
 : block-indefinite-self-release disable-int claim-all-core-spinlock-raw task-waited-for @ if -1 current-task @ task-ready-count ! blocked-indefinite current-task @ task-state h! false reschedule? ! pause then release-all-core-spinlock-raw enable-int ; 
 : compare-timeout dup ['] timeout for-task@ no-timeout <> if systick-counter over timeout-systick-start @ - swap timeout-systick-delay @ >= else drop false then ; 
 : wait-notify-indefinite [: dup current-task @ validate-notify begin dup bit current-task @ task-notified-bitmap bit@ not while dup current-task @ task-current-notify ! blocked-indefinite current-task @ task-state h! pu-index end-critical-with-other-core-spinlock pause-wo-reschedule cpu-index begin-critical-with-other-core-spinlock repeat current-task @ task-notify-area @ over cells + @ swap bit current-task @ task-notified-bitmap bic! -1 current-task @ task-current-notify ! ;] cpu-index critical-with-other-core-spinlock ; 
 : do-ready dup task-current-notify @ -1 = if 0 over task-ready-count ! 0>= if readied swap task-state h! else drop then else rop then ; 
 : ready [: dup validate-not-terminated do-ready ;] over task-core @ critical-with-other-core-spinlock ; 
 : notify [: dup validate-not-terminated 2dup validate-notify 2dup swap bit swap task-notified-bitmap bis! dup task-current-notify @ rot = if eadied swap task-state h! true else rop false then ;] over task-core @ critical-with-other-core-spinlock if pause-wo-reschedule then ; 
 : notify-set [: dup validate-not-terminated 2dup validate-notify dup task-notify-area @ 2 pick cells + >r rot r> ! 2dup swap bit swap task-notified-bitmap bis! dup task-current-notify @ rot = if eadied swap task-state h! true else rop false then ;] over task-core @ critical-with-other-core-spinlock if pause-wo-reschedule then ; 
 : notify-update r> r> 2dup swap bit swap task-notified-bitmap bis! dup task-current-notify @ rot = if readied swap task-state h! true else rop false then ;] over task-core @ critical-with-other-core-spinlock if pause-wo-reschedule then ; 
 : clear-notify [: dup validate-not-terminated 2dup validate-notify swap bit swap task-notified-bitmap bic! ;] over task-core @ critical-with-other-core-spinlock ; 
 : mailbox@ [: dup validate-not-terminated 2dup validate-notify task-notify-area @ swap cells + @ ;] over task-core @ critical-with-other-core-spinlock ; 
 : mailbox! [: dup validate-not-terminated 2dup validate-notify task-notify-area @ swap cells + ! ;] over task-core @ critical-with-other-core-spinlock ; 
 : block [: dup validate-not-terminated dup ['] timeout for-task@ no-timeout <> if up timeout-systick-delay @ ver timeout-systick-start @ ot block-timeout else lock-indefinite then ;] over task-core @ critical-with-other-core-spinlock ; 
 : wait-notify [: timeout @ no-timeout <> if current-task @ timeout-systick-delay @ current-task @ timeout-systick-start @ rot true else false then ;] cpu-index critical-with-other-core-spinlock if wait-notify-timeout else wait-notify-indefinite then ; 
 : prepare-block [: dup validate-not-terminated dup ['] timeout for-task@ no-timeout <> if ystick-counter over timeout-systick-start ! up ['] timeout for-task@ 0 max swap timeout-systick-delay ! else rop then ;] over task-core @ critical-with-other-core-spinlock ; 
 : terminated? task-active h@ terminated = ; 
 : wake-other-tasks cpu-count 0 do i cpu-first-task @ begin ?dup while dup ['] task-waited-for for-task@ current-task @ = if 0 over ['] task-waited-for for-task! dup task-state h@ blocked-indefinite = if dup do-ready then then task-prev @ epeat loop ; 
 : block-raw dup validate-not-terminated dup ['] timeout for-task@ no-timeout <> if up timeout-systick-delay @ ver timeout-systick-start @ ot -1 over task-ready-count +! up task-ready-count @ 0< if tuck task-systick-start ! tuck task-systick-delay ! blocked-timeout over task-state h! lse nip nip hen else 1 over task-ready-count +! up task-ready-count @ 0< if blocked-indefinite over task-state h! hen then current-task @ = if false reschedule? ! pause then ; 
 : init-main-task claim-all-core-spinlock free-end @ task-size - dict-base @ over task-dict-base ! rstack-base @ rstack-end @ - over task-rstack-size h! stack-base @ stack-end @ - over task-stack-size h! free-end @ task-size - next-ram-space - over task-dict-size ! rp@ over task-rstack-current ! 0 over task-priority h! 0 over task-saved-priority h! 1 over task-active h! readied over task-state h! no-timeout timeout ! 0 over task-ready-count ! 0 task-waited-for ! 0 over timeout-systick-start ! 0 over timeout-systick-delay ! 0 over task-systick-start ! -1 over task-systick-delay ! wake-counter @ over task-wake-after ! 0 over task-force-call ! 0 over task-raise ! 0 over task-terminate-hook ! 0 over task-terminate-data ! not-terminated over task-terminate-immed-reason ! not-terminated over task-terminate-reason ! cpu-index over task-core ! c" over task-name ! -1 over task-current-notify ! 0 over task-notified-bitmap ! 0 over task-notify-count ! 0 over task-notify-area ! default-timeslice over task-timeslice ! default-min-timeslice over task-min-timeslice ! default-timeslice over task-saved-systick-counter ! 0 current-lock-held ! 0 over task-next ! 0 over task-prev ! dup main-task ! dup first-task ! dup last-task ! dup prev-task ! current-task ! free-end @ task-size - free-end ! release-all-core-spinlock ; 
 : task-entry rdrop try-and-display-error dup 0= if drop terminated-normally then current-task @ terminate ; 
 : delayed? systick-counter over task-systick-start @ - swap task-systick-delay @ < ; 
 : init-aux-task-stack '] task-stack-base for-task@ wap >r >r FEDCBA98 r> cell - tuck ! >r egin dup 0<> while dup roll r> cell - tuck ! >r 1- epeat rop > r> swap cell - tuck ! ; 
 : init-aux-task wap dup dup task-dict-size @ - over task-dict-base ! swap ver task-core ! up task-rstack-size h@ over task-stack-size h@ + over + task-size + ver ['] task-rstack-base for-task! up task-stack-size h@ over + task-size + ver ['] task-rstack-end for-task! up ['] task-rstack-end for-task@ over ['] task-stack-base for-task! up task-size + over ['] task-stack-end for-task! over task-ready-count ! over ['] task-handler for-task! over ['] task-waited-for for-task! over task-priority h! over task-saved-priority h! over task-active h! ase @ over ['] task-base for-task! over ['] current-lock-held for-task! eadied over task-state h! o-timeout over ['] timeout for-task! over timeout-systick-start ! over timeout-systick-delay ! over task-systick-start ! over task-name ! 1 over task-current-notify ! over task-notified-bitmap ! over task-notify-count ! over task-notify-area ! -1 over task-systick-delay ! wake-counter @ over task-wake-after ! 0 over task-force-call ! 0 over task-raise ! 0 over task-terminate-hook ! 0 over task-terminate-data ! not-terminated over task-terminate-immed-reason ! not-terminated over task-terminate-reason ! " aux-main" over task-name ! efault-timeslice over task-timeslice ! efault-min-timeslice over task-min-timeslice ! efault-timeslice over task-saved-systick-counter ! up ['] task-rstack-base for-task@ over task-rstack-current ! ext-user-space over task-dict-base @ + ver ['] task-ram-here for-task! over task-next ! over task-prev ! up >r init-aux-task-stack > ['] task-rstack-base for-task@ ; 
 : init-context rot dup 7 and if 2 cells - $01000200 over ! else cell - $01000000 over ! then cell - swap over ! cell - $FFFFFFFE over ! cell - $DEADBEEF over ! cell - $DEADBEEF over ! cell - $DEADBEEF over ! cell - $DEADBEEF over ! cell - $DEADBEEF over ! cell - $DEADBEEF over ! cell - $DEADBEEF over ! cell - $DEADBEEF over ! cell - swap over ! cell - $FEDCBA98 over ! cell - $DEADBEEF over ! cell - $DEADBEEF over ! ; 
 : block-set [: dup validate-not-terminated dup ['] timeout for-task@ no-timeout <> if dup timeout-systick-delay @ over timeout-systick-start @ rot -1 over task-ready-count +! dup task-ready-count @ 0< if tuck task-systick-start ! tuck task-systick-delay ! blocked-timeout swap task-state h! else 2drop drop then else -1 over task-ready-count +! dup task-ready-count @ 0< if blocked-indefinite swap task-state h! else drop then then ! false reschedule? ! pause ;] over task-core @ critical-with-other-core-spinlock ; 
 : init-task swap dup dup task-dict-size @ - over task-dict-base ! swap over task-core ! dup task-rstack-size h@ over task-stack-size h@ + over + task-size + over ['] task-rstack-base for-task! dup task-stack-size h@ over + task-size + over ['] task-rstack-end for-task! dup ['] task-rstack-end for-task@ over ['] task-stack-base for-task! dup task-size + over ['] task-stack-end for-task! 0 over task-ready-count ! 0 over ['] task-handler for-task! 0 over ['] task-waited-for for-task! 0 over task-priority h! 0 over task-saved-priority h! 0 over task-active h! base @ over ['] task-base for-task! key-hook @ over ['] task-key-hook for-task! key?-hook @ over ['] task-key?-hook for-task! emit-hook @ over ['] task-emit-hook for-task! emit?-hook @ over ['] task-emit?-hook for-task! error-emit-hook @ over ['] error-emit-hook for-task! error-emit?-hook @ over ['] error-emit?-hook for-task! flush-console-hook @ over ['] flush-console-hook for-task! error-flush-console-hook @ over ['] error-flush-console-hook for-task! 0 over ['] current-lock-held for-task! readied over task-state h! no-timeout over ['] timeout for-task! 0 over timeout-systick-start ! 0 over timeout-systick-delay ! 0 over task-systick-start ! 0 over task-name ! -1 over task-current-notify ! 0 over task-notified-bitmap ! 0 over task-notify-count ! 0 over task-notify-area ! -1 over task-systick-delay ! wake-counter @ over task-wake-after ! 0 over task-force-call ! 0 over task-raise ! 0 over task-terminate-hook ! 0 over task-terminate-data ! not-terminated over task-terminate-immed-reason ! not-terminated over task-terminate-reason ! default-timeslice over task-timeslice ! default-min-timeslice over task-min-timeslice ! default-timeslice over task-saved-systick-counter ! dup ['] task-rstack-base for-task@ over ['] task-stack-base for-task@ ['] task-entry init-context over task-rstack-current ! next-user-space over task-dict-base @ + over ['] task-ram-here for-task! 0 over task-next ! 0 over task-prev ! swap >r >r begin dup 0<> while dup roll r@ push-task-stack 1- repeat drop r> r> swap push-task-stack ; 
 : task-allot [: 2dup 4 align swap 4 align + task-size + free-end @ swap - swap 4 align swap tuck task-rstack-size h! swap 4 align swap tuck task-stack-size h! swap 4 align swap tuck task-dict-size ! dup dup task-dict-size @ - free-end ! ;] critical-with-all-core-spinlock ; 
 : config-notify [: over 32 u<= averts x-out-of-range-notify 2dup task-current-notify @ > averts x-current-wait-notify 2dup swap $FFFFFFFF 32 rot - rshift over task-notified-bitmap @ and swap task-notified-bitmap ! 2dup task-notify-count ! 2 pick rot cells 0 fill task-notify-area ! ;] critical ; 
 : spawn task-allot dup >r cpu-index init-task r> ; 
 : waiting-task? eq bc> 0 tos movs_,#_ pc 1 pop >mark >mark ]code delayed? ; 
 : find-next-task first-task code[ 0 tos tos ldr_,[_,#_] mark> 0 tos cmp_,#_ ne bc> pc 1 pop >mark tos 1 push ]code waiting-task? code[ 0 tos cmp_,#_ ne bc> pc tos 2 pop >mark tos 1 pop .task-prev tos tos ldr_,[_,#_] b< ]code ; 
 : pendsv-return variable ; 
 : save-task-state task-systick-counter @ swap task-saved-systick-counter ! ; 
 : restore-task-state task-dict-base @ dict-base ! ; 
 : handle-task-terminated >r r@ task-terminate-hook @ ?dup if claim-same-core-spinlock r@ task-terminate-reason @ swap r@ task-name @ swap r@ task-terminate-data @ swap r@ task-terminate-immed-reason @ 2 rot r@ cpu-index init-task r@ task-name ! r@ task-terminate-reason ! max-priority r@ task-priority h! 1 r@ task-active h! r@ insert-task release-same-core-spinlock then rdrop ; 
 : do-extra-task begin wake-counter 1+ current-task @ block-wait again ; 
 : init-extra-task extra-task @ if 0 ['] do-extra-task extra-task @ cpu-index init-task else 0 ['] do-extra-task 320 128 512 spawn extra-task ! then claim-same-core-spinlock first-task @ 0= if c" extra-task @ task-name ! -1 extra-task @ task-priority h! 1 extra-task @ task-active h! extra-task @ insert-task then release-same-core-spinlock ; 
 : reschedule-task true in-task-change ! reschedule-last? @ if claim-same-core-spinlock dup remove-task dup task-active@ 0> if insert-task-last else dup terminated? if terminated-task ! else drop then then release-same-core-spinlock else reschedule? @ task-systick-counter @ 0<= or if claim-same-core-spinlock dup remove-task dup task-active@ 0> if insert-task else dup terminated? if terminated-task ! else drop then then release-same-core-spinlock else drop then then false reschedule-last? ! true reschedule? ! false in-task-change ! ; 
 : handle-pending-ops first-pending-op @ code[ r6 r0 movs_,_ r6 1 r7 ldm mark> 0 r0 cmp_,#_ ne bc> pc 1 pop >mark .pending-op-xt r0 r1 ldr_,[_,#_] 0 r2 movs_,#_ .pending-op-xt r0 r2 str_,[_,#_] .pending-op-next r0 r0 ldr_,[_,#_] 0 r1 cmp_,#_ 2dup eq bc< 1 r1 adds_,#_ r0 1 push r1 blx_ r0 1 pop b< ]code ; 
 : switch-tasks r> pendsv-return ! in-critical @ 0= in-task-change @ 0= and if handle-pending-ops do-pause? @ if 1 pause-count +! current-task @ dup prev-task ! ?dup if dup save-task-state reschedule-task then begin true in-task-change ! begin first-task @ 0= if init-extra-task then claim-same-core-spinlock find-next-task dup 0<> if dup task-ready-count @ 0 max over task-ready-count ! then release-same-core-spinlock dup 0<> if dup task-active@ 1 < if claim-same-core-spinlock remove-task release-same-core-spinlock false else dup task-state h@ dup blocked-timeout = swap block-timed-out = or if block-timed-out over task-state h! else readied over task-state h! then true then else true then until dup current-task ! false in-task-change ! 0<> if true else sleep false then until prev-task @ current-task @ <> if disable-int current-task @ task-rstack-current @ context-switch prev-task @ if prev-task @ task-rstack-current ! else drop then current-task @ restore-task-state enable-int then current-task @ task-saved-systick-counter @ 0<= if current-task @ task-saved-systick-counter @ current-task @ task-timeslice @ + current-task @ task-min-timeslice @ max task-systick-counter ! else current-task @ task-saved-systick-counter @ task-systick-counter ! then terminated-task @ if terminated-task @ handle-task-terminated 0 terminated-task ! then false do-pause? ! then else rue deferred-context-switch ! then pendsv-return @ >r current-task @ task-force-call @ ?dup if claim-same-core-spinlock code[ $18 4 + tos str_,[sp,#_] tos 1 dp ldm ]code 0 current-task @ task-force-call ! release-same-core-spinlock then false in-multitasker? ! ; 
 : task-systick-handler systick-handler -1 task-systick-counter +! task-systick-counter @ 0 <= if ause then ; 
 : do-pause true do-pause? ! true in-multitasker? ! ICSR_PENDSVSET! dmb dsb isb ; 
 : dump-task-name task-name@ ?dup if count tuck type 16 swap - 0 max else 16 then spaces ; 
 : dump-task-state dup current-task @ = if " running" else up task-current-notify @ -1 <> if s" endof endcase hen then tuck type 11 swap - spaces drop ; 
 : dump-task-priority task-priority@ here swap format-integer dup 8 swap - spaces type ; 
 : dump-task-until dup task-state h@ case elayed of true endof locked-timeout of true endof alse swap endcase if ast-delay + dup here swap format-unsigned up 10 swap - spaces type space ystick-counter - here swap format-integer dup 11 swap - spaces type else rop 22 spaces then ; 
 : dump-task-header cr ." ; 
 : dump-tasks dump-task-header cpu-count 0 ?do cpu-count 1 > if cr ." then i [: cpu-first-task @ begin ?dup while dup cr dup h.8 space dup dump-task-name space dup dump-task-priority space dup dump-task-state space dump-task-until task-prev @ repeat ;] i critical-with-other-core-spinlock loop ; 
 : trace trace-enabled? @ if [: r type space ." in-critical @ 1- . .s dump-tasks ;] critical else 2drop then ; 
 : ms1 systick-divisor * systick-counter current-task @ delay ; 
 : do-wait pause-enabled @ 0> if current-task @ block-wait else drop then ; 
 : ram-dict-warned variable ; 
 : saved-validate-dict variable ; 
 : actual-here dup current-task @ = if drop ram-here else task-dict-current then ; 
 : do-validate-dict main-task @ task-dict-end main-task @ actual-here - 1024 < ram-dict-warned @ not and if true ram-dict-warned ! [: display-red ." cr display-normal ;] with-error-console then saved-validate-dict @ ?execute ; 
 : init-aux-main-task fifo-drain ait-current-core NVIC_ICPR_CLRPEND_All! current-task @ task-dict-base @ dict-base ! 7F SHPR3_PRI_15! FF SHPR2_PRI_11! FF SHPR3_PRI_14! 00 SIO_IRQ_PROC1 NVIC_IPR_IP! IO_IRQ_PROC1 NVIC_ISER_SETENA! pause-enabled ! core-init-hook @ execute true core-1-launched ! pause try-and-display-error dup 0= if drop terminated-normally then current-task @ terminate ; 
 : x-main-already-launched ." cr ; 
 : x-core-can-only-be-launched-from-core-0 ." cr ; 
 : spawn-aux-main [ cpu-count 1 > ] [if] pu-index 0= averts x-core-can-only-be-launched-from-core-0 dup 1 = averts x-core-out-of-range [: dup cpu-active? @ if ['] x-main-already-launched ?raise else true over cpu-active? ! then >r task-allot >r 2r@ cpu-current-task ! 2r@ cpu-main-task ! 2r@ cpu-prev-task ! 2r@ cpu-first-task ! 2r@ cpu-last-task ! 2r@ init-aux-task ['] init-aux-main-task -rot 2r> swap >r disable-int launch-aux-core r> begin core-1-launched @ until enable-int ;] critical [else] '] x-core-out-of-range ?raise [then] ; 
 : spawn-on-core [ cpu-count 1 > ] [if] dup cpu-count < over 0 >= and averts x-core-out-of-range dup cpu-active? @ if r task-allot r> over >r init-task r> else pawn-aux-main then [else] 0= averts x-core-out-of-range spawn [then] ; 
 : current-task current-task @ ; 
 : main-task 0 cpu-main-task @ ; 
 : exclude-multitasker disable-int in-multitasker? @ dup not if >r execute r> else nip then enable-int ; 
 : force-call task-force-call ! ; 
 : signal over 0<> if disable-int tuck task-raise ! [: current-task task-raise @ 0 current-task task-raise ! ?raise ;] over force-call readied swap task-state h! enable-int else 2drop then ; 
 : saved-attention-hook variable ; 
 : x-interrupt-main ." cr ; 
 : do-attention dup [char] z = if drop false attention? ! ['] x-interrupt-main main-task signal else saved-attention-hook @ execute then ; 
 : init-tasker init-systick-aux-core ;] core-init-hook ! cpu-count 0 ?do false i cpu-in-multitasker? ! false i cpu-sleep-enabled? ! false i cpu-trace-enabled? ! false i cpu-in-task-change ! false i cpu-do-pause? ! true i cpu-reschedule? ! false i cpu-reschedule-last? ! 0 i cpu-task-systick-counter ! 0 i cpu-terminated-task ! 0 i cpu-extra-task ! 0 i cpu-first-pending-op ! i 0= if rue i cpu-active? ! nit-main-task else alse i cpu-active? ! i cpu-main-task ! i cpu-current-task ! i cpu-prev-task ! i cpu-first-task ! 0 i cpu-last-task ! then 0 i cpu-pause-count ! loop ['] execute svcall-vector vector! ['] switch-tasks pendsv-vector vector! ['] task-systick-handler systick-vector vector! [: cpu-index 0= current-task main-task = and ;] in-main?-hook ! [: terminated-crashed current-task terminate ;] crash-hook ! [: 0 cpu-main-task @ task-dict-current ;] main-here-hook ! 1 pause-enabled ! enable-int ; 
 : task-unused cr ." dup task-rstack-current @ swap ['] task-rstack-end for-task@ - 0 <# #s #> type ; 
 : unused cr 0 cpu-main-task @ ." dup task-rstack-current @ swap ['] task-rstack-end for-task@ - 0 <# #s #> type ; 
 : force-pending-ops true in-multitasker? ! ICSR_PENDSVSET! dmb dsb isb ; 
 : register-pending-op [: { priority pending-op } priority pending-op pending-op-priority ! 0 pending-op pending-op-xt ! first-pending-op @ if priority first-pending-op @ pending-op-priority @ > if first-pending-op @ pending-op pending-op-next ! pending-op first-pending-op ! else first-pending-op @ begin dup pending-op-next @ ?dup if priority over pending-op-priority @ > if pending-op pending-op-next ! pending-op swap pending-op-next ! true else nip false then else 0 pending-op pending-op-next ! pending-op swap pending-op-next ! true then until then else pending-op first-pending-op ! 0 pending-op pending-op-next ! then ;] critical ; 
 : set-pending-op pending-op-xt ! ; 
 : pause-count pause-count @ ; 
 : enable-sleep true sleep-enabled? ! ; 
 : disable-sleep false sleep-enabled? ! ; 
 : sleep-enabled? sleep-enabled? @ ; 
 : enable-trace true trace-enabled? ! ; 
 : disable-trace false trace-enabled? ! ; 
 : trace-enable? trace-enabled? @ ; 
 : allot-end [: negate free-end +! free-end @ ;] critical-with-all-core-spinlock ; 
 : x-no-task-available ." cr ; 
 : task@ task-pool-size + swap cells + @ ; 
 : spawn-from-task-pool begin-critical dup task-pool-count @ 0 ?do i over task@ terminated? if swap task@ dup >r cpu-index init-task r> end-critical unloop exit then loop end-critical ['] x-no-task-available ?raise ; 
 : task-pool-free begin-critical 0 swap dup task-pool-count @ 0 ?do i over task@ terminated? if swap 1+ swap then loop drop end-critical ; 
 : init-task-pool tuck task-pool-count ! tuck swap 4 align swap task-pool-rstack-size h! tuck swap 4 align swap task-pool-stack-size h! tuck swap 4 align swap task-pool-dict-size ! dup task-pool-count @ 0 ?do 0 [: ;] 2 pick dup task-pool-dict-size @ swap dup task-pool-stack-size h@ swap task-pool-rstack-size h@ spawn dup kill over task-pool-size + i cells + ! loop drop ; 
 : task-pool-size cells task-pool-size + ; 
 : x-data-too-big ." cr ; 
 : init-temp tuck temp-data-size ! 0 swap temp-index ! ; 
 : allocate-temp 2dup temp-data-size @ > triggers x-data-too-big 2dup dup temp-data-size @ swap temp-index @ - > if 0 over temp-index ! then dup temp-index @ over + temp-size + -rot temp-index +! ; 
 : temp-size [inlined] temp-size + ; 
 : temp-str-size constant ; 
 : c" parse-to-char dup 1+ temp-str ['] allocate-temp critical 2dup c! rot over 1+ 3 roll move swap if ompile-to-flash then then ; 
 : s" parse-to-char dup temp-str ['] allocate-temp critical rot over 3 pick move swap rot if ompile-to-flash then then ; 
 : ." parse-to-char type then ; 
 : c\" [immediate] state @ if postpone c\" else [: dvance-once ere [char] " parse-esc-string ere over - dup 1+ temp-str ['] allocate-temp critical dup c! pick over 1+ 3 roll move wap ram-here! advance-bytes ;] with-ram then ; 
 : s\" [immediate] state @ if postpone s\" else [: dvance-once ere [char] " parse-esc-string ere over - dup temp-str ['] allocate-temp critical pick over 3 pick move ot ram-here! swap advance-bytes ;] with-ram then ; 
 : .\" [immediate] state @ if postpone .\" else advance-once here [char] " parse-esc-string dup dup here swap - type ram-here! 1 advance-bytes then ; 
 : init init temp-str-size temp-str init-temp ; 
 : x-out-of-range-alarm ." cr ; 
 : timer-count constant ; 
 : TIMER_Base constant ; 
 : ALARM cells TIMER_Base $10 + + ; 
 : validate-alarm timer-count u< averts x-out-of-range-alarm ; 
 : timer-irq 0 + ; 
 : timer-vector timer-irq 16 + ; 
 : init-timer disable-int [: 0 bit INTR ! 0 timer-irq NVIC_ICPR_CLRPEND! ;] 0 timer-vector vector! [: 1 bit INTR ! 1 timer-irq NVIC_ICPR_CLRPEND! ;] 1 timer-vector vector! [: 2 bit INTR ! 2 timer-irq NVIC_ICPR_CLRPEND! ;] 2 timer-vector vector! [: 3 bit INTR ! 3 timer-irq NVIC_ICPR_CLRPEND! ;] 3 timer-vector vector! timer-count 0 ?do 0 i timer-irq NVIC_IPR_IP! i timer-irq NVIC_ISER_SETENA! i bit INTE bis! loop enable-int ; 
 : us-counter-lsb TIMERAWL @ ; 
 : us-counter begin TIMERAWL @ TIMERAWH @ TIMERAWL @ rot over u<= until swap ; 
 : us-counter! { lo hi -- } lo TIMELW ! hi TIMEHW ! ; 
 : pause-us 0 bit TIME_PAUSE bis! ; 
 : unpause-us 0 bit TIME_PAUSE bic! ; 
 : delay-until-us begin 2dup us-counter du<= until 2drop ; 
 : delay-us us-counter d+ delay-until-us ; 
 : set-alarm { us xt index -- } index validate-alarm index bit ARMED ! xt index timer-vector vector! us index ALARM ! ; 
 : clear-alarm { index -- } index validate-alarm index bit ARMED ! index bit INTR bic! ; 
 : clear-alarm-int { index -- } index validate-alarm index bit INTR ! index timer-irq NVIC_ICPR_CLRPEND! ; 
 : blink-interval constant ; 
 : blinky 0 [: begin green toggle-led blink-interval s>d delay-us again ;] 320 128 512 spawn run ; 
 : next-alarm variable ; 
 : alarm-blinky us-counter-lsb blink-interval + next-alarm ! next-alarm @ ['] handle-alarm 0 set-alarm ; 
 : tinymt32-mexp constant ; 
 : tinymt32-sh0 constant ; 
 : tinymt32-sh1 constant ; 
 : tinymt32-sh8 constant ; 
 : tinymt32-mask constant ; 
 : tinymt32-get-mexp drop tinymt32-mexp ; 
 : tinymt32-next-state ; 
 : tinymt32-temper then ; 
 : min-loop constant ; 
 : pre-loop constant ; 
 : period-certification 0 cells r@ tinymt32-status + @ tinymt32-mask and 0= 1 cells r@ tinymt32-status + @ 0= and 2 cells r@ tinymt32-status + @ 0= and 3 cells r@ tinymt32-status + @ 0= and if char] T 0 cells r@ tinymt32-status + ! char] I 1 cells r@ tinymt32-status + ! char] N 2 cells r@ tinymt32-status + ! char] Y 3 cells r> tinymt32-status + ! else drop then ; 
 : tinymt32-init ; 
 : tinymt32-prepare ; 
 : tinymt32-prepare-example >r $8F7011EE $FC78FF1F $3793FDFF r> tinymt32-prepare ; 
 : tinymt32-generate-uint32 dup tinymt32-next-state tinymt32-temper ; 
 : find-wait-queue-prev { priority queue -- wait|0 } queue tqueue-last @ { current } begin current while current wait-task @ task-priority@ priority < if current wait-prev @ to current else current exit then repeat 0 ; 
 : push-wait-queue { wait queue -- } false wait wait-popped ! wait wait-task @ task-priority@ queue find-wait-queue-prev { prev-wait } prev-wait 0= if 0 wait wait-prev ! queue tqueue-first @ { first-wait } first-wait if wait first-wait wait-prev ! else wait queue tqueue-last ! then first-wait wait wait-next ! wait queue tqueue-first ! else prev-wait wait-next @ { next-wait } next-wait wait wait-next ! next-wait if wait next-wait wait-prev ! else wait queue tqueue-last ! then wait prev-wait wait-next ! prev-wait wait wait-prev ! then ; 
 : pop-wait-queue { queue -- wait|0 } queue tqueue-first @ { first-wait } first-wait if true first-wait wait-popped ! first-wait wait-next @ { next-wait } next-wait if 0 next-wait wait-prev ! else 0 queue tqueue-last ! then next-wait queue tqueue-first ! first-wait else 0 then ; 
 : remove-wait-queue { wait queue -- } wait wait-popped @ not if true wait wait-popped ! wait wait-next @ wait wait-prev @ { next-wait prev-wait } next-wait if prev-wait next-wait wait-prev ! else prev-wait queue tqueue-last ! then prev-wait if next-wait prev-wait wait-next ! else next-wait queue tqueue-first ! then then ; 
 : +tqueue-counter dup tqueue-limit @ 0>= if dup tqueue-counter @ 1+ over tqueue-limit @ min swap tqueue-counter ! else 1 swap tqueue-counter +! then ; 
 : no-tqueue-limit constant ; 
 : init-tqueue tuck tqueue-slock ! 0 over tqueue-counter ! -1 over tqueue-limit ! 0 over tqueue-first ! 0 swap tqueue-last ! ; 
 : init-tqueue-full tuck tqueue-slock ! tuck tqueue-counter ! tuck tqueue-limit ! 0 over tqueue-first ! 0 swap tqueue-last ! ; 
 : wait-tqueue s" trace ; 
 : wake-tqueue s" trace ; 
 : unwake-tqueue dup tqueue-counter @ dup 0> if 1- 0 max swap tqueue-counter ! else 2drop then ; 
 : wake-tqueue-all begin dup tqueue-counter @ 0< while dup wake-tqueue repeat drop ; 
 : init-test 1 4 uart-pin 1 5 uart-pin 1 uart-baud! begin 1 uart>? if 1 uart> dup emit 1 >uart then key? until ; 
 : x-invalid-uart ." cr ; 
 : validate-uart 2 u< averts x-invalid-uart ; 
 : uart1-rx-read-index variable ; 
 : uart1-rx-write-index variable ; 
 : uart1-rx-buffer-size constant ; 
 : uart1-tx-read-index variable ; 
 : uart1-tx-write-index variable ; 
 : uart1-tx-buffer-size constant ; 
 : UART1_Base constant ; 
 : uart0-irq constant ; 
 : uart1-irq constant ; 
 : UART1_UARTDR_DATA! $FF and UART1_UARTDR c! ; 
 : UART1_UARTDR_DATA@ UART1_UARTDR c@ ; 
 : UART1_UARTFR_TXFE@ 7 bit UART1_UARTFR bit@ ; 
 : UART1_UARTFR_TXFF@ 5 bit UART1_UARTFR bit@ ; 
 : UART1_UARTFR_RXFE@ 4 bit UART1_UARTFR bit@ ; 
 : UART1_UARTIMSC_RTIM! 6 bit UART1_UARTIMSC bis! ; 
 : UART1_UARTIMSC_TXIM! 5 bit UART1_UARTIMSC bis! ; 
 : UART1_UARTIMSC_RXIM! 4 bit UART1_UARTIMSC bis! ; 
 : UART1_UARTIMSC_RTIM_Clear 6 bit UART1_UARTIMSC bic! ; 
 : UART1_UARTIMSC_TXIM_Clear 5 bit UART1_UARTIMSC bic! ; 
 : UART1_UARTIMSC_RXIM_Clear 4 bit UART1_UARTIMSC bic! ; 
 : UART1_UARTIFLS_RXIFLSEL! UART1_UARTIFLS @ $38 bic swap $7 and 3 lshift or UART1_UARTIFLS ! ; 
 : UART1_UARTIFLS_TXIFLSEL! UART1_UARTIFLS @ $07 bic swap $7 and or UART1_UARTIFLS ! ; 
 : uart1-rx-full? uart1-rx-write-index @ uart1-rx-read-index @ rx-buffer-size 1- + $FF and = ; 
 : uart1-rx-empty? uart1-rx-read-index @ uart1-rx-write-index @ = ; 
 : write-uart1-rx [: art1-rx-full? not if uart1-rx-write-index @ uart1-rx-buffer + c! uart1-rx-write-index @ 1+ $FF and uart1-rx-write-index ! lse drop hen ;] serial-spinlock critical-with-spinlock ; 
 : read-uart1-rx [: art1-rx-empty? not if uart1-rx-read-index @ uart1-rx-buffer + c@ uart1-rx-read-index @ 1+ $FF and uart1-rx-read-index ! lse 0 hen ;] serial-spinlock critical-with-spinlock ; 
 : uart1-tx-full? uart1-tx-write-index @ uart1-tx-read-index @ uart1-tx-buffer-size 1- + $FF and = ; 
 : uart1-tx-empty? uart1-tx-read-index @ uart1-tx-write-index @ = ; 
 : write-uart1-tx [: art1-tx-full? not if uart1-tx-write-index @ uart1-tx-buffer + c! uart1-tx-write-index @ 1+ $FF and uart1-tx-write-index ! lse drop hen ;] serial-spinlock critical-with-spinlock ; 
 : read-uart1-tx [: art1-tx-empty? not if uart1-tx-read-index @ uart1-tx-buffer + c@ uart1-tx-read-index @ 1+ $FF and uart1-tx-read-index ! lse 0 hen ;] serial-spinlock critical-with-spinlock ; 
 : handle-uart1-io begin art1-rx-full? not if UART1_UARTFR_RXFE@ not if UART1_UARTDR_DATA@ write-uart1-rx false else true then lse true hen until uart1-rx-full? if ART1_UARTIMSC_RTIM_Clear ART1_UARTIMSC_RXIM_Clear then begin art1-tx-empty? not if UART1_UARTFR_TXFF@ not if read-uart1-tx UART1_UARTDR_DATA! false else true then lse true hen until uart1-tx-empty? if ART1_UARTIMSC_TXIM_Clear then uart1-irq NVIC_ICPR_CLRPEND! wake ; 
 : enable-uart1-int-io disable-int 0 UART1_UARTIFLS_RXIFLSEL! 0 UART1_UARTIFLS_TXIFLSEL! 0 uart1-irq NVIC_IPR_IP! ['] handle-uart1-io uart1-vector vector! uart1-irq NVIC_ISER_SETENA! UART1_UARTIMSC_RTIM! UART1_UARTIMSC_RXIM! enable-int ; 
 : disable-uart1-int-io disable-int ['] handle-null uart1-vector vector! UART1_UARTIMSC_RTIM_Clear UART1_UARTIMSC_RXIM_Clear UART1_UARTIMSC_TXIM_Clear uart1-irq NVIC_ICER_CLRENA! enable-int ; 
 : uart-alternate validate-uart 2 ; 
 : uart-enabled? dup validate-uart 0 bit swap 0= if UART0_UARTCR else UART1_UARTCR then bit@ ; 
 : enable-uart dup validate-uart UART_8N1 UART_FIFO or over 0= if UART0_UARTLCR_H else UART1_UARTLCR_H then ! UART_ENABLE swap 0= if UART0_UARTCR else UART1_UARTCR then bis! ; 
 : disable-uart dup validate-uart UART_ENABLE swap 0= if UART0_UARTCR else UART1_UARTCR then bic! ; 
 : with-uart-disabled dup uart-enabled? 2dup if disable-uart else drop then 2>r try 2r> if enable-uart else drop then ?raise ; 
 : uart-baud! [: >r 0 swap 16,0 f* 125000000,0 2swap f/ r@ 0= if UART0_UARTIBRD else UART1_UARTIBRD then ! 0 64,0 f* 0,5 d+ nip r> 0= if UART0_UARTFBRD else UART1_UARTFBRD then ! ;] over with-uart-disabled ; 
 : init-uart1 0 uart1-rx-read-index ! 0 uart1-rx-write-index ! 0 uart1-tx-read-index ! 0 uart1-tx-write-index ! 115200 1 uart-baud! 1 enable-uart enable-uart1-int-io ; 
 : >uart dup validate-uart 0= if do-emit else UART1_UARTIMSC_TXIM! uart1-tx-empty? UART1_UARTFR_TXFF@ not and if ART1_UARTDR_DATA! else : uart1-tx-full? not ;] wait rite-uart1-tx then then ; 
 : uart> dup validate-uart 0= if do-key else UART1_UARTIMSC_RTIM! UART1_UARTIMSC_RXIM! [: uart1-rx-empty? not ;] wait read-uart1-rx then ; 
 : >uart? dup validate-uart 0= if do-emit? else uart1-tx-full? not then ; 
 : uart>? dup validate-uart 0= if do-key? else uart1-rx-empty? not then ; 
 : flush-uart dup validate-uart 0= if do-flush-console else [: uart1-tx-empty? UART1_UARTFR_TXFE@ and ;] wait then ; 
 : enable-uart-int-io dup validate-uart 0= if enable-int-io else enable-uart1-int-io then ; 
 : disable-uart-int-io dup validate-uart 0= if disable-int-io else disable-uart1-int-io then ; 
 : uart-pin swap uart-alternate swap alternate-pin ; 
 : init-console-uart-input { uart data -- } uart data console-uart ! data data console-io [: { data } data console-uart @ uart> ;] bind data data console-io? [: { data } data console-uart @ uart>? ;] bind ; 
 : init-console-uart-output { uart data -- } uart data console-uart ! data data console-io [: { byte data } byte data console-uart @ >uart ;] bind data data console-io? [: { data } data console-uart @ >uart? ;] bind data data console-io-flush [: { data } data console-uart @ flush-uart ;] bind ; 
 : with-uart-input over validate-uart console-uart-data-size [: { data } swap data init-console-uart-input data console-io data console-io? rot console::with-input ;] with-aligned-allot ; 
 : with-uart-output over validate-uart console-out-uart-data-size [: { data } swap data init-console-uart-output data console-io data console-io? rot data console-io-flush swap console::with-output ;] with-aligned-allot ; 
 : with-uart-error-output over validate-uart console-out-uart-data-size [: { data } swap data init-console-uart-output data console-io data console-io? rot data console-io-flush swap console::with-error-output ;] with-aligned-allot ; 
 : usb-special-enabled variable ; 
 : x-invalid-pkt-size ." cr ; 
 : rev [inlined] code[ tos tos rev_,_ ]code ; 
 : rev16 [inlined] code[ tos tos rev16_,_ ]code ; 
 : 2c, dup c, 8 rshift c, ; 
 : usbctrl-irq constant ; 
 : USB_Base constant ; 
 : RESETS_BASE constant ; 
 : reset-usb RESETS_USBCTRL RESETS_RESET_Set ! RESETS_USBCTRL RESETS_RESET_Clr ! begin RESETS_RESET_DONE @ not RESETS_USBCTRL and while repeat ; 
 : USB_INT_EP_CTRL_INT_EP_ACTIVE [inlined] bit ; 
 : USB_BUFF_STATUS_EP_IN [inlined] 1 lshift bit ; 
 : USB_BUFF_STATUS_EP_OUT [inlined] 1 lshift 1+ bit ; 
 : USB_DPRAM_Base constant ; 
 : USB_SETUP_PACKET constant ; 
 : USB_EP_IN_ENDPOINT_CONTROL 3 lshift USB_DPRAM_Base + ; 
 : USB_EP_OUT_ENDPOINT_CONTROL 3 lshift [ USB_DPRAM_Base cell+ ] literal + ; 
 : USB_EP_IN_BUFFER_CONTROL 3 lshift [ USB_DPRAM_Base $80 + ] literal + ; 
 : USB_EP_OUT_BUFFER_CONTROL 3 lshift [ USB_DPRAM_Base $80 + cell+ ] literal + ; 
 : USB_EP_ENDPOINT_TYPE_LSB constant ; 
 : USB_EP_ADDRESS_BASE_OFFSET_LSB constant ; 
 : USB_BUF_CTRL_DATA0_PID constant ; 
 : USB_BUF_CTRL_LEN constant ; 
 : USB_BUF_CTRL_LEN_MASK constant ; 
 : dpram-size constant ; 
 : USB_DT_DEVICE constant ; 
 : USB_DT_CONFIG constant ; 
 : USB_DT_STRING constant ; 
 : USB_DT_INTERFACE constant ; 
 : USB_DT_ENDPOINT constant ; 
 : USB_REQUEST_GET_STATUS constant ; 
 : USB_REQUEST_CLEAR_FEATURE constant ; 
 : USB_REQUEST_SET_FEATURE constant ; 
 : USB_REQUEST_SET_ADDRESS constant ; 
 : USB_REQUEST_GET_DESCRIPTOR constant ; 
 : USB_REQUEST_SET_DESCRIPTOR constant ; 
 : USB_REQUEST_GET_CONFIGURATION constant ; 
 : USB_REQUEST_SET_CONFIGURATION constant ; 
 : USB_REQUEST_GET_INTERFACE constant ; 
 : USB_REQUEST_SET_INTERFACE constant ; 
 : USB_REQUEST_SYNC_FRAME constant ; 
 : USB_REQUEST_SET_LINE constant ; 
 : USB_EP_TYPE_CONTROL constant ; 
 : USB_EP_TYPE_ISO constant ; 
 : USB_EP_TYPE_BULK constant ; 
 : USB_EP_TYPE_INTERRUPT constant ; 
 : USB_DIR_OUT constant ; 
 : USB_DIR_IN constant ; 
 : USB_EP_OUT_ADDR ; 
 : USB_EP_IN_ADDR 128 + ; 
 : usb-device-addr variable ; 
 : set-usb-device-addr variable ; 
 : usb-dtr? variable ; 
 : usb-device-configd? variable ; 
 : prepare-usb-device-configd? variable ; 
 : usb-handled-interrupts variable ; 
 : endpoint1-out-ready? variable ; 
 : endpoint1-in-ready? variable ; 
 : usb-rx-pending-op-enabled? variable ; 
 : usb-pending-op-priority constant ; 
 : ctrl-c constant ; 
 : ctrl-t constant ; 
 : rx-read-index variable ; 
 : rx-write-index variable ; 
 : rx-buffer-size constant ; 
 : tx-read-index variable ; 
 : tx-write-index variable ; 
 : tx-buffer-size constant ; 
 : rx-full? rx-read-index @ 1- $7F and rx-write-index @ = ; 
 : rx-empty? rx-read-index @ rx-write-index @ = ; 
 : rx-count rx-read-index @ { read-index } rx-write-index @ { write-index } read-index write-index <= if write-index read-index - else rx-buffer-size read-index - write-index + then ; 
 : write-rx rx-full? not if rx-write-index @ rx-buffer + c! rx-write-index @ 1+ $7F and rx-write-index ! else drop then ; 
 : read-rx rx-empty? not if rx-read-index @ rx-buffer + c@ rx-read-index @ 1+ $7F and rx-read-index ! else 0 then ; 
 : tx-full? tx-read-index @ 1- $7F and tx-write-index @ = ; 
 : tx-empty? tx-read-index @ tx-write-index @ = ; 
 : tx-count tx-read-index @ { read-index } tx-write-index @ { write-index } read-index write-index <= if write-index read-index - else tx-buffer-size read-index - write-index + then ; 
 : write-tx tx-full? not if tx-write-index @ tx-buffer + c! tx-write-index @ 1+ $7F and tx-write-index ! else drop then ; 
 : read-tx tx-empty? not if tx-read-index @ tx-buffer + c@ tx-read-index @ 1+ $7F and tx-read-index ! else 0 then ; 
 : usb-buffer-offset USB_DPRAM_Base - ; 
 : init-usb-endpoint0 { buffer-ctrl max-pkt-size tx? endpoint -- } 0 endpoint endpoint-endpoint-control ! buffer-ctrl endpoint endpoint-buffer-control ! 1 endpoint endpoint-next-pid ! max-pkt-size endpoint endpoint-max-packet-size ! 0 buffer-ctrl ! USB_EP0_BUFFER endpoint endpoint-buffer ! 0 endpoint endpoint-data-buffer ! 0 endpoint endpoint-data-len ! 0 endpoint endpoint-data-total-len ! tx? endpoint endpoint-tx? ! ; 
 : init-usb-console-endpoint { ep-ctrl buffer-ctrl data-buf max-pkt-size ep-type tx? endpoint -- } ep-ctrl endpoint endpoint-endpoint-control ! buffer-ctrl endpoint endpoint-buffer-control ! 0 endpoint endpoint-next-pid ! max-pkt-size endpoint endpoint-max-packet-size ! data-buf endpoint endpoint-buffer ! 0 buffer-ctrl ! [ USB_EP_ENABLE USB_EP_ENABLE_INTERRUPT_PER_BUFFER or ] literal ep-type USB_EP_ENDPOINT_TYPE_LSB lshift or data-buf usb-buffer-offset or ep-ctrl ! tx? endpoint endpoint-tx? ! ; 
 : init-usb-endpoint { ep-ctrl buffer-ctrl data-buf max-pkt-size ep-type tx? endpoint -- } ep-ctrl endpoint endpoint-endpoint-control ! buffer-ctrl endpoint endpoint-buffer-control ! 0 endpoint endpoint-next-pid ! max-pkt-size endpoint endpoint-max-packet-size ! data-buf endpoint endpoint-buffer ! 0 endpoint endpoint-data-buffer ! 0 endpoint endpoint-data-len ! 0 endpoint endpoint-data-total-len ! 0 buffer-ctrl ! [ USB_EP_ENABLE USB_EP_ENABLE_INTERRUPT_PER_BUFFER or ] literal ep-type USB_EP_ENDPOINT_TYPE_LSB lshift or data-buf usb-buffer-offset or ep-ctrl ! tx? endpoint endpoint-tx? ! ; 
 : init-usb-endpoints 0 USB_EP_IN_BUFFER_CONTROL 64 true endpoint0-in init-usb-endpoint0 0 USB_EP_OUT_BUFFER_CONTROL 8 false endpoint0-out init-usb-endpoint0 1 USB_EP_IN_ENDPOINT_CONTROL 1 USB_EP_IN_BUFFER_CONTROL USB_BUFFER_Base $00 + 64 USB_EP_TYPE_BULK true endpoint1-in init-usb-console-endpoint 1 USB_EP_OUT_ENDPOINT_CONTROL 1 USB_EP_OUT_BUFFER_CONTROL USB_BUFFER_Base $40 + 64 USB_EP_TYPE_BULK false endpoint1-out init-usb-console-endpoint 2 USB_EP_IN_ENDPOINT_CONTROL 2 USB_EP_IN_BUFFER_CONTROL USB_BUFFER_Base $80 + 8 USB_EP_TYPE_INTERRUPT true endpoint2-in init-usb-endpoint ; 
 : usb-console-count { endpoint -- count } endpoint endpoint-tx? @ if tx-count else rx-buffer-size rx-count - then ; 
 : usb-update-buffer-control { buffer-control-val endpoint -- } endpoint endpoint-buffer-control @ { buffer-control } buffer-control-val USB_BUF_CTRL_AVAIL and if buffer-control-val USB_BUF_CTRL_AVAIL bic buffer-control ! code[ b> >mark b> >mark b> >mark b> >mark b> >mark b> >mark ]code then buffer-control-val buffer-control ! ; 
 : usb-console-continue-transfer { endpoint -- } endpoint usb-console-count endpoint endpoint-max-packet-size @ min { bytes } endpoint endpoint-tx? @ bytes 0<> or if bytes [ USB_BUF_CTRL_AVAIL USB_BUF_CTRL_SEL or ] literal or { buffer-control-val } endpoint endpoint-tx? @ if endpoint endpoint-buffer @ bytes over + swap ?do read-tx i c! loop buffer-control-val USB_BUF_CTRL_FULL or to buffer-control-val then endpoint endpoint-next-pid @ if USB_BUF_CTRL_DATA1_PID else USB_BUF_CTRL_DATA0_PID then buffer-control-val or to buffer-control-val USB_BUF_CTRL_LAST buffer-control-val or to buffer-control-val endpoint endpoint-next-pid @ 1 xor endpoint endpoint-next-pid ! buffer-control-val endpoint usb-update-buffer-control then ; 
 : usb-console-rx [: { endpoint } endpoint endpoint-buffer-control @ @ { buffer-control-val } [ USB_SIE_STATUS_BIT_STUFF_ERROR USB_SIE_STATUS_CRC_ERROR or ] literal USB_SIE_STATUS bit@ not if buffer-control-val USB_BUF_CTRL_FULL and if buffer-control-val USB_BUF_CTRL_LEN_MASK and { bytes } endpoint endpoint-buffer @ bytes over + swap ?do i c@ usb-special-enabled @ if dup ctrl-c = if drop reboot else attention? @ if usb-out-core-lock release-core-lock [: attention-hook @ execute ;] try usb-out-core-lock claim-core-lock ?raise else dup ctrl-t = if usb-out-core-lock release-core-lock drop [: attention-start-hook @ execute ;] try usb-out-core-lock claim-core-lock ?raise else write-rx then then then else write-rx then loop then then USB_SIE_STATUS @ [ USB_SIE_STATUS_DATA_SEQ_ERROR USB_SIE_STATUS_RX_TIMEOUT or USB_SIE_STATUS_BIT_STUFF_ERROR or USB_SIE_STATUS_CRC_ERROR or ] literal and USB_SIE_STATUS ! ;] usb-out-core-lock with-core-lock ; 
 : usb-console-start-transfer { endpoint -- } endpoint endpoint-tx? @ if usb-in-core-lock else usb-out-core-lock then endpoint [: { endpoint } endpoint usb-console-continue-transfer ;] rot with-core-lock ; 
 : usb-continue-transfer { endpoint -- } endpoint endpoint-data-len @ endpoint endpoint-max-packet-size @ min { bytes } bytes [ USB_BUF_CTRL_AVAIL USB_BUF_CTRL_SEL or ] literal or { buffer-control-val } endpoint endpoint-tx? @ if endpoint endpoint-data-buffer @ if endpoint endpoint-data-buffer @ endpoint endpoint-buffer @ bytes move bytes endpoint endpoint-data-buffer +! then buffer-control-val USB_BUF_CTRL_FULL or to buffer-control-val bytes negate endpoint endpoint-data-len +! then endpoint endpoint-next-pid @ if USB_BUF_CTRL_DATA1_PID else USB_BUF_CTRL_DATA0_PID then buffer-control-val or to buffer-control-val endpoint endpoint-data-len @ 0= if USB_BUF_CTRL_LAST buffer-control-val or to buffer-control-val then endpoint endpoint-next-pid @ 1 xor endpoint endpoint-next-pid ! buffer-control-val endpoint usb-update-buffer-control ; 
 : usb-rx { endpoint -- } endpoint endpoint-buffer-control @ @ { buffer-control-val } buffer-control-val USB_BUF_CTRL_LEN_MASK and { bytes } endpoint endpoint-tx? @ not if endpoint endpoint-data-buffer @ if endpoint endpoint-buffer @ endpoint endpoint-data-buffer @ bytes move bytes endpoint endpoint-data-buffer +! then bytes endpoint endpoint-data-total-len +! bytes negate endpoint endpoint-data-len +! then ; 
 : usb-handle { endpoint -- } endpoint usb-rx endpoint endpoint-data-len @ 0> if endpoint usb-continue-transfer then ; 
 : usb-start-transfer { addr bytes endpoint -- } addr endpoint endpoint-data-buffer ! bytes endpoint endpoint-data-len ! endpoint usb-continue-transfer ; 
 : usb-ack-out-request 0 0 endpoint0-in usb-start-transfer ; 
 : usb-set-device-addr USB_SETUP_PACKET setup-pkt-value h@ usb-device-addr ! true set-usb-device-addr ! usb-ack-out-request ; 
 : usb-set-device-config true prepare-usb-device-configd? ! usb-ack-out-request ; 
 : usb-set-line USB_SETUP_PACKET setup-pkt-value h@ 1 and 0<> usb-dtr? ! usb-ack-out-request ; 
 : usb-handle-device-descr device-data USB_SETUP_PACKET setup-pkt-length h@ device-data-size min endpoint0-in usb-start-transfer ; 
 : usb-handle-config-descr config-data USB_SETUP_PACKET setup-pkt-length h@ 9 = if 9 else config-data-size then endpoint0-in usb-start-transfer ; 
 : usb-handle-string-descr usb-ack-out-request ; 
 : usb-handle-setup-pkt 1 endpoint0-in endpoint-next-pid ! USB_SETUP_PACKET setup-pkt-request-type c@ case USB_DIR_OUT of USB_SETUP_PACKET setup-pkt-request c@ case USB_REQUEST_SET_ADDRESS of usb-set-device-addr endof USB_REQUEST_SET_CONFIGURATION of usb-set-device-config endof usb-ack-out-request endcase endof %00100001 of USB_SETUP_PACKET setup-pkt-request c@ case USB_REQUEST_SET_LINE of usb-set-line endof usb-ack-out-request endcase endof USB_DIR_IN of USB_SETUP_PACKET setup-pkt-request c@ case USB_REQUEST_GET_DESCRIPTOR of USB_SETUP_PACKET setup-pkt-value h@ 8 rshift case USB_DT_DEVICE of usb-handle-device-descr endof USB_DT_CONFIG of usb-handle-config-descr endof USB_DT_STRING of usb-handle-string-descr endof endcase endof usb-ack-out-request endcase endof usb-ack-out-request endcase ; 
 : usb-handle-bus-reset 0 USB_ADDR_ENDP ! 0 usb-device-addr ! false set-usb-device-addr ! false prepare-usb-device-configd? ! false usb-device-configd? ! false endpoint1-out-ready? ! false endpoint1-in-ready? ! false usb-rx-pending-op-enabled? ! false usb-dtr? ! 0 rx-read-index ! 0 rx-write-index ! 0 tx-read-index ! 0 tx-write-index ! ; 
 : usb-partial-rx usb-rx-pending-op-enabled? @ if false usb-rx-pending-op-enabled? ! rx-count rx-buffer-size 64 - <= endpoint1-out-ready? @ and if false endpoint1-out-ready? ! endpoint1-out usb-console-start-transfer then then ; 
 : usb-attempt-rx rx-count rx-buffer-size 64 - <= endpoint1-out-ready? @ and if true usb-rx-pending-op-enabled? ! ['] usb-partial-rx usb-rx-pending-op set-pending-op then ; 
 : usb-attempt-tx ['] usb-partial-tx usb-tx-pending-op set-pending-op ; 
 : handle-usb-irq USB_BUFF_STATUS @ dup { buff-status } USB_BUFF_STATUS ! USB_INTS @ { ints } buff-status 1 USB_BUFF_STATUS_EP_OUT and if endpoint1-out usb-console-rx true endpoint1-out-ready? ! usb-attempt-rx then buff-status 1 USB_BUFF_STATUS_EP_IN and if true endpoint1-in-ready? ! usb-attempt-tx then buff-status 2 USB_BUFF_STATUS_EP_IN and if endpoint2-in usb-handle then buff-status 0 USB_BUFF_STATUS_EP_IN and if endpoint0-in usb-handle prepare-usb-device-configd? @ if true usb-device-configd? ! false prepare-usb-device-configd? ! true endpoint1-out-ready? ! true endpoint1-in-ready? ! usb-attempt-rx usb-attempt-tx 0 0 endpoint0-out usb-start-transfer else set-usb-device-addr @ if usb-device-addr @ USB_ADDR_ENDP ! false set-usb-device-addr ! else 0 0 endpoint0-out usb-start-transfer then then then ints USB_INTS_SETUP_REQ and if USB_SIE_STATUS_SETUP_REC USB_SIE_STATUS ! usb-handle-setup-pkt then ints USB_INTS_BUS_RESET and if USB_SIE_STATUS_BUS_RESET USB_SIE_STATUS ! usb-handle-bus-reset then ; 
 : init-usb true usb-special-enabled ! usb-out-core-lock init-core-lock usb-in-core-lock init-core-lock 0 rx-read-index ! 0 rx-write-index ! 0 tx-read-index ! 0 tx-write-index ! reset-usb USB_DPRAM_Base dpram-size 0 fill 0 USB_ADDR_ENDP ! 0 usb-device-addr ! false set-usb-device-addr ! false prepare-usb-device-configd? ! false usb-device-configd? ! false endpoint1-out-ready? ! false endpoint1-in-ready? ! false usb-dtr? ! false usb-rx-pending-op-enabled? ! usb-pending-op-priority usb-rx-pending-op register-pending-op usb-pending-op-priority usb-tx-pending-op register-pending-op 0 usbctrl-irq NVIC_IPR_IP! ['] handle-usb-irq usbctrl-vector vector! usbctrl-irq NVIC_ISER_SETENA! [ USB_USB_MUXING_TO_PHY USB_USB_MUXING_SOFTCON or ] literal USB_USB_MUXING ! [ USB_USB_PWR_VBUS_DETECT USB_USB_PWR_VBUS_DETECT_OVERRIDE_EN or ] literal USB_USB_PWR ! USB_MAIN_CTRL_CONTROLLER_EN USB_MAIN_CTRL ! USB_SIE_CTRL_EP0_INT_1BUF USB_SIE_CTRL ! [ USB_INTS_BUFF_STATUS USB_INTS_BUS_RESET or USB_INTS_SETUP_REQ or ] literal USB_INTE ! init-usb-endpoints [ USB_SIE_CTRL_EP0_INT_1BUF USB_SIE_CTRL_PULLUP_EN or ] literal USB_SIE_CTRL ! ; 
 : usb-emit? usb-dtr? @ usb-device-configd? @ and tx-full? not and ; 
 : usb-emit begin [: [: usb-dtr? @ usb-device-configd? @ and if tx-full? not if write-tx true else false then usb-attempt-tx else false then ;] critical ;] usb-in-core-lock with-core-lock dup not if pause then until ; 
 : usb-key? usb-device-configd? @ rx-empty? not and ; 
 : usb-key begin [: [: usb-device-configd? @ if rx-empty? not if read-rx true else false then usb-attempt-rx else false then ;] critical ;] usb-out-core-lock with-core-lock dup not if pause then until ; 
 : usb-flush-console begin tx-empty? endpoint1-in-ready? @ and dup not if usb-dtr? @ usb-device-configd? @ and if usb-attempt-tx then pause then until ; 
 : usb-console ['] usb-key? key?-hook ! ['] usb-key key-hook ! ['] usb-emit? emit?-hook ! ['] usb-emit emit-hook ! ['] usb-emit? error-emit?-hook ! ['] usb-emit error-emit-hook ! ['] usb-flush-console flush-console-hook ! ['] usb-flush-console error-flush-console-hook ! ; 
 : with-usb-input ['] usb-key ['] usb-key? rot with-input ; 
 : with-usb-output ['] usb-emit ['] usb-emit? rot ['] usb-flush-console swap with-output ; 
 : with-usb-error-output ['] usb-emit ['] usb-emit? rot ['] usb-flush-console swap with-error-output ; 
 : local-buf-size constant ; 
 : local-buf-top variable ; 
 : local-buf-bottom variable ; 
 : block-locals-size constant ; 
 : block-locals-top variable ; 
 : cell-local constant ; 
 : cell-addr-local constant ; 
 : double-local constant ; 
 : double-addr-local constant ; 
 : do-i-local constant ; 
 : do-limit-local constant ; 
 : do-leave-local constant ; 
 : x-out-of-locals ." cr ; 
 : x-loop-var-not-found ." cr ; 
 : find-loop-var begin dup local-buf-bottom @ < while dup c@ 2 pick = if nip exit then dup c@ dup double-local = swap double-addr-local = or if 1+ dup c@ 1+ + rot 2 + -rot else 1+ dup c@ 1+ + rot 1+ -rot then repeat drop 2drop ['] x-loop-var-not-found ?raise ; 
 : find-i-var 0 do-i-local local-buf-top @ find-loop-var drop ; 
 : find-limit-var 0 do-limit-local local-buf-top @ find-loop-var drop ; 
 : find-leave-var 0 do-leave-local local-buf-top @ find-loop-var drop ; 
 : find-j-var 0 do-i-local local-buf-top @ find-loop-var 2 + swap 1+ swap do-i-local swap find-loop-var drop ; 
 : reset-local local-buf local-buf-size + dup local-buf-top ! local-buf-bottom ! block-locals block-locals-size + block-locals-top ! ; 
 : local-count 0 local-buf-top @ begin dup local-buf-bottom @ < while dup c@ dup double-local = swap double-addr-local = or if 1+ dup c@ 1+ + swap 2 + swap else 1+ dup c@ 1+ + swap 1+ swap then repeat drop ; 
 : add-local dup 1+ local-buf-top @ swap - local-buf >= averts x-out-of-locals dup 1+ negate local-buf-top +! dup local-buf-top @ c! local-buf-top @ 1+ swap move -1 local-buf-top +! dup local-buf-top @ c! dup double-local = swap double-addr-local = or if 2 else 1 then block-locals-top @ c+! ; 
 : add-noname-local local-buf-top @ 1- local-buf >= averts x-out-of-locals -1 local-buf-top +! 0 local-buf-top @ c! -1 local-buf-top +! dup local-buf-top @ c! dup double-local = swap double-addr-local = or if 2 else 1 then block-locals-top @ c+! ; 
 : fill-locals dup 0> if undefer-lit dup 4 * negate 0 literal, [ armv6m-instr import ] r0 addsp,sp,4_ 0 ?do i 4 * tos str_,[sp,#_] tos 1 dp ldm loop [ armv6m-instr unimport ] else drop then ; 
 : push-locals local-buf-top @ 1- local-buf > averts x-out-of-locals local-buf-top @ local-buf local-buf-size + < if local-buf-bottom @ local-buf-top @ - local-buf-top @ 1- c! local-buf-top @ 1- dup local-buf-bottom ! local-buf-top ! then block-locals-top @ block-locals 2 + >= averts x-out-of-locals -1 block-locals-top +! $FF block-locals-top @ c! -1 block-locals-top +! 0 block-locals-top @ c! ; 
 : push-block-locals block-locals-top @ block-locals > averts x-out-of-locals -1 block-locals-top +! 0 block-locals-top @ c! ; 
 : drop-locals local-count ?dup if undefer-lit [ armv6m-instr import ] dup 128 < if 4 * addsp,sp,#_ else 4 * 0 literal, r0 addsp,sp,4_ then [ armv6m-instr unimport ] then ; 
 : drop-block-locals block-locals-top @ block-locals block-locals-size + < if block-locals-top @ c@ dup $FF <> if ?dup if undefer-lit [ armv6m-instr import ] dup 128 < if 4 * addsp,sp,#_ else 4 * 0 literal, r0 addsp,sp,4_ then [ armv6m-instr unimport ] then else drop then then ; 
 : drop-loop-locals find-leave-var 1+ undefer-lit [ armv6m-instr import ] dup 128 < if 4 * addsp,sp,#_ else 4 * 0 literal, r0 addsp,sp,4_ then [ armv6m-instr unimport ] ; 
 : clear-locals local-buf-bottom @ local-buf local-buf-size + < if local-buf-bottom @ 1+ local-buf-top ! local-buf-bottom @ c@ local-buf-top @ + local-buf-bottom ! else local-buf-bottom @ local-buf-top ! then block-locals-top @ block-locals block-locals-size + < if begin block-locals-top @ c@ $FF = 1 block-locals-top +! until then ; 
 : clear-block-locals block-locals-top @ c@ dup $FF <> if begin ?dup while local-buf-top @ dup c@ >r 1+ c@ 2 + local-buf-top +! r@ double-local = r> double-addr-local = or if 2 - else 1- then repeat 1 block-locals-top +! else drop then ; 
 : ignore-local-comment begin token dup if s" equal-strings? else 2drop eval-eof @ ?dup if execute else true then if clear-locals true else display-prompt refill false then then until ; 
 : compile-get-cell-local undefer-lit 6 push, [ armv6m-instr import ] 4 * r6 ldr_,[sp,#_] [ armv6m-instr unimport ] ; 
 : compile-get-double-local undefer-lit 6 push, [ armv6m-instr import ] dup 1+ 4 * r6 ldr_,[sp,#_] [ armv6m-instr unimport ] 6 push, [ armv6m-instr import ] 4 * r6 ldr_,[sp,#_] [ armv6m-instr unimport ] ; 
 : compile-get-cell-addr-local undefer-lit 6 push, [ armv6m-instr import ] 4 * r6 add_,sp,#_ [ armv6m-instr unimport ] ; 
 : parse-get-local 2>r 0 local-buf-top @ begin dup local-buf-bottom @ < while dup 1+ count 2r@ equal-case-strings? if rdrop rdrop c@ case cell-local of compile-get-cell-local endof cell-addr-local of compile-get-cell-addr-local endof double-local of compile-get-double-local endof double-addr-local of compile-get-cell-addr-local endof endcase true exit else dup c@ dup double-local = swap double-addr-local = or if 1+ dup c@ 1+ + swap 2 + swap else 1+ dup c@ 1+ + swap 1+ swap then then repeat rdrop rdrop 2drop false ; 
 : compile-set-cell-local undefer-lit [ armv6m-instr import ] 4 * tos str_,[sp,#_] [ armv6m-instr unimport ] 6 pull, ; 
 : compile-set-double-local [ armv6m-instr import ] dup 4 * tos str_,[sp,#_] [ armv6m-instr unimport ] 6 pull, [ armv6m-instr import ] 1+ 4 * tos str_,[sp,#_] [ armv6m-instr unimport ] 6 pull, ; 
 : parse-set-local 2>r 0 local-buf-top @ begin dup local-buf-bottom @ < while dup 1+ count 2r@ equal-case-strings? if rdrop rdrop c@ case cell-local of compile-set-cell-local endof cell-addr-local of compile-set-cell-local endof double-local of compile-set-double-local endof double-addr-local of compile-set-double-local endof endcase true exit else dup c@ dup double-local = swap double-addr-local = or if 1+ dup c@ 1+ + swap 2 + swap else 1+ dup c@ 1+ + swap 1+ swap then then repeat rdrop rdrop 2drop false ; 
 : compile-add-cell-local undefer-lit [ armv6m-instr import ] dup 4 * r0 ldr_,[sp,#_] r0 tos tos adds_,_,_ 4 * tos str_,[sp,#_] [ armv6m-instr unimport ] 6 pull, ; 
 : compile-add-double-local undefer-lit [ armv6m-instr import ] dup 1+ 4 * r1 ldr_,[sp,#_] dup 4 * r2 ldr_,[sp,#_] r3 1 dp ldm r3 r1 r1 adds_,_,_ tos r2 adcs_,_ dup 1+ 4 * r1 str_,[sp,#_] 4 * r2 str_,[sp,#_] tos 1 dp ldm [ armv6m-instr unimport ] ; 
 : parse-add-local 2>r 0 local-buf-top @ begin dup local-buf-bottom @ < while dup 1+ count 2r@ equal-case-strings? if rdrop rdrop c@ case cell-local of compile-add-cell-local endof cell-addr-local of compile-add-cell-local endof double-local of compile-add-double-local endof double-addr-local of compile-add-double-local endof endcase true exit else dup c@ dup double-local = swap double-addr-local = or if 1+ dup c@ 1+ + swap 2 + swap else 1+ dup c@ 1+ + swap 1+ swap then then repeat rdrop rdrop 2drop false ; 
 : 2value? 2 + h@ $3F08 = ; 
 : value-field@ dup h@ $FF and 2 lshift 2 + + 4 align ; 
 : value-addr@ value-field@ @ ; 
 : value-init@ value-field@ cell+ @ ; 
 : 2value-init@ value-field@ cell+ 2@ ; 
 : compile-to-value undefer-lit dup 2value? if value-addr@ 0 literal, [ armv6m-instr import ] 0 r0 r6 str_,[_,#_] 6 pull, 4 r0 r6 str_,[_,#_] 6 pull, [ armv6m-instr unimport ] else value-addr@ 0 literal, [ armv6m-instr import ] 0 r0 r6 str_,[_,#_] 6 pull, [ armv6m-instr unimport ] then ; 
 : compile-+to-value undefer-lit dup 2value? if value-addr@ 0 literal, [ armv6m-instr import ] 4 r0 r1 ldr_,[_,#_] 0 r0 r2 ldr_,[_,#_] r3 1 dp ldm r3 r1 r1 adds_,_,_ tos r2 adcs_,_ 4 r0 r1 str_,[_,#_] 0 r0 r2 str_,[_,#_] tos 1 dp ldm [ armv6m-instr unimport ] else value-addr@ 0 literal, [ armv6m-instr import ] 0 r0 r1 ldr_,[_,#_] tos r1 r1 adds_,_,_ 0 r0 r1 str_,[_,#_] tos 1 dp ldm [ armv6m-instr unimport ] then ; 
 : init-flash-values flash-latest begin ?dup while dup word-flags h@ init-value-flag and if dup >xt dup 2value? if dup 2value-init@ rot value-addr@ 2! else dup value-init@ swap value-addr@ ! then then next-word @ repeat ; 
 : saved-word-begin-hook variable ; 
 : saved-word-exit-hook variable ; 
 : saved-word-end-hook variable ; 
 : saved-word-reset-hook variable ; 
 : saved-block-begin-hook variable ; 
 : saved-block-exit-hook variable ; 
 : saved-block-end-hook variable ; 
 : saved-parse-hook variable ; 
 : init-values word-begin-hook @ saved-word-begin-hook ! word-exit-hook @ saved-word-exit-hook ! word-end-hook @ saved-word-end-hook ! word-reset-hook @ saved-word-reset-hook ! block-begin-hook @ saved-block-begin-hook ! block-exit-hook @ saved-block-exit-hook ! block-end-hook @ saved-block-end-hook ! parse-hook @ saved-parse-hook ! [: saved-word-begin-hook @ ?execute push-locals ;] word-begin-hook ! [: drop-locals saved-word-exit-hook @ ?execute ;] word-exit-hook ! [: clear-locals saved-word-end-hook @ ?execute ;] word-end-hook ! [: saved-word-reset-hook @ ?execute reset-local ;] word-reset-hook ! [: saved-block-begin-hook @ ?execute push-block-locals ;] block-begin-hook ! [: drop-block-locals saved-block-exit-hook @ ?execute ;] block-exit-hook ! [: clear-block-locals saved-block-end-hook @ ?execute ;] block-end-hook ! [: state @ if 2dup parse-get-local not if saved-parse-hook @ ?dup if execute else 2drop false then else 2drop true then else saved-parse-hook @ ?dup if execute else 2drop false then then ;] parse-hook ! reset-local init-flash-values ; 
 : parse-local-with-type begin token dup if add-local true else 2drop eval-eof @ ?dup if execute display-prompt refill false else drop clear-locals ['] x-token-expected ?raise then then until ; 
 : type-my-base base @ dup { saved-base } case #10 of ." endof dup #10 base ! (.) saved-base base ! endcase ; 
 : my-prompt ." then .s cr ; 
 : field-count constant ; 
 : init-fields c" field-array 5 cells + ! ; 
 : max-field-length { array array-count -- length } 0 array array-count cells + array ?do i @ c@ max cell +loop ; 
 : max-index-length { max-index -- } max-index s>d <# #s #> nip ; 
 : emit-field-char { row max-length index array -- } array index cells + @ { field } field c@ { field-length } max-length row - field-length > if space else field-length max-length row - - { char-index } field 1+ char-index + c@ emit then ; 
 : emit-index-char { index-length row index -- } index s>d <# #s #> { index-addr index-bytes } index-length row - index-bytes > if space else index-bytes index-length row - - { char-index } index-addr char-index + c@ emit then ; 
 : print-fields { array array-count -- } cr array array-count max-field-length { max-length } max-length 0 ?do 0 array-count 1- ?do j max-length i array emit-field-char space -1 +loop cr loop cr array-count max-index-length { index-length } index-length 0 ?do 0 array-count 1- ?do index-length j i emit-index-char space -1 +loop loop ; 
 : run-test init-fields field-array field-count print-fields ; 
 : max-length constant ; 
 : reproduce-count constant ; 
 : mutate-numerator constant ; 
 : mutate-denominator constant ; 
 : target-length variable ; 
 : massage-char dup [char] A >= over [char] Z <= and not if dup [char] a >= over [char] z <= and if char] a - [char] A + else rop $20 then then ; 
 : massage-target target-length @ begin ?dup while 1- >r target-buffer r@ + c@ massage-char target-buffer r@ + c! r> repeat ; 
 : prepare-target max-length min dup target-length ! target-buffer swap move massage-target ; 
 : random-char random 27 umod dup 26 < if [char] A + else drop $20 then ; 
 : prepare-current target-length @ begin ?dup while 1- random-char over current-buffer + c! repeat ; 
 : mutate random mutate-denominator umod mutate-numerator < if drop random-char then ; 
 : reproduce-score 0 target-length @ begin ?dup while 1- >r current-buffer r@ + c@ mutate dup reproduce-buffer r@ + c! target-buffer r@ + c@ = if 1+ then r> repeat ; 
 : score-current 0 target-length @ begin ?dup while 1- >r current-buffer r@ + c@ target-buffer r@ + c@ = if + then r> repeat ; 
 : make-candidate reproduce-buffer candidate-buffer target-length @ move ; 
 : make-current candidate-buffer current-buffer target-length @ move ; 
 : reproduce reproduce-score make-candidate reproduce-count 1- begin ?dup while 1- >r reproduce-score 2dup < if ake-candidate nip else rop then r> repeat ; 
 : run-weasel prepare-target prepare-current score-current cr 0 . . current-buffer target-length @ type 0 begin 1+ cr dup . reproduce make-current dup . current-buffer target-length @ type target-length @ = key? or until drop ; 
 : max-length constant ; 
 : reproduce-count constant ; 
 : mutate-numerator constant ; 
 : mutate-denominator constant ; 
 : target-length variable ; 
 : massage-char dup [char] A >= over [char] Z <= and not if dup [char] a >= over [char] z <= and if char] a - [char] A + else rop $20 then then ; 
 : massage-target target-length @ 0 ?do target-buffer i + c@ massage-char target-buffer i + c! loop ; 
 : prepare-target max-length min dup target-length ! target-buffer swap move massage-target ; 
 : random-char random 27 umod dup 26 < if [char] A + else drop $20 then ; 
 : prepare-current target-length @ 0 ?do random-char current-buffer i + c! loop ; 
 : mutate random mutate-denominator umod mutate-numerator < if drop random-char then ; 
 : reproduce reproduce-count 0 ?do target-length @ 0 ?do urrent-buffer i + c@ mutate reproduce-buffer max-length j * + i + c! loop loop ; 
 : score-current 0 target-length @ 0 ?do current-buffer i + c@ target-buffer i + c@ = if + then loop ; 
 : score 0 target-length @ 0 ?do over max-length * reproduce-buffer + i + c@ target-buffer i + c@ = if + then loop nip ; 
 : high-score 0 0 score reproduce-count 0 ?do i score 2dup < if ip nip i swap else rop then loop ; 
 : run-weasel prepare-target prepare-current score-current cr 0 . . current-buffer target-length @ type 0 begin 1+ cr dup . reproduce high-score dup . over -1 <> if wap max-length * reproduce-buffer + current-buffer target-length @ ove else rop then current-buffer target-length @ type target-length @ = key? or until drop ; 
 : spi-index constant ; 
 : miso-pin constant ; 
 : cs-pin constant ; 
 : clk-pin constant ; 
 : mosi-pin constant ; 
 : handshake-pin constant ; 
 : server-port constant ; 
 : found-mux variable ; 
 : server-active? variable ; 
 : server-task variable ; 
 : server-delay constant ; 
 : rx-read-index variable ; 
 : rx-write-index variable ; 
 : rx-buffer-size constant ; 
 : rx-index-mask constant ; 
 : tx-read-index variable ; 
 : tx-write-index variable ; 
 : tx-buffer-size constant ; 
 : tx-index-mask constant ; 
 : rx-full? rx-write-index @ rx-read-index @ rx-buffer-size 1- + rx-index-mask and = ; 
 : rx-empty? rx-read-index @ rx-write-index @ = ; 
 : write-rx rx-full? not if rx-write-index @ rx-buffer + c! rx-write-index @ 1+ rx-index-mask and rx-write-index ! else drop then ; 
 : read-rx rx-empty? not if rx-read-index @ rx-buffer + c@ rx-read-index @ 1+ rx-index-mask and rx-read-index ! else 0 then ; 
 : tx-full? tx-write-index @ tx-read-index @ tx-buffer-size 1- + tx-index-mask and = ; 
 : tx-empty? tx-read-index @ tx-write-index @ = ; 
 : write-tx tx-full? not if tx-write-index @ tx-buffer + c! tx-write-index @ 1+ tx-index-mask and tx-write-index ! else drop then ; 
 : read-tx tx-empty? not if tx-read-index @ tx-buffer + c@ tx-read-index @ 1+ tx-index-mask and tx-read-index ! else 0 then ; 
 : find-client -1 found-mux @ = if status ['] esp-at-status@ device with-esp-at status esp-at-status-count@ 0> if 0 status esp-at-status-mux@ dup found-mux ! true else 0 false then else found-mux @ true then ; 
 : do-server begin [: server-delay ms server-active? @ if [: poll-esp-at ;] device with-esp-at [: tx-empty? ;] server-slock with-slock not if find-client if { mux } [: 0 { count } tx-read-index @ tx-write-index @ < if tx-write-index @ tx-read-index @ - to count tx-buffer tx-read-index @ + actual-tx-buffer count move else tx-read-index @ tx-write-index @ > if tx-buffer-size tx-read-index @ - { first-count } tx-buffer tx-read-index @ + actual-tx-buffer first-count move tx-buffer actual-tx-buffer first-count + tx-write-index @ move first-count tx-write-index @ + to count then then 0 tx-read-index ! 0 tx-write-index ! count ;] server-slock with-slock { count } actual-tx-buffer count mux ['] multi>esp-at device with-esp-at else drop [: 0 tx-read-index ! 0 tx-write-index ! ;] server-slock with-slock then then then ;] try if [: ['] test-esp-at device with-esp-at ;] try ?dup if int-io::serial-console cr display-red execute display-normal true else false then else false then until ; 
 : do-rx-data [: { c-addr bytes mux } c-addr bytes + c-addr ?do rx-full? not if i c@ write-rx else leave then loop ;] server-slock with-slock ; 
 : telnet-emit server-active? @ if begin [: tx-full? not if write-tx true else false then ;] server-slock with-slock dup not if server-delay ms then until else drop then ; 
 : telnet-emit? server-active? @ if [: tx-full? not ;] server-slock with-slock else false then ; 
 : telnet-key begin server-active? @ if [: rx-empty? not if read-rx true else false then ;] server-slock with-slock dup not if server-delay ms then else false then until ; 
 : telnet-key? server-active? @ if [: rx-empty? not ;] server-slock with-slock else false then ; 
 : telnet-type { c-addr bytes -- } c-addr bytes + c-addr ?do i c@ telnet-emit loop ; 
 : init-test server-slock init-slock 0 tx-read-index ! 0 tx-write-index ! 0 rx-read-index ! 0 rx-write-index ! -1 found-mux ! <wio-esp-at-spi> intf init-object intf <esp-at> device init-object <esp-at-status> status init-object 200000 device esp-at-timeout! true intf esp-at-log! [: { device } station-mode device init-esp-at ;] device with-esp-at 0 ['] do-server 320 128 768 1 spawn-on-core server-task ! server-task @ run ; 
 : connect-wifi [: { D: password D: ssid device } begin password ssid device [: 4 pick 4 pick 4 pick 4 pick 4 pick connect-esp-at-wifi ;] try nip nip nip nip nip dup 0= if drop true else dup ['] x-esp-at-error = if drop cr ." then ;] device with-esp-at ; 
 : start-server [: { device } true device esp-at-multi! ['] do-rx-data device esp-at-recv-xt! server-port device start-esp-at-server true server-active? ! ;] device with-esp-at ; 
 : telnet-console false intf esp-at-log! ['] telnet-key key-hook ! ['] telnet-key? key?-hook ! ['] telnet-emit emit-hook ! ['] telnet-emit? emit?-hook ! ; 
 : reset-wifi [: reset-esp-at ;] device with-esp-at ; 
 : configure-power { device -- } disable-sleep-mode device esp-at-sleep! device esp-at-wifi-power@ cr ." dup . 80 >= if leave then loop then ; 
 : connect-to-ap { D: password D: ssid device -- } begin password ssid device [: 4 pick 4 pick 4 pick 4 pick 4 pick connect-esp-at-wifi ;] try nip nip nip nip nip dup 0= if drop true else dup ['] x-esp-at-error = if drop cr ." loop cr false else ?raise then then until ; 
 : station-info { device -- } device esp-at-station-ipv4-addr@ if cr ." then ; 
 : resolve-google { device -- } resolve-ipv4-only s" then ; 
 : single-google-request { device -- } [: cr ." device single>esp-at systick::systick-counter { start-time } begin device poll-esp-at systick::systick-counter start-time - 100000 >= until status device esp-at-status@ status esp-at-status. device close-esp-at-single ; 
 : multi-google-request { device -- } [: cr ." 0 device multi>esp-at systick::systick-counter { start-time } begin device poll-esp-at systick::systick-counter start-time - 100000 >= until status device esp-at-status@ status esp-at-status. 0 device close-esp-at-multi ; 
 : run-test <wio-esp-at-spi> intf init-object intf <esp-at> device init-object <esp-at-status> status init-object true intf esp-at-log! 200000 device esp-at-timeout! [: { D: password D: ssid device } station-mode device init-esp-at device configure-power password ssid device connect-to-ap device station-info device resolve-google device single-google-request device multi-google-request ;] device with-esp-at ; 
 : get-status [: { device } status device esp-at-status@ status esp-at-status. ;] device with-esp-at ; 
 : start-line-time variable ; 
 : last-line-time variable ; 
 : start-word-count variable ; 
 : current-word-rate variable ; 
 : maximum-last-line-diff constant ; 
 : line-interval constant ; 
 : dict-word-count 0 swap begin dup while swap 1+ swap next-word @ repeat drop ; 
 : word-count ram-latest dict-word-count flash-latest dict-word-count + ; 
 : handle-line systick-counter dup last-line-time @ - maximum-last-line-diff <= if last-line-time ! 0 word-count start-word-count @ - 0 last-line-time @ start-line-time @ - 10000,0 f/ f/ f. else dup last-line-time ! start-line-time ! word-count start-word-count ! then do-prompt ; 
 : enable-word-speed systick-counter dup start-line-time ! last-line-time ! word-count start-word-count ! ['] handle-line prompt-hook ! ; 
 : disable-word-speed ['] do-prompt prompt-hook ! ; 
